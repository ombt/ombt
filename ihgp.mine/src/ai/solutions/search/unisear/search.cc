/*
 * Copyright (C) 1995, 1996 Peter Bouthoorn.
 *
 * This software may be freely distributed and modified provided
 * this copyright message is left intact. The copyright message must be
 * included both with this (the original) software and with any modified
 * copies of this software or with any new software based on this software.
 * Furthermore any modified copies of this software must carry prominent
 * notices stating the software was changed and the date of any change.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. In no event
 * will the copyright holder be liable for any damage arising out of
 * the use of this software.
 *
 * As a matter of courtesy, the author requests to be informed about
 * any bugs found in this software and about improvements that may be of
 * general interest.
 *
 * Peter Bouthoorn
 * peter@obelix.icce.rug.nl
 */

#include "aisearch.h"

/* 
 * The constructor puts the start node on OPEN, saves the goal node
 * so that goal checking can take place and sets the number of operators
 * to the specified value.
 */
Search::Search(int op, Node *start, Node *goal)
{
    if (start)
        open.addtohead(start);
    num_op = op;
    goalnode = goal;
    solgoal = 0;
}


/*
 * The destructor only needs to remove the goal node that was stored
 * by the constructor. The destruction of OPEN and CLOSED is taken care
 * of automatically by the destructors of the list objects.
 */
Search::~Search()
{
    delete(goalnode);
}


/*
 * get_goal() returns the solution node only, i.e. the last node 
 * generated by the search (if it was successfull).
 */
Node *Search::get_goal() const
{
    return(solgoal);
}


/*
 * get_sol() returns the solution path: it stores the nodes that belong
 * to the solution path in an object of type IntrList<Node> which
 * is allocated dynamically. This routine removes these nodes from the
 * the search tree and adds them to the solution list. This means that
 * after get_sol() has been called the state space is in an
 * inconsistent state and the search object can no longer be used (to
 * do any further searches). This is not a problem because the search
 * algorithm wasn't designed this way way anyway: generate() can be
 * called only once to generate one solution (a search algorithm
 * that generates multiple solutions can be found in class BackTrack
 * which implements a backtracking algorithm). For this reason get_sol()
 * calls clear() after it's done.
 */
IntrList<Node> *Search::get_sol()
{
    Node *cur;
    IntrList<Node> *ret;

    if (!solgoal)
	return(0);

    ret = new IntrList<Node>;

    /*
     * Because all nodes that are part of the solution path must be on
     * CLOSED we know which list to remove them from. It would be
     * cleaner to copy every node, but that would be much less efficient.
     */
    for (cur = solgoal; cur; cur = cur->getparent())
    {
	closed.remove_node(cur, NoDel);
	ret->addtohead(cur);
    }
    clear();
    return(ret);
}


/*
 * set_goalnode() saves the goal node of the problem. This function
 * can be called if passing the goal node through the constructor of
 * class Search is for some reason not feasible or if the search
 * space has been cleared by clear() and a new search must be started.
 */
void Search::set_goalnode(Node *node)
{
    goalnode = node;
}


/*
 * set_startnode() adds the node used to start the search on open.
 * This function can be called if passing the start node through the
 * constructor of class Search is for some reason not feasible or if
 * the search space has been cleared by clear() and a new search must
 * be started.
 */
void Search::set_startnode(Node *node)
{
    open.addtohead(node);
}


/*
 * is_goal() checks if the specified node is a goal node. Note that
 * the equality operator used to do the checking is a pure virtual
 * function, so that the method used to compare the nodes is defined
 * by the problem at hand.
 */
int Search::is_goal(const Node *node)
{
#ifdef DEBUG
    if (!node)
    {
	puts("Search::is_goal() called with 0 (NULL) argument - did you forget to implement is_goal()?");
	exit(0);
    }
#endif
    return(*goalnode == *node);
}


/*
 * clear() clears the state space so that the object can be reused for a
 * new problem.
 */
void Search::clear()
{
    open.clear(DoDel);
    closed.clear(DoDel);

    delete goalnode;
    goalnode = solgoal = 0;
}


/*
 * display() prints the solution path.
 */
void Search::display() const
{
    if (solgoal)
       print_sol(solgoal);
}


/*
 * print_sol() traces back through the parent pointers of each node until
 * it finds the root node and then prints each node. Depending on the
 * length of the solution path this could result in a lot of recursive calls.
 */
void Search::print_sol(Node *node) const
{
    if (!node)
        return;
    print_sol(node->getparent());
    node->display();
}


/*
 * generate() starts the search.
 * generate() returns 1 if a solution was found and 0 otherwise.
 */
int Search::generate()
{
    solgoal = solve();
    return(solgoal != 0);
}


/*
 * solve() implements the actual search engine. The steps taken by
 * this routine are:
 *
 * 1. Get the first node from OPEN. If OPEN is empty the search ends
 *    with failure. Otherwise move the node to CLOSED.
 * 2. Check if the node is a goal node. If true, the search ends with
 *    success.
 * 3. Expand the node by generating its successor nodes. If there are
 *    no successors continue with step 1. Otherwise for every
 *    successor do the following:
 *    4. Set successor to point back to the node (which is its parent node),
 *       so that the solution can be traced back afterwards.
 *    5. Pass the node to add() for further processing. If add() returns
 *       0 the node is already part of the search graph and must be
 *       done away with. Add() is a virtual function implemented by
 *       a derivative of Search. The implementation of add() defines
 *       the type of search: depth-first, breadth-first, best-first, etc.
 *
 * solve() returns the goal node if found and 0 otherwise.
 */
Node *Search::solve()
{
    IntrList<Node>
        *succlist;
    Node
        *father,
        *child;

    while((father = open.gethead()) != 0)  // get first node from open
    {                                         
        open.remove_head(NoDel);	      // non-destructive removal
        closed.addtohead(father);             // put it on closed

	if (is_goal(father))                  // check for goal node
	    return(father);

        if (!(succlist = father->expand(num_op)))  // expand the node
	    continue;

        while ((child = succlist->gethead()))
        {
            succlist->remove_head(NoDel);
            child->setparent(father);   // set successor's parent pointer
            if (!add(child))		// add successor to graph
                delete(child);          // successor already in graph
#ifdef DEBUG
	    else
	    {
		puts("adding node:");
		child->display();
		putchar('\n');
	    }
#endif
	}
	delete(succlist);
    }
    return(0);
}

