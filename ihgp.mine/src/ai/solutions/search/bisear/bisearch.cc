/*
 * Copyright (C) 1995, 1996 Peter Bouthoorn.
 *
 * This software may be freely distributed and modified provided
 * this copyright message is left intact. The copyright message must be
 * included both with this (the original) software and with any modified
 * copies of this software or with any new software based on this software.
 * Furthermore any modified copies of this software must carry prominent
 * notices stating the software was changed and the date of any change.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. In no event
 * will the copyright holder be liable for any damage arising out of
 * the use of this software.
 *
 * As a matter of courtesy, the author requests to be informed about
 * any bugs found in this software and about improvements that may be of
 * general interest.
 *
 * Peter Bouthoorn
 * peter@obelix.icce.rug.nl
 */

#include "bisearch.h"

/*
 * The constructor puts the start node on S-OPEN, the goal node on
 * T-OPEN and sets the number of operators to the specified value.
 */
BiSearch::BiSearch(int op, Node *start, Node *goal)
{
    if (start)
        s_open.addtohead(start);
    if (goal)
        t_open.addtohead(goal);
    num_op = op;
}


/*
 * The destructor does nothing. The destruction of S-OPEN, S-CLOSED,
 * T-OPEN and T-CLOSED is taken care of automatically by the destructors
 * of the list objects.
 */
BiSearch::~BiSearch()
{
}


/*
 * get_sol() returns the solution path: it stores the nodes that belong
 * to the solution path in an object of type IntrList<Node> which
 * is allocated dynamically. This routine removes these nodes from the
 * the search tree and adds them to the solution list. This means that
 * after get_sol() has been called the state space is in an
 * inconsistent state and the search object can no longer be used (to
 * do any further searches). This is not a problem because the search
 * algorithm wasn't designed this way way anyway: generate() can be
 * called only once to generate one solution (a search algorithm
 * that generates multiple solutions can be found in class BackTrack
 * which implements a backtracking algorithm). For this reason get_sol()
 * calls clear() after it's done.
 */
IntrList<Node> *BiSearch::get_sol()
{
    Node *cur;
    IntrList<Node> *ret;

    if (!foundsol)
	return(0);

    ret = new IntrList<Node>;

    /*
     * Each of the search paths (one generated by the forward search,
     * the other by the backward search) contains a node that is also on
     * the other path; this is the node that connects both of these paths.
     * Both of these nodes are stored by solve() at the head of the closed
     * lists of the respective searches. These nodes will be the
     * starting point for retrieving the solution path. Because these two
     * nodes are actually the same only one of them is needed, so skip the
     * one that's at the head of S_CLOSED.
     */
    for (cur = s_closed.gethead()->getparent(); cur; cur = cur->getparent())
    {
	s_closed.remove_node(cur, NoDel);
	ret->addtohead(cur);
    }
    for (cur = t_closed.gethead(); cur; cur = cur->getparent())
    {
	t_closed.remove_node(cur, NoDel);
	ret->addtotail(cur);
    }
    clear();
    return(ret);
}


/*
 * set_goalnode() saves the goal node of the problem. This function
 * can be called if passing the goal node through the constructor of
 * class BiSearch is for some reason not feasible or if the search
 * space has been cleared by clear() and a new search must be started.
 */
void BiSearch::set_goalnode(Node *node)
{
    t_open.addtohead(node);
}


/*
 * set_startnode() adds the node used to start the search on open.
 * This function can be called if passing the start node through the
 * constructor of class BiSearch is for some reason not feasible or if
 * the search space has been cleared by clear() and a new search must
 * be started.
 */
void BiSearch::set_startnode(Node *node)
{
    s_open.addtohead(node);
}


/*
 * clear() clears the state space so that the object can be reused for a
 * new problem.
 */
void BiSearch::clear()
{
    s_open.clear(DoDel);
    s_closed.clear(DoDel);
    t_open.clear(DoDel);
    t_closed.clear(DoDel);
}


/*
 * display() prints the solution path.
 */
void BiSearch::display() const
{
    if (foundsol)
    {
#ifdef DEBUG
        puts("Printing first half of solution path");
#endif
        print_sol(s_closed.gethead()->getparent());
#ifdef DEBUG
        puts("Printing second half of solution path");
#endif
        print_sol_2(t_closed.gethead());
    }
}


/*
 * print_sol() traces back through the parent pointers of each node until
 * it finds the root node and then prints each node. Depending on the
 * length of the solution path this could result in a lot of recursive calls.
 * This function is called to print the part of the solution path
 * generated by the forward search.
 */
void BiSearch::print_sol(Node *sol) const
{
    if (!sol)
        return;
    print_sol(sol->getparent());
    sol->display();
}


/*
 * print_sol_2 is called to print the part of the solution path generated
 * by the forward search.
 */
void BiSearch::print_sol_2(Node *sol) const
{
    while (sol)
    {
        sol->display();
        sol = sol->getparent();
    }
}


/*
 * generate() starts the search.
 * generate() returns 1 if a solution was found and 0 otherwise.
 */
int BiSearch::generate()
{
    foundsol = bisolve() ? 1 : 0;
    return(foundsol);
}


/*
 * bisolve() determines if the search will be continued backward or
 * forward: if S-OPEN contains fewer nodes than T-OPEN the search will
 * proceed forward, otherwise the search will proceed backward. If both
 * lists are empty the search ends with failure.
 */
Node *BiSearch::bisolve()
{
    Node
        *node = 0;

    while (node == 0)
    {
	if (s_open.getcount() && s_open.getcount() <= t_open.getcount())
            node = solve(&s_open, &s_closed, &t_closed);  // search forward
	else if (t_open.getcount())
            node = solve(&t_open, &t_closed, &s_closed);  // search backward
	else
	    break;
    }
    return(node);
}


/*
 * solve() implements the actual search engine. The steps taken by
 * this routine are:
 *
 * 1. Get the first node from xOPEN (xOPEN is the OPEN list of one
 *    of the searches: one proceeding forward, the other proceeding
 *    backward). xOPEN is guaranteed not to be empty, because this
 *    condition has been checked by bisolve(). Move the node to xCLOSED.
 * 2. Expand the node by generating its successor nodes. If there are
 *    no successors exit. Otherwise for every successor do the
 *    following:
 *    3. Set successor to point back to the node (which is its parent node),
 *       so that the solution can be traced back afterwards.
 *    4. Check if the successor is also on yClosed (the closed list
 *       of the search proceding in the other direction). If true,
 *       a node (or actually: two nodes) has been found that connects
 *       both search paths and the search ends with success.
 *    5. Pass the successor to add() for further processing. If add()
 *       returns 0 the node is already part of the search graph and must be
 *       done away with. Add() is a virtual function implemented by
 *       a derivative of BiSearch. The implementation of add() defines
 *       the type of search: depth-first, breadth-first, etc.
 *
 * Solve() return the node that connects both paths if found and 0 (NULL)
 * otherwise.
 */
Node *BiSearch::solve(IntrList<Node> *x_open, IntrList<Node> *x_closed,
IntrList<Node> *y_closed)
{
    IntrList<Node>
        *succlist;
     Node
        *father,
        *child,
        *aux = 0;

    father = x_open->gethead();			   // get first node from open
    x_open->remove_head(NoDel);			   // non-destructive removal
    x_closed->addtohead(father);		   // move it to closed

    if (!(succlist = father->expand(num_op)))      // expand node
	return(0);

    while ((child = succlist->gethead()) != 0)
    {
        succlist->remove_head(NoDel);
        child->setparent(father);                     // set up solution path

        if ((aux = y_closed->lookup(child)) != 0)
	{					      // the two paths connect
	    /* 
	     * The nodes that connect both search paths are stored at the
             * the head of the CLOSED lists for later reference.
	     */
	    y_closed->remove_found(NoDel);
	    y_closed->addtohead(aux);
	    x_closed->addtohead(child);
	    break;
	}

        if (!add(x_open, x_closed, child))	// add successor to graph
            delete(child);			// successor already in graph
#ifdef DEBUG
        else
        {
            puts("adding node:");
            child->display();
            putchar('\n');
	}
#endif
    }
    delete(succlist);
    return(aux);
}
