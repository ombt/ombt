#!/opt/exp/bin/perl -w 
#!/opt/exp/bin/perl -w -d:DProf
#
# SIP simulator.
#
########################################################################
#
# path for finding modules
#
use lib "/home/lcstools/tools/bin";
#
# modules
#
use Fcntl;
use Storable qw(dclone);
use IO::Socket;
use Getopt::Std;
#
use mytimer;
use mypqueue;
#
#########################################################################
#
# global data
#
$debugflag = 0;
$logflag = 0;
$verboseflag = 0;
#
# any parameter or dndata must have a default value defined below. if not,
# when it is detected, the simulator will report it and exit.
#
%parameters = (
	branch => "z9hG4bk",
	delta => 10,
	minmsgsize => 10,
	logfile => "",
	mysipip => "127.0.0.1",
	mysipport => 5060,
	myrtpip => "127.0.0.1",
	myrtpport => 8000,
	myrtcpport => 8001,
	maxforwards => 70,
);
#
%dndata = (
	DEFAULT => {
		dn => undef,
		dnstate => "INACTIVE",
		callloadstate => "INACTIVE",
		registrationstate => "INACTIVE",
		originationstate => "INACTIVE",
		terminationstate => "INACTIVE",
		registrar => "registrar",
		registration => "register",
		origination => "origination",
		termination => "termination",
		ipaddress => "127.0.0.1",
		sipip => "127.0.0.1",
		sipport => 5060,
		rtpip => "127.0.0.1",
		rtpport => 8000,
		rtcpip => "127.0.0.1",
		rtcpport => 8001,
		expires => 600,
		interregistertime => 120,
		maxcallduration => 60,
		waitingforackduration => 10,
		waitingfor200duration => 10,
		waitingfor202duration => 10,
		ringingduration => 1,
		prerefercallduration => 10,
	},
);
#
%dialogs = (
	DEFAULT => {
		dn => undef,
		cseq => undef,
		timertag => undef,
		handler => undef,
		contact => undef,
	},
);
#
%statistics = (
	origination => {
		started => 0,
		stable => 0,
		abandoned => 0,
		timedout => 0,
	},
	termination => {
		started => 0,
		stable => 0,
		abandoned => 0,
		timedout => 0,
	},
);
#
%loaddata = (
	state => "idle",
	callspersec => 0.0,
	maxcalls => 0,
	callsstarted => 0,
	holdtime => 0,
	calls => { },
	origdns => [ ],
	currentorigdn => 0,
	origdnssz => 0,
	tag => -1,
);
#
use subs qw(printit);
use subs qw(dprint);
use subs qw(vprint);
#
########################################################################
#
# functions
#
sub usage {
	printit "\n";
	printit "usage: sipsim [-?xV] [-l logfile] [configfile]\n";
	printit "\n";
	printit "if a configfile is not given, then the default config\n";
	printit "file 'sipsimcfg' is read from the current directory.\n";
}
#
sub dprint {
	my ($msg) = @_;
	if ($debugflag) {
		printit $msg;
	}
}
sub vprint {
	my ($msg) = @_;
	if ($verboseflag) {
		printit $msg;
	}
}
sub printit {
	my ($msg) = @_;
	#
	if ($logflag) {
		print LOGFILE ${msg};
	}
	print STDERR ${msg};
}
#
sub dumpdndata {
	#
	return unless ($verboseflag);
	#
	vprint "\n";
	vprint "Dumping DN-Data structure:\n";
	foreach $key (sort keys %dndata) {
		vprint "dn = $key\n";
		foreach $key2 (sort keys %{$dndata{$key}}) {
			vprint "\t$key2 = ";
			if (defined($dndata{$key}{$key2})) {
				vprint "$dndata{$key}{$key2}\n";
			} else {
				vprint "====>>>> UNDEFINED <<<<====\n";
			}
		}
	}
}
#
sub dumpparams {
	#
	return unless ($verboseflag);
	#
	vprint "\n";
	vprint "Parameters:\n";
	foreach $param (sort keys %parameters) {
		vprint "\t$param = $parameters{$param}\n";
	}
}
#
sub dumphdrs {
	my ($phdrs) = @_;
	#
	return unless ($verboseflag);
	#
	vprint "\nHeader Fields:\n";
	foreach $key (sort keys %{$phdrs}) {
		if (defined($phdrs->{$key})) {
			vprint "$key = $phdrs->{$key}\n";
		} else {
			vprint "$key NOT DEFINED.\n";
		}
	}
}
sub auditPQ {
	my ($pq) = @_;
	printit "\nAudit Priority Queue Contents:\n";
	if ($pq->isEmpty()) {
		printit "PQ is empty.\n";
		return;
	}
	if ($pq->count() == 1) {
		printit "PQ has one member.\n";
		return;
	}
	my $count = 0;
	my $pos1=$pq->first();
	for (my $pos2=$pos1->{next}; 
	     defined($pos1) && defined($pos2); 
	     $pos1=$pos2, $pos2=$pos2->{next}) {
		my $ptimer1 = $pos1->{data};
		my $ptimer2 = $pos2->{data};
		if ($ptimer1->cmp($ptimer2) > 0) {
			$count += 1;
			printit "\nREVERSED ENTRIES IN QUEUE !!!\n";
			printit "\tT1: callid = ".$ptimer1->{callid}."\n";
			printit "\tT1: expire = ".$ptimer1->{expire}."\n";
			printit "\tT1: id     = ".$ptimer1->{id}."\n";
			printit "\tT1: label  = ".$ptimer1->{label}."\n";
			printit "\tT2: callid = ".$ptimer2->{callid}."\n";
			printit "\tT2: expire = ".$ptimer2->{expire}."\n";
			printit "\tT2: id     = ".$ptimer2->{id}."\n";
			printit "\tT2: label  = ".$ptimer2->{label}."\n";
		}
	}
	if ($count > 0) {
		printit "$count PQ entries reversed.\n";
	} else {
		printit "PQ is sane.\n";
	}
}
#
sub dumpPQ {
	my ($pq) = @_;
	printit "\nPriority Queue Contents:\n";
	for (my $pos=$pq->first(); defined($pos); $pos=$pos->{next}) {
		my $ptimer = $pos->{data};
		printit "\tcallid = ".$ptimer->{callid}."\n";
		printit "\texpire = ".$ptimer->{expire}."\n";
		printit "\tid     = ".$ptimer->{id}."\n";
		printit "\tlabel  = ".$ptimer->{label}."\n";
	}
}
#
sub dumpIncomingMsg {
	my ($recvpaddr, $msg) = @_;
	#
	return unless ($verboseflag);
	#
	my ($recvport, $recvipaddr) = sockaddr_in($recvpaddr);
	$recvipaddr = inet_ntoa($recvipaddr);
	my $recvaddr = "$recvipaddr:$recvport";
	#
	vprint "\n";
	vprint "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< incoming msg\n";
	vprint "FROM IP/PORT: $recvaddr\n";
	my @newmsg = split /[\r\n]+/, $msg;
	foreach $line (@newmsg) {
		vprint "line=<$line>\n";
	}
	vprint "<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< incoming msg\n";
}
#
sub dumpOutgoingMsg {
	my ($recvpaddr, $msg) = @_;
	#
	return unless ($verboseflag);
	#
	my ($recvport, $recvipaddr) = sockaddr_in($recvpaddr);
	$recvipaddr = inet_ntoa($recvipaddr);
	my $recvaddr = "$recvipaddr:$recvport";
	#
	vprint "\n";
	vprint ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> outgoing msg\n";
	vprint "TO IP/PORT: $recvaddr\n";
	my @newmsg = split /[\r\n]+/, $msg;
	foreach $line (@newmsg) {
		vprint "line=<$line>\n";
	}
	vprint ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> outgoing msg\n";
}
#
sub dumptimer {
	my ($timerflag, $ptimer) = @_;
	#
	return unless ($verboseflag);
	#
	vprint "\nTimer data:\n";
	vprint "\ttimer flag = ${timerflag}\n";
	vprint "\tcallid = ".$ptimer->{callid}."\n";
	vprint "\texpire = ".$ptimer->{expire}."\n";
	vprint "\tid     = ".$ptimer->{id}."\n";
	vprint "\tlabel  = ".$ptimer->{label}."\n";
}
#
sub incrstats {
	my ($state, $type) = @_;
	#
	if (defined($statistics{$state}{$type})) {
		$statistics{$state}{$type} += 1;
	} else {
		$statistics{$state}{$type} = 1;
	}
}
#
sub readconfigfile {
	my ($configfile) = @_;
	#
	my $dntype = "individual";
	my $nodefaults = 0;
	my $syntaxerrors = 0;
	my $dn = "UNKNOWNDN";
	open(CONFIGFILE, $configfile) or die "can't open $configfile: $!";
	while (defined($crec = <CONFIGFILE>)) {
		# remove newline
		chomp($crec);
		# skip comments
		if ($crec =~ /^[\s]*#/) {
			next;
		}
		# is it a parameter?
		if ($crec =~ /^parameter/i) {
			my ($dummy, $parameter, $value) = split /\s+/, $crec, 3;
			if (!defined($dummy) || !defined($parameter) ||
			    !defined($value)) {
				printit "\n";
				printit "skipping record <$crec>.\n";
				printit "not in a 'parameter key value' format.\n";
				$syntaxerrors += 1;
				next;
			}
			if (!exists($parameters{$parameter}))
			{
				$nodefaults += 1;
				printit "\n";
				printit "parameter $parameter has NO default value.\n";
			}
			$parameters{$parameter} = $value;
			next;
		}
		# is it a ORIGDN CNT pair?
		if ($crec =~ /^rcall/) {
			my ($dummy, $origdn, $termdn, $cnt) = split /\s+/, $crec, 4;
			if (!defined($dummy) || !defined($origdn) ||
			    !defined($termdn) || !defined($cnt)) {
				printit "\n";
				printit "skipping record <$crec>.\n";
				printit "not in a 'rcall origdn termdn count' format.\n";
				$syntaxerrors += 1;
				next;
			}
			for (my $i=0; $i<$cnt; ${i}++) {
				my $odn = $origdn + $i;
				my $tdn = $termdn + $i;
				$loaddata{calls}{$odn} = $tdn;
				if (!exists($dndata{$odn})) {
					printit "$odn has NO dndata.\n";
					$syntaxerrors += 1;
				}
				if (!exists($dndata{$tdn})) {
					printit "$tdn has NO dndata.\n";
					$syntaxerrors += 1;
				}
			}
			next;
		}
		# get name-value pair
		my ($key, $value) = split /\s*=\s*/, $crec, 2;
		if (!defined($key) || !defined($value)) {
			printit "\n";
			printit "skipping record <$crec>.\n";
			printit "not in a 'key=value' format.\n";
			$syntaxerrors += 1;
			next;
		}
		#
		if ($key =~ /^dn/) {
			$dn = $value;
			$dndata{$dn} = dclone($dndata{DEFAULT});
			$dndata{$dn}{dn} = $dn;
			$dntype = "individual";
		} elsif ($key =~ /^rdn/) {
			($mindn, $dncnt) = split /\s+/, $value, 2;
			if (!defined($mindn) || !defined($dncnt)) {
				printit "\n";
				printit "skipping record <$crec>.\n";
				printit "not in a 'rdn startdn cnt' format.\n";
				$syntaxerrors += 1;
				next;
			}
			for (my $i=0; $i<$dncnt; ${i}++) {
				$dn = $mindn + $i;
				$dndata{$dn} = dclone($dndata{DEFAULT});
				$dndata{$dn}{dn} = $dn;
			}
			$dntype = "range";
		} else {
			if (!exists($dndata{DEFAULT}{$key}))
			{
				$nodefaults += 1;
				printit "\n";
				printit "field $key has NO default value.\n";
			}
			if ($dntype eq "individual") {
				$dndata{$dn}{$key} = $value;
			} elsif ($dntype eq "range") {
				for (my $i=0; $i<$dncnt; ${i}++) {
					$dn = $mindn + $i;
					$dndata{$dn}{$key} = $value;
				}
			} else {
				printit "readconfigfile: invalid dntype: $dntype\n";
				exit 2;
			}
		}
	}
	close(CONFIGFILE);
	#
	if ($nodefaults) {
		printit "\n";
		printit "$nodefaults field(s) found with NO defaults.\n";
	}
	if ($syntaxerrors) {
		printit "\n";
		printit "$syntaxerrors syntax error(s) found in config file.\n";
	}
	if ($nodefaults || $syntaxerrors) {
		printit "exiting.\n";
		exit 2;
	}
	#
	# generate list of originating DNs.
	#
	my $odncnt = scalar(keys %{$loaddata{calls}});
	if ($odncnt > 0) {
		printit "\n$odncnt ORIG-TERM DN pairs read.\n";
		@{$loaddata{origdns}} = sort keys %{$loaddata{calls}};
		$loaddata{origdnsz} = @{$loaddata{origdns}};
	}
	#
	return;
}
#
sub dumpfld {
	my ($fldname, $phdrs) = @_;
	#
	return unless ($verboseflag);
	#
	my $maxi = $#{$phdrs->{$fldname}};
	for (my $i = 0; $i <= $maxi; ${i}++) {
		vprint "$fldname\[$i\] = $phdrs->{$fldname}[$i]\n";
	}
}
#
sub dn2mysipuri {
	my ($dn) = @_;
	my $myip = $parameters{mysipip};
	my $myport = $parameters{mysipport};
	my $mycontact = "sip:${dn}\@${myip}";
	return($mycontact);
}
#
sub dn2contact {
	my ($dn) = @_;
	# dprint "dn2contact: dn=$dn\n";
	#
	my $ip = $dndata{$dn}{sipip};
	my $port = $dndata{$dn}{sipport};
	my $contact = "sip:${dn}\@${ip}:${port}";
	#
	# dprint "dn2contact: contact=$contact\n";
	return($contact);
}
#
sub getCseqNo {
	my ($cseq) = @_;
	$cseq =~ /^[\s]*([0-9]+)[\s]+/;
	return($1);
}
sub getCseqMethod {
	my ($cseq) = @_;
	$cseq =~ /^[\s]*[0-9]+[\s]+([^\s]+)/;
	return($1);
}
#
sub makerequesturi {
	my ($callid, $field) = @_;
	#
	my $from = $dialogs{$callid}{$field};
	$from =~ /^.*sip:([^@]+)@([0-9\.]+).*$/;
	#
	my $dn = $1;
	my $ip = $2;
	#
	my $requesturi = "sip:${dn}\@${ip}";
	return($requesturi);
}
#
sub dumpSDP {
	my ($psdp) = @_;
	#
	return unless ($verboseflag);
	#
	vprint "\n";
	vprint "SDP CONTENTS: \n";
	foreach $line (@{${psdp}}) {
		vprint "$line\n";
	}
}
#
sub makeSDP {
	my ($dn, $psdp) = @_;
	#
	$$psdp = "";
	$$psdp .= "v=0\n";
	$$psdp .= "o=$dn 0 $dndata{$dn}{rtpport} IN IP4 $dndata{$dn}{rtpip}\n";
	$$psdp .= "s=-\n";
	$$psdp .= "c=IN IP4 $dndata{$dn}{rtpip}\n";
	$$psdp .= "t=0 0\n";
	$$psdp .= "m=audio $dndata{$dn}{rtpport} RTP/AVP 0\n";
	$$psdp .= "a=rtpmap:0 pcmu/$dndata{$dn}{rtpport}\n";
}
#
sub parseSipMsg {
	my ($rawmsg, $prawhdr, $prawdata, $phdrs, $pdatablocks) = @_;
	#
	# separate the hdr from the payload.
	#
	($$prawhdr, $$prawdata) = split /[\r\n]{4,4}/, $rawmsg, 2;
	return unless (defined($$prawhdr));
	#
	# split fields in header. each header field is 
	# separated by CRLF. each header in turn is separated
	# by commas first, then semicolons. also, headers can 
	# be repeated. each repeated header field can be combined
	# into one header field separated by commas. each header field
	# can contain parameters which are separated by semicolons.
	#
	my @fldhdrs = split /[\r\n]+/, $$prawhdr;
	#
	# get the type of msg
	#
	my ($fld1, $fld2) = split /\s+/, $fldhdrs[0];
	$phdrs->{msgtype} = $fld1;
	if ($phdrs->{msgtype} =~ /^SIP\/2.0/) {
		$phdrs->{msgtype} = "RETURNCODE";
		$phdrs->{returncode} = $fld2;
	}
	#
	# split the remaining flds. combine multiple lines
	# into one line.
	#
	my $nflds = scalar @fldhdrs;
	for (my $ifld = 1; $ifld < $nflds; ${ifld}++) {
		my ($fldname, $fldvalue) = 
			split /\s*:\s*/, $fldhdrs[$ifld], 2;
		if (!exists($phdrs->{$fldname})) {
			$phdrs->{$fldname} = $fldvalue;
		} else {
			$phdrs->{$fldname} .= ",".$fldvalue;
		}
	}
	#
	# get data specific to msg type.
	#
	my $dummy = undef;
	if ($phdrs->{msgtype} =~ /^REGISTER/) {
		$dummy = $phdrs->{"To"};
		$dummy =~ /^.*[<]*sip:([0-9]+)@.*$/;
		$dummy = $1;
		if (defined($dummy)) {
			$phdrs->{"dn"} = $dummy;
		}
		my $callid = $phdrs->{"Call-ID"};
		if (!defined($dialogs{$callid})) {
			# first time, create dialog
			$dialogs{$callid}{dn} = $phdrs->{"dn"};
			$dialogs{$callid}{contact} = $phdrs->{"Contact"};
			$dialogs{$callid}{mycontact} = 
				dn2contact($phdrs->{"dn"});
			$dialogs{$callid}{cseq} = 
				getCseqNo($phdrs->{"CSeq"});
			$dialogs{$callid}{handler} = 
				$dndata{$phdrs->{"dn"}}{registrar};
			$dialogs{$callid}{"timertag"} = 0;
			$dialogs{$callid}{"mytag"} = int(rand(1000000000));
			$dialogs{$callid}{"mytag"} .= "mytag";
			# save additional fields when timers expire and
			# we need to send msgs.
			$dialogs{$callid}{from} = $phdrs->{"From"};
			$dialogs{$callid}{to} = $phdrs->{"To"};
			$dialogs{$callid}{via} = $phdrs->{"Via"};
			$dialogs{$callid}{maxforwards} = 
				$phdrs->{"Max-Forwards"};
			$dialogs{$callid}{requesturi} = 
				makerequesturi($callid, "contact");
		}
	} elsif ($phdrs->{msgtype} =~ /^INVITE/) {
		$dummy = $phdrs->{"To"};
		$dummy =~ /^.*[<]*sip:([0-9]+)@.*$/;
		$dummy = $1;
		if (defined($dummy)) {
			$phdrs->{"dn"} = $dummy;
		}
		my $callid = $phdrs->{"Call-ID"};
		if (!defined($dialogs{$callid})) {
			# first time, create dialog
			$dialogs{$callid}{dn} = $phdrs->{"dn"};
			$dialogs{$callid}{contact} = $phdrs->{"Contact"};
			$dialogs{$callid}{mycontact} = 
				dn2contact($phdrs->{"dn"});
			$dialogs{$callid}{cseq} = 
				getCseqNo($phdrs->{"CSeq"});
			$dialogs{$callid}{handler} = 
				$dndata{$phdrs->{"dn"}}{termination};
			$dialogs{$callid}{"timertag"} = 0;
			$dialogs{$callid}{"mytag"} = int(rand(1000000000));
			$dialogs{$callid}{"mytag"} .= "mytag";
			# save additional fields when timers expire and
			# we need to send msgs.
			$dialogs{$callid}{from} = $phdrs->{"From"};
			$dialogs{$callid}{to} = $phdrs->{"To"};
			$dialogs{$callid}{via} = $phdrs->{"Via"};
			$dialogs{$callid}{maxforwards} = 
				$phdrs->{"Max-Forwards"};
			$dialogs{$callid}{requesturi} = 
				makerequesturi($callid, "contact");
		}
	}
	#
	if ($phdrs->{msgtype} =~ /^RETURNCODE/) {
		my $cseqmeth = undef;
		if (defined($phdrs->{"CSeq"})) {
			$cseqmeth = getCseqMethod($phdrs->{"CSeq"});
		} 
		if (!defined($cseqmeth)) {
			$cseqmeth = "UNKNOWNMETHOD";
		}
		incrstats("msgs-received", 
			"RETURNCODE".$phdrs->{returncode}.$cseqmeth);
	} else {
		incrstats("msgs-received", $phdrs->{msgtype});
	}
	#
	# any data blocks?
	#
	if ($phdrs->{"Content-Length"} == 0) {
		# no data
		return;
	}
	#
	# split blocks
	#
	if ($phdrs->{"Content-Type"} =~ /^multipart\/mixed/) {
		$phdrs->{"Content-Type"} =~ 
			/^multipart\/mixed;boundary=\"([^\"]+)\"/;
		my $dbdelimiter = $1;
		die "delimiter not found in Content-Type = mixed." unless 
			defined($dbdelimiter);
		@{$pdatablocks} = split /${dbdelimiter}/, $$prawdata;
	} else {
		# only one data block.
		@{$pdatablocks} = [ $$prawdata ];
		# check if we have an SDP block
		if ($phdrs->{"Content-Type"} =~ /application\/sdp/) {
			@{$phdrs->{sdp}} = [];
			@{$phdrs->{sdp}[0]} = split /[\r\n]+/, $$prawdata;
			dumpSDP($phdrs->{sdp}[0]);
		}
	}
	return;
}
#
sub changeDnState {
	my ($dn, $dnstate, $newstate) = @_;
	#
	my $olddnstate = $dndata{$dn}{$dnstate};
	$dndata{$dn}{$dnstate} = $newstate;
	if ($newstate eq "INACTIVE") {
		$dndata{$dn}{callloadstate} = "INACTIVE";
	}
	return unless ($verboseflag);
	vprint("\nOLD $dnstate STATE FOR $dn: ${olddnstate}\n");
	vprint("NEW $dnstate STATE FOR $dn: $dndata{$dn}{$dnstate}\n");
}
#
sub dumpDnState {
	my ($dn, $dnstate) = @_;
	#
	return unless ($verboseflag);
	#
	vprint("\nCURRENT $dnstate STATE FOR $dn: $dndata{$dn}{$dnstate}\n");
}
#
sub isMyTimer {
	my ($callid, $ptimer) = @_;
	#
	my $dialogtag = $dialogs{$callid}{"timertag"};
	my $timertag = $ptimer->{expire};
	#
	my $dialogid = $dialogs{$callid}{"timerid"};
	my $timerid = $ptimer->{id};
	#
	if ($dialogtag != $timertag || $dialogid != $timerid) {
		# it is not my timer
		if ($verboseflag) {
			vprint "\nTimer label: ".$ptimer->{label}."\n";
			vprint "Ignoring old timer (tag=$timertag).\n";
			vprint "(callid=$callid).\n";
		}
		return(0);
	} else {
		# it is my timer
		return(1);
	}
}
#
########################################################################
#
# utility functions to make msgs
#
sub removetimer {
	my ($callid) = @_;
	#
	if (defined($dialogs{$callid}{"ptimer"})) {
		my $ptimer = $dialogs{$callid}{"ptimer"};
		$pq->remove($ptimer);
		$ptimer = undef;
	}
}
#
sub starttimer {
	my ($callid, $delta, $label) = @_;
	#
	my $endtime = time() + $delta;
	my $timerid = int(rand(1000000000));
	if ($delta <= 0) {
		printit "\n\n\n";
		printit "starttimer: ZERO LENGTH TIMER FOR CALL-ID $callid.\n";
		printit "\n\n\n";
	}
	#
	if ($verboseflag) {
		vprint "\nstarttimer:\n";
		vprint "\tcallid=${callid}\n";
		vprint "\tlabel=${label}\n";
		vprint "\tdelta=${delta}\n";
		vprint "\tendtime=$endtime\n";
		vprint "\tid=$timerid\n";
	}
	#
	my $ptimer = "mytimer"->new($callid, $endtime, $timerid, $label);
	#
	$dialogs{$callid}{"timertag"} = $endtime;
	$dialogs{$callid}{"timerid"} = $timerid;
	$dialogs{$callid}{"ptimer"} = $ptimer;
	#
	if ($verboseflag) {
		vprint "\tcallid = ".$ptimer->{callid}."\n";
		vprint "\texpire = ".$ptimer->{expire}."\n";
		vprint "\tid     = ".$ptimer->{id}."\n";
		vprint "\tlabel  = ".$ptimer->{label}."\n";
	}
	#
	$pq->enqueue($ptimer);
	incrstats("general","starttimerenqueuecalled");
}
#
sub makepaddr {
	my ($contact, $callid) = @_;
	#
	my $dcontact = $dialogs{$callid}{$contact};
	$dcontact =~ /^.*<*sip:([^@]+)@([^:]+):([0-9]+).*$/;
	#
	my $dn = $1;
	my $ip = $2;
	my $port = $3;
	#
	my $ipaddr = gethostbyname($ip);
	defined($ipaddr) or die "gethostbyname: $!";
	my $paddr = sockaddr_in($port, $ipaddr);
	defined($paddr) or die "getprotobyname: $!";
	#
	return($paddr);
}
#
sub sendRegister {
	my ($callid, $contact) = @_;
	#
	return;
}
#
sub sendRefer {
	my ($callid, $contact) = @_;
	#
	return;
}
#
sub sendRegister200OK {
	my ($callid, $phdrs, $contact) = @_;
	#
	my $dn = $dialogs{$callid}{dn};
	#
	my $ackmsg = "SIP/2.0 200 OK\r\n";
	$ackmsg .= "Via: ".$phdrs->{"Via"}.";received=";
	$ackmsg .= $parameters{mysipip}."\r\n";
	$ackmsg .= "From: ".$phdrs->{"From"}."\r\n";
	$ackmsg .= "To: ".$phdrs->{"To"}."\r\n";
	$ackmsg .= "Call-ID: ".$phdrs->{"Call-ID"}."\r\n";
	$ackmsg .= "CSeq: ".$phdrs->{"CSeq"}."\r\n";
	$ackmsg .= "Contact: ".$phdrs->{"Contact"}."\r\n";
	$ackmsg .= "Expires: ".$dndata{$dn}{"expires"}."\r\n";
	$ackmsg .= "Content-Length: 0\r\n";
	$ackmsg .= "\r\n";
	#
	my $paddr = makepaddr($contact, $callid);
	dumpOutgoingMsg($paddr, $ackmsg);
	#
	defined(send(SIP, $ackmsg, 0, $paddr)) or die "send: $!";
	#
	my $cseqmeth = undef;
	if (defined($phdrs->{"CSeq"})) {
		$cseqmeth = getCseqMethod($phdrs->{"CSeq"});
	} 
	if (!defined($cseqmeth)) {
		$cseqmeth = "UNKNOWNMETHOD";
	}
	incrstats("msgs-sent", "RETURNCODE200".$cseqmeth);
	return;
}
#
sub sendInvite180Ringing {
	my ($callid, $phdrs, $contact) = @_;
	#
	my $dn = $dialogs{$callid}{dn};
	#
	my $ackmsg = "SIP/2.0 180 Ringing\r\n";
	$ackmsg .= "Via: ".$phdrs->{"Via"}."\r\n";
	$ackmsg .= "From: ".$phdrs->{"From"}."\r\n";
	$ackmsg .= "To: ".$phdrs->{"To"}.";tag=".$dialogs{$callid}{mytag}."\r\n";
	$ackmsg .= "Call-ID: ".$phdrs->{"Call-ID"}."\r\n";
	$ackmsg .= "CSeq: ".$phdrs->{"CSeq"}."\r\n";
	$ackmsg .= "Contact: ".$dialogs{$callid}{mycontact}."\r\n";
	$ackmsg .= "Content-Length: 0\r\n";
	$ackmsg .= "\r\n";
	#
	my $paddr = makepaddr($contact, $callid);
	dumpOutgoingMsg($paddr, $ackmsg);
	#
	defined(send(SIP, $ackmsg, 0, $paddr)) or die "send: $!";
	#
	my $cseqmeth = undef;
	if (defined($phdrs->{"CSeq"})) {
		$cseqmeth = getCseqMethod($phdrs->{"CSeq"});
	} 
	if (!defined($cseqmeth)) {
		$cseqmeth = "UNKNOWNMETHOD";
	}
	incrstats("msgs-sent", "RETURNCODE180".$cseqmeth);
	return;
}
#
sub sendInvite200OK {
	my ($callid, $phdrs, $contact) = @_;
	#
	my $dn = $dialogs{$callid}{dn};
	#
	my $ackmsg = "SIP/2.0 200 OK\r\n";
	$ackmsg .= "Via: ".$phdrs->{"Via"}."\r\n";
	$ackmsg .= "From: ".$phdrs->{"From"}."\r\n";
	$ackmsg .= "To: ".$phdrs->{"To"}.";tag=".$dialogs{$callid}{mytag}."\r\n";
	$ackmsg .= "Call-ID: ".$phdrs->{"Call-ID"}."\r\n";
	$ackmsg .= "CSeq: ".$phdrs->{"CSeq"}."\r\n";
	$ackmsg .= "Contact: ".$dialogs{$callid}{mycontact}."\r\n";
	#
	my $sdp = "";
	makeSDP($dn, \$sdp);
	# dprint "OFFER SDP: $sdp\n";
	#
	my $sdplen = length($sdp);
	$ackmsg .= "Content-Type: application/sdp\r\n";
	$ackmsg .= "Content-Length: $sdplen\r\n";
	$ackmsg .= "\r\n";
	$ackmsg .= "$sdp";
	#
	my $paddr = makepaddr($contact, $callid);
	dumpOutgoingMsg($paddr, $ackmsg);
	#
	defined(send(SIP, $ackmsg, 0, $paddr)) or die "send: $!";
	#
	my $cseqmeth = undef;
	if (defined($phdrs->{"CSeq"})) {
		$cseqmeth = getCseqMethod($phdrs->{"CSeq"});
	} 
	if (!defined($cseqmeth)) {
		$cseqmeth = "UNKNOWNMETHOD";
	}
	incrstats("msgs-sent", "RETURNCODE200".$cseqmeth);
	return;
}
#
sub sendBye {
	my ($callid, $contact) = @_;
	#
	my $dn = $dialogs{$callid}{dn};
	my $requesturi = $dialogs{$callid}{requesturi};
	my $brand = int(rand(1000000000));
	my $newbranch = ${parameters}{branch}.$brand;
	#
	# flip To and From fields in the BYE msg.
	#
	my $ackmsg = "BYE ${requesturi} SIP/2.0\r\n";
	$ackmsg .= "Via: SIP/2.0/UDP ".$parameters{mysipip}.":".$parameters{mysipport}.";branch=".${newbranch}."\r\n";
	$ackmsg .= "From: ".$dialogs{$callid}{to}.";tag=".$dialogs{$callid}{mytag}."\r\n";
	$ackmsg .= "To: ".$dialogs{$callid}{from}."\r\n";
	$ackmsg .= "Call-ID: ".${callid}."\r\n";
	$ackmsg .= "CSeq: ".$dialogs{$callid}{cseq}." BYE\r\n";
	$ackmsg .= "Max-Forwards: ".$dialogs{$callid}{maxforwards}."\r\n";
	$ackmsg .= "Content-Length: 0\r\n";
	$ackmsg .= "\r\n";
	#
	my $paddr = makepaddr($contact, $callid);
	dumpOutgoingMsg($paddr, $ackmsg);
	#
	defined(send(SIP, $ackmsg, 0, $paddr)) or die "send: $!";
	incrstats("msgs-sent", "BYE");
	return;
}
#
sub sendAck {
	my ($callid, $phdrs, $contact) = @_;
	#
	my $dn = $dialogs{$callid}{dn};
	my $requesturi = $dialogs{$callid}{requesturi};
	#
	my $ackmsg = "ACK ${requesturi} SIP/2.0\r\n";
	$ackmsg .= "Via: ".$phdrs->{"Via"}."\r\n";
	$ackmsg .= "From: ".$phdrs->{"From"}."\r\n";
	$ackmsg .= "To: ".$phdrs->{"To"}."\r\n";
	$ackmsg .= "Call-ID: ".$phdrs->{"Call-ID"}."\r\n";
	$ackmsg .= "Cseq: ".$dialogs{$callid}{cseq}." ACK\r\n";
	$ackmsg .= "Contact: ".$dialogs{$callid}{mycontact}."\r\n";
	#
	my $sdp = "";
	makeSDP($dn, \$sdp);
	# dprint "OFFER SDP: $sdp\n";
	#
	my $sdplen = length($sdp);
	$ackmsg .= "Content-Type: application/sdp\r\n";
	$ackmsg .= "Content-Length: $sdplen\r\n";
	$ackmsg .= "\r\n";
	$ackmsg .= "$sdp";
	#
	my $paddr = makepaddr($contact, $callid);
	dumpOutgoingMsg($paddr, $ackmsg);
	#
	defined(send(SIP, $ackmsg, 0, $paddr)) or die "send: $!";
	incrstats("msgs-sent", "ACK");
	return;
}
#
sub sendCancel {
	my ($callid, $contact) = @_;
	#
	my $dn = $dialogs{$callid}{dn};
	my $requesturi = $dialogs{$callid}{requesturi};
	my $brand = int(rand(1000000000));
	my $newbranch = ${parameters}{branch}.$brand;
	#
	# flip To and From fields in the BYE msg.
	#
	my $ackmsg = "CANCEL ${requesturi} SIP/2.0\r\n";
	$ackmsg .= "Via: SIP/2.0/UDP ".$parameters{mysipip}.":".$parameters{mysipport}.";branch=".${newbranch}."\r\n";
	$ackmsg .= "From: ".$dialogs{$callid}{to}.";tag=".$dialogs{$callid}{mytag}."\r\n";
	$ackmsg .= "To: ".$dialogs{$callid}{from}."\r\n";
	$ackmsg .= "Call-ID: ".${callid}."\r\n";
	$ackmsg .= "CSeq: ".$dialogs{$callid}{cseq}." CANCEL\r\n";
	$ackmsg .= "Contact: ".$dialogs{$callid}{mycontact}."\r\n";
	$ackmsg .= "Max-Forwards: ".$dialogs{$callid}{maxforwards}."\r\n";
	$ackmsg .= "Content-Length: 0\r\n";
	$ackmsg .= "\r\n";
	#
	my $paddr = makepaddr($contact, $callid);
	dumpOutgoingMsg($paddr, $ackmsg);
	#
	defined(send(SIP, $ackmsg, 0, $paddr)) or die "send: $!";
	incrstats("msgs-sent", "CANCEL");
	return;
}
#
sub sendInvite {
	my ($callid, $contact) = @_;
	#
	my $dn = $dialogs{$callid}{dn};
	my $requesturi = $dialogs{$callid}{requesturi};
	my $brand = int(rand(1000000000));
	my $newbranch = ${parameters}{branch}.$brand;
	#
	my $ackmsg = "INVITE ${requesturi} SIP/2.0\r\n";
	$ackmsg .= "Via: SIP/2.0/UDP ".$parameters{mysipip}.":".$parameters{mysipport}.";branch=".${newbranch}."\r\n";
	$ackmsg .= "From: ".$dialogs{$callid}{from}.";tag=".$dialogs{$callid}{mytag}."\r\n";
	$ackmsg .= "To: ".$dialogs{$callid}{to}."\r\n";
	$ackmsg .= "Call-ID: ".${callid}."\r\n";
	$ackmsg .= "CSeq: ".$dialogs{$callid}{cseq}." INVITE\r\n";
	$ackmsg .= "Contact: ".$dialogs{$callid}{mycontact}."\r\n";
	$ackmsg .= "Max-Forwards: ".$dialogs{$callid}{maxforwards}."\r\n";
	#
	my $sdp = "";
	makeSDP($dn, \$sdp);
	# dprint "OFFER SDP: $sdp\n";
	#
	my $sdplen = length($sdp);
	$ackmsg .= "Content-Type: application/sdp\r\n";
	$ackmsg .= "Content-Length: $sdplen\r\n";
	$ackmsg .= "\r\n";
	$ackmsg .= "$sdp";
	#
	my $paddr = makepaddr($contact, $callid);
	dumpOutgoingMsg($paddr, $ackmsg);
	#
	defined(send(SIP, $ackmsg, 0, $paddr)) or die "send: $!";
	incrstats("msgs-sent", "INVITE");
	return;
}
#
sub sendGratuitous200OK {
	# sometime we get BYE or CANCEL msgs after a call
	# dies. this keeps up until the other side times out
	# or until the maximum retries is reached. to shut these
	# msgs up, we take the CANCEL or BYE and return a 200 OK.
	#
	my ($phdrs) = @_;
	#
	if (!(($phdrs->{msgtype} =~ /BYE/) ||
	      ($phdrs->{msgtype} =~ /CANCEL/))) {
		# not a BYE or CANCEL
		return;
	}
	#
	my $ackmsg = "SIP/2.0 200 OK\r\n";
	$ackmsg .= "Via: ".$phdrs->{"Via"}.";received=";
	$ackmsg .= $parameters{mysipip}."\r\n";
	$ackmsg .= "From: ".$phdrs->{"From"}."\r\n";
	$ackmsg .= "To: ".$phdrs->{"To"}."\r\n";
	$ackmsg .= "Call-ID: ".$phdrs->{"Call-ID"}."\r\n";
	$ackmsg .= "CSeq: ".$phdrs->{"CSeq"}."\r\n";
	$ackmsg .= "Content-Length: 0\r\n";
	$ackmsg .= "\r\n";
	#
	my $contact = $phdrs->{"Contact"};
	return unless defined($contact);
	$contact =~ /^.*<*sip:([^@]+)@([^:]+):([0-9]+).*$/;
	#
	my $dn = $1;
	return unless defined($dn);
	my $ip = $2;
	return unless defined($ip);
	my $port = $3;
	return unless defined($port);
	#
	my $ipaddr = gethostbyname($ip);
	return unless defined($ipaddr);
	my $paddr = sockaddr_in($port, $ipaddr);
	return unless defined($paddr);
	#
	dumpOutgoingMsg($paddr, $ackmsg);
	#
	defined(send(SIP, $ackmsg, 0, $paddr)) or die "send: $!";
	incrstats("msgs-sent", "RETURNCODE200".$phdrs->{msgtype}."-GRATUITOUS");
	return;
}
#
sub send200OK {
	my ($callid, $phdrs, $contact) = @_;
	#
	my $dn = $dialogs{$callid}{dn};
	#
	my $ackmsg = "SIP/2.0 200 OK\r\n";
	$ackmsg .= "Via: ".$phdrs->{"Via"}.";received=";
	$ackmsg .= $parameters{mysipip}."\r\n";
	$ackmsg .= "From: ".$phdrs->{"From"}."\r\n";
	$ackmsg .= "To: ".$phdrs->{"To"}."\r\n";
	$ackmsg .= "Call-ID: ".$phdrs->{"Call-ID"}."\r\n";
	$ackmsg .= "CSeq: ".$phdrs->{"CSeq"}."\r\n";
	$ackmsg .= "Contact: ".$dialogs{$callid}{mycontact}."\r\n";
	$ackmsg .= "Content-Length: 0\r\n";
	$ackmsg .= "\r\n";
	#
	my $paddr = makepaddr($contact, $callid);
	dumpOutgoingMsg($paddr, $ackmsg);
	#
	defined(send(SIP, $ackmsg, 0, $paddr)) or die "send: $!";
	#
	my $cseqmeth = undef;
	if (defined($phdrs->{"CSeq"})) {
		$cseqmeth = getCseqMethod($phdrs->{"CSeq"});
	} 
	if (!defined($cseqmeth)) {
		$cseqmeth = "UNKNOWNMETHOD";
	}
	incrstats("msgs-sent", "RETURNCODE200".$cseqmeth);
	return;
}
#
sub send486Busy {
	my ($callid, $phdrs, $contact) = @_;
	#
	my $dn = $dialogs{$callid}{dn};
	#
	my $ackmsg = "SIP/2.0 486 Busy\r\n";
	$ackmsg .= "Via: ".$phdrs->{"Via"}.";received=";
	$ackmsg .= $parameters{mysipip}."\r\n";
	$ackmsg .= "From: ".$phdrs->{"From"}."\r\n";
	$ackmsg .= "To: ".$phdrs->{"To"}."\r\n";
	$ackmsg .= "Call-ID: ".$phdrs->{"Call-ID"}."\r\n";
	$ackmsg .= "CSeq: ".$phdrs->{"CSeq"}."\r\n";
	$ackmsg .= "Contact: ".$dialogs{$callid}{mycontact}."\r\n";
	$ackmsg .= "Content-Length: 0\r\n";
	$ackmsg .= "\r\n";
	#
	my $paddr = makepaddr($contact, $callid);
	dumpOutgoingMsg($paddr, $ackmsg);
	#
	defined(send(SIP, $ackmsg, 0, $paddr)) or die "send: $!";
	#
	my $cseqmeth = undef;
	if (defined($phdrs->{"CSeq"})) {
		$cseqmeth = getCseqMethod($phdrs->{"CSeq"});
	} 
	if (!defined($cseqmeth)) {
		$cseqmeth = "UNKNOWNMETHOD";
	}
	incrstats("msgs-sent", "RETURNCODE486".$cseqmeth);
	return;
}
#
##########################################################################
#
# high-level msg handlers
#
sub register {
	my ($callid, $timerflag, $current_time, $recvpaddr, 
	    $pdatablocks, $phdrs, $ptimer) = @_;
	#
	if ($verboseflag) {
		vprint "\nEntry register: Call-ID = <$callid>\n";
		vprint "Timer Flag for $callid = <$timerflag>\n";
	}
	#
	my $dn = $dialogs{$callid}{dn};
	my $regstate = $dndata{$dn}{registrationstate};
	dumpDnState($dn, "registrationstate");
	#
	# check for registrations
	#
	if ($origstate =~ /^INACTIVE$/) {
		# only registration event timers are allowed
		if ($timerflag == 3) {
			# check if my timer
			if (!isMyTimer($callid, $ptimer)) {
				$ptimer = undef;
				return;
			}
			# send a register msg
			$dialogs{$callid}{cseq} += 1;
			sendRegister($callid, "mycontact");
			starttimer($callid, $dndata{$dn}{"waitingfor200duration"}, 
				"WAIT FOR 200 REGISTER");
			changeDnState($dn, "registration", "WAITFOR200");
		} else {
			vprint "\nregistration INACTIVE:\n";
			vprint "Unexpected messge or timer.\n";
			vprint "(callid=$callid).\n";
			$ptimer = undef;
		}
	} elsif ($origstate =~ /^WAITFOR200$/) {
		if ($timerflag) {
			# check if my timer
			if (!isMyTimer($callid, $ptimer)) {
				$ptimer = undef;
				return;
			}
			# timed out, schedule another register attempt.
			$ptimer = undef;
			delete $dialogs{$callid};
			changeDnState($dn, "registration", "INACTIVE");
			queueReg($dn, $dndata{$dn}{interregistertime});
		} elsif ($phdrs->{msgtype} =~ /RETURNCODE/) {
			my $label = "";
			removetimer($callid);
			if ($phdrs->{returncode} == 200) {
				starttimer($callid, $dndata{$dn}{"expires"},
					"REGISTRATION EXPIRES");
				changeDnState($dn, "registrationstate", "REGISTERED");
			} else {
				# registration denied. try again.
				delete $dialogs{$callid};
				changeDnState($dn, "registration", "INACTIVE");
				queueReg($dn, $dndata{$dn}{interregistertime});
			}
		} else {
			vprint "\nregistration WAITFOR200 warning:\n";
			vprint "Unexpected msg $phdrs->{msgtype}.\n";
			vprint "(callid=$callid).\n";
		}
	} elsif ($origstate =~ /^REGISTERED$/) {
		if ($timerflag) {
			# check if my timer
			if (!isMyTimer($callid, $ptimer)) {
				$ptimer = undef;
				return;
			}
			# send a re-register msg
			$dialogs{$callid}{cseq} += 1;
			sendRegister($callid, "mycontact");
			starttimer($callid, $dndata{$dn}{"waitingfor200duration"}, 
				"WAIT FOR 200 REGISTER");
			changeDnState($dn, "registration", "WAITFOR200");
		} else {
			vprint "\nregistration TALKING warning:\n";
			vprint "Unexpected msg $phdrs->{msgtype}.\n";
			vprint "(callid=$callid).\n";
		}
	} else {
		printit "\nregistration - unknown state $origstate error:\n";
		if ($timerflag) {
			printit "Unexpected timer.\n";
			$ptimer = undef;
		}
		printit "(callid=$callid).\n";
	}
}
#
sub registrar {
	my ($callid, $timerflag, $current_time, $recvpaddr, 
	    $pdatablocks, $phdrs, $ptimer) = @_;
	#
	if ($verboseflag) {
		vprint "\nEntry registrar: Call-ID = <$callid>\n";
		vprint "Timer Flag for $callid = <$timerflag>\n";
	}
	#
	my $dn = $dialogs{$callid}{dn};
	my $regstate = $dndata{$dn}{registrationstate};
	dumpDnState($dn, "registrationstate");
	#
	if ($timerflag) {
		if (!isMyTimer($callid, $ptimer)) {
			$ptimer = undef;
			return;
		}
		#
		$ptimer = undef;
		$dialogs{$callid}{"timertag"} = 0;
		changeDnState($dn, "registrationstate", "UNREGISTER");
	} elsif ($phdrs->{msgtype} =~ /^REGISTER$/) {
		sendRegister200OK($callid, $phdrs, "contact");
		removetimer($callid);
		starttimer($callid, $dndata{$dn}{"expires"}, "REGISTRATION TIME OUT");
		changeDnState($dn, "registrationstate", "REGISTER");
	} else {
		printit "\nregistrar REGISTER warning:\n";
		printit "Unexpected msg $phdrs->{msgtype}.\n";
		printit "(callid=$callid).\n";
	}
	return;
}
#
sub origination {
	my ($callid, $timerflag, $current_time, $recvpaddr, 
	    $pdatablocks, $phdrs, $ptimer) = @_;
	#
	if ($verboseflag) {
		vprint "\nEntry origination: Call-ID = <$callid>\n";
		vprint "Timer Flag for $callid = <$timerflag>\n";
	}
	#
	my $dn = $dialogs{$callid}{dn};
	my $origstate = $dndata{$dn}{originationstate};
	dumpDnState($dn, "originationstate");
	#
	# check for originations
	#
	if ($origstate =~ /^INACTIVE$/) {
		# only call orig timers are allowed.
		if ($timerflag == 2) {
			# check if my timer
			if (!isMyTimer($callid, $ptimer)) {
				dumptimer($timerflag, $ptimer);
				incrstats("origination","invalidtimers-1");
				$ptimer = undef;
				return;
			}
			# start up a call, send an INVITE
			$dialogs{$callid}{cseq} += 1;
			sendInvite($callid, "contact");
			incrstats("origination","started");
			incrstats("origination","sendInvite");
			starttimer($callid, $dndata{$dn}{"waitingfor200duration"}, 
				"WAIT FOR 200 INVITE");
			changeDnState($dn, "originationstate", "WAITFOR200");
		} else {
			if ($timerflag) {
				dumptimer($timerflag, $ptimer);
				incrstats("origination","invalidtimers-2");
			} else {
				incrstats("origination","unexpectedmsgs-1");
			}
			vprint "\norigination INACTIVE:\n";
			vprint "Unexpected messge or timer.\n";
			vprint "(callid=$callid).\n";
			$ptimer = undef;
		}
	} elsif ($origstate =~ /^WAITFOR200$/) {
		if ($timerflag) {
			# check if my timer
			if (!isMyTimer($callid, $ptimer)) {
				incrstats("origination","invalidtimers-3");
				if ($timerflag == 2) {
					incrstats("origination","notreadyfororig");
				}
				$ptimer = undef;
				return;
			}
			# cancel call.
			$ptimer = undef;
			$dialogs{$callid}{cseq} += 1;
			sendCancel($callid, "contact");
			incrstats("origination","sendCancel");
			incrstats("origination","timedout-1");
			starttimer($callid, $dndata{$dn}{"waitingfor200duration"}, 
				"WAIT FOR 200 CANCEL");
			changeDnState($dn, "originationstate", 
					"WAITFOR200CANCEL");
		} elsif ($phdrs->{msgtype} =~ /RETURNCODE/) {
			my $label = "";
			if ($phdrs->{returncode} == 100) {
				removetimer($callid);
				starttimer($callid, 
					$dndata{$dn}{"waitingfor200duration"}, 
					"WAIT FOR 200 INVITE (after 100)");
				changeDnState($dn, "originationstate", "WAITFOR200");
				incrstats("origination","received100Invite");
			} elsif ($phdrs->{returncode} == 180) {
				removetimer($callid);
				starttimer($callid, 
					$dndata{$dn}{"waitingfor200duration"}, 
					"WAIT FOR 200 INVITE (after 180)");
				changeDnState($dn, "originationstate", "WAITFOR200");
				incrstats("origination","received180Invite");
			} elsif ($phdrs->{returncode} == 183) {
				removetimer($callid);
				starttimer($callid, 
					$dndata{$dn}{"waitingfor200duration"}, 
					"WAIT FOR 200 INVITE (after 183)");
				changeDnState($dn, "originationstate", "WAITFOR200");
				incrstats("origination","received183Invite");
			} elsif ($phdrs->{returncode} == 200) {
				sendAck($callid, $phdrs, "contact");
				incrstats("origination","sendAck");
				removetimer($callid);
				starttimer($callid, 
					$dndata{$dn}{"maxcallduration"},
					"TALKING MAX CALL LENGTH");
				changeDnState($dn, "originationstate", "TALKING");
				incrstats("origination","stable");
				incrstats("origination","received200Invite");
			} else {
				# call ends.
				removetimer($callid);
				delete $dialogs{$callid};
				changeDnState($dn, "originationstate", "INACTIVE");
				incrstats("origination", "inactive");
			}
		} elsif ($phdrs->{msgtype} =~ /CANCEL/) {
			# last request was canceled. end call.
			send200OK($callid, $phdrs, "contact");
			incrstats("origination","send200OKCancel");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "originationstate", "INACTIVE");
			incrstats("origination","inactive");
		} elsif ($phdrs->{msgtype} =~ /BYE/) {
			# other side is gone.
			send200OK($callid, $phdrs, "contact");
			incrstats("origination","send200OK");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "originationstate", "INACTIVE");
			incrstats("origination","inactive");
		} else {
			incrstats("origination","unexpectedmsgs-2");
			vprint "\norigination WAITFOR200 warning:\n";
			vprint "Unexpected msg $phdrs->{msgtype}.\n";
			vprint "(callid=$callid).\n";
		}
	} elsif ($origstate =~ /^TALKING$/) {
		if ($timerflag) {
			# check if my timer
			if (!isMyTimer($callid, $ptimer)) {
				incrstats("origination","invalidtimers-4");
				if ($timerflag == 2) {
					incrstats("origination","notreadyfororig");
				}
				$ptimer = undef;
				return;
			}
			# call ends, send bye.
			$dialogs{$callid}{cseq} += 1;
			sendBye($callid, "contact");
			incrstats("origination","sendBye");
			incrstats("origination","timedout-2");
			#
			starttimer($callid, $dndata{$dn}{"waitingfor200duration"},
				"WAIT FOR 200 BYE");
			changeDnState($dn, "originationstate", "WAITFOR200BYE");
		} elsif ($phdrs->{msgtype} =~ /BYE/) {
			# onhook received
			send200OK($callid, $phdrs, "contact");
			incrstats("origination","send200OK");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "originationstate", "INACTIVE");
			incrstats("origination","inactive");
		} elsif ($phdrs->{msgtype} =~ /CANCEL/) {
			# last request was canceled. end call.
			send200OK($callid, $phdrs, "contact");
			incrstats("origination","send200OKCancel");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "originationstate", "INACTIVE");
			incrstats("origination","inactive");
		} else {
			incrstats("origination","unexpectedmsgs-3");
			vprint "\norigination TALKING warning:\n";
			vprint "Unexpected msg $phdrs->{msgtype}.\n";
			vprint "(callid=$callid).\n";
		}
	} elsif ($origstate =~ /^WAITFOR200BYE$/) {
		if ($timerflag) {
			# check if my timer
			if (!isMyTimer($callid, $ptimer)) {
				incrstats("origination","invalidtimers-5");
				if ($timerflag == 2) {
					incrstats("origination","notreadyfororig");
				}
				$ptimer = undef;
				return;
			}
			# call ends.
			$ptimer = undef;
			delete $dialogs{$callid};
			changeDnState($dn, "originationstate", "INACTIVE");
			incrstats("origination","inactive");
			incrstats("origination","timedout-3");
		} elsif ($phdrs->{msgtype} =~ /RETURNCODE/) {
			# call ends. the return code should be
			# 200OK, but really we are ending the call
			# whether it is or not.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "originationstate", "INACTIVE");
			incrstats("origination","inactive");
		} elsif ($phdrs->{msgtype} =~ /CANCEL/) {
			# last request was canceled. end call.
			send200OK($callid, $phdrs, "contact");
			incrstats("origination","send200OKCancel");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "originationstate", "INACTIVE");
			incrstats("origination","inactive");
		} elsif ($phdrs->{msgtype} =~ /BYE/) {
			# onhook received
			send200OK($callid, $phdrs, "contact");
			incrstats("origination","send200OK");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "originationstate", "INACTIVE");
			incrstats("origination","inactive");
		} else {
			incrstats("origination","unexpectedmsgs-4");
			vprint "\norigination WAITFOR200BYE warning:\n";
			vprint "Unexpected msg $phdrs->{msgtype}.\n";
			vprint "(callid=$callid).\n";
		}
	} elsif ($origstate =~ /^WAITFOR200CANCEL$/) {
		if ($timerflag) {
			# check if my timer
			if (!isMyTimer($callid, $ptimer)) {
				incrstats("origination","invalidtimers-6");
				if ($timerflag == 2) {
					incrstats("origination","notreadyfororig");
				}
				$ptimer = undef;
				return;
			}
			# call ends.
			$ptimer = undef;
			delete $dialogs{$callid};
			changeDnState($dn, "originationstate", "INACTIVE");
			incrstats("origination","inactive");
			incrstats("origination","timedout-4");
		} elsif ($phdrs->{msgtype} =~ /RETURNCODE/) {
			# call ends. the return code should be
			# 200OK, but really we are ending the call
			# whether it is or not.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "originationstate", "INACTIVE");
			incrstats("origination","inactive");
			incrstats("origination","waitfor200cancel-received200OK");
		} else {
			incrstats("origination","unexpectedmsgs-5");
			vprint "\norigination WAITFOR200CANCEL warning:\n";
			vprint "Unexpected msg $phdrs->{msgtype}.\n";
			vprint "(callid=$callid).\n";
		}
	} else {
		vprint "\norigination - unknown state $origstate error:\n";
		if ($timerflag) {
			incrstats("origination","invalidtimers-7");
			if ($timerflag == 2) {
				incrstats("origination","notreadyfororig");
			}
			vprint "Unexpected timer.\n";
			$ptimer = undef;
		} else {
			incrstats("origination","unexpectedmsgs-6");
		}
		vprint "(callid=$callid).\n";
	}
	return;
}
#
sub termination {
	my ($callid, $timerflag, $current_time, $recvpaddr, 
	    $pdatablocks, $phdrs, $ptimer) = @_;
	#
	if ($verboseflag) {
		vprint "\nEntry termination: Call-ID = <$callid>\n";
		vprint "Timer Flag for $callid = <$timerflag>\n";
	}
	#
	my $dn = $dialogs{$callid}{dn};
	my $termstate = $dndata{$dn}{terminationstate};
	dumpDnState($dn, "terminationstate");
	#
	# if (!$timerflag && $phdrs->{msgtype} =~ /CANCEL/) {
		# printit "MSG CANCEL, STATE ${termstate}\n";
	# }
	if ($termstate =~ /^INACTIVE$/) {
		if ($timerflag) {
			incrstats("termination","invalidtimers-1");
			vprint "\ntermination INACTIVE warning:\n";
			vprint "Unexpected timer.\n";
			vprint "(callid=$callid).\n";
			$ptimer = undef;
		} elsif ($phdrs->{msgtype} =~ /INVITE/) {
			incrstats("termination","started");
			sendInvite180Ringing($callid, $phdrs, "contact");
			incrstats("termination","sendInvite180Ringing");
			#
			if ($dndata{$dn}{"ringingduration"} > 0) {
				# wait for ringing
				removetimer($callid);
				starttimer($callid, 
					$dndata{$dn}{"ringingduration"}, 
					"RINGING");
				changeDnState($dn, "terminationstate", 
					"RINGING");
				$dialogs{$callid}{lastphdrs} = $phdrs;
			} else {
				# just send 200OK immediately
				sendInvite200OK($callid, $phdrs, "contact");
				incrstats("termination","sendInvite200OK");
				#
				removetimer($callid);
				starttimer($callid, 
					$dndata{$dn}{"waitingforackduration"}, 
					"WAIT FOR ACK");
				changeDnState($dn, "terminationstate", 
					"WAITFORACK");
			}
		} else {
			incrstats("termination","unexpectedmsgs-1");
			vprint "\ntermination INACTIVE warning:\n";
			vprint "Unexpected msg $phdrs->{msgtype}.\n";
			vprint "(callid=$callid).\n";
		}
	} elsif ($termstate =~ /^RINGING$/) {
		if ($timerflag) {
			# check if my timer
			if (!isMyTimer($callid, $ptimer)) {
				incrstats("termination","invalidtimers-6");
				$ptimer = undef;
				return;
			}
			$phdrs = $dialogs{$callid}{lastphdrs};
			sendInvite200OK($callid, $phdrs, "contact");
			incrstats("termination","sendInvite200OK");
			#
			starttimer($callid, $dndata{$dn}{"waitingforackduration"}, 
				"WAIT FOR ACK");
			changeDnState($dn, "terminationstate", "WAITFORACK");
		} elsif ($phdrs->{msgtype} =~ /INVITE/) {
			# busy, send 486
			send486Busy($callid, $phdrs, "contact");
			incrstats("termination","send486Busy");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
			incrstats("termination","inactive");
		} elsif ($phdrs->{msgtype} =~ /CANCEL/) {
			# last request was canceled. end call.
			send200OK($callid, $phdrs, "contact");
			incrstats("termination","send200OKCancel");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
			incrstats("termination","inactive");
		} elsif ($phdrs->{msgtype} =~ /BYE/) {
			# end call.
			send200OK($callid, $phdrs, "contact");
			incrstats("termination","send200OK");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
			incrstats("termination","inactive");
		} else {
			incrstats("termination","unexpectedmsgs-6");
			vprint "\ntermination WAITFORACK warning:\n";
			vprint "Unexpected msg $phdrs->{msgtype}.\n";
			vprint "(callid=$callid).\n";
		}
	} elsif ($termstate =~ /^WAITFORACK$/) {
		if ($timerflag) {
			# check if my timer
			if (!isMyTimer($callid, $ptimer)) {
				incrstats("termination","invalidtimers-2");
				$ptimer = undef;
				return;
			}
			# call ends.
			$ptimer = undef;
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
			incrstats("termination","inactive");
			incrstats("termination","timedout-1");
		} elsif ($phdrs->{msgtype} =~ /INVITE/) {
			# busy, send 486
			send486Busy($callid, $phdrs, "contact");
			incrstats("termination","send486Busy");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
			incrstats("termination","inactive");
		} elsif ($phdrs->{msgtype} =~ /ACK/) {
			removetimer($callid);
			starttimer($callid, $dndata{$dn}{"maxcallduration"},
				"TALKING MAX CALL LENGTH");
			changeDnState($dn, "terminationstate", "TALKING");
			incrstats("termination","stable");
		} elsif ($phdrs->{msgtype} =~ /CANCEL/) {
			# last request was canceled. end call.
			send200OK($callid, $phdrs, "contact");
			incrstats("termination","send200OKCancel");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
			incrstats("termination","inactive");
		} elsif ($phdrs->{msgtype} =~ /BYE/) {
			# end call.
			send200OK($callid, $phdrs, "contact");
			incrstats("termination","send200OK");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
			incrstats("termination","inactive");
		} else {
			incrstats("termination","unexpectedmsgs-2");
			vprint "\ntermination WAITFORACK warning:\n";
			vprint "Unexpected msg $phdrs->{msgtype}.\n";
			vprint "(callid=$callid).\n";
		}
	} elsif ($termstate =~ /^TALKING$/) {
		if ($timerflag) {
			# check if my timer
			if (!isMyTimer($callid, $ptimer)) {
				incrstats("termination","invalidtimers-3");
				$ptimer = undef;
				return;
			}
			# call ends, send bye.
			$dialogs{$callid}{cseq} += 1;
			sendBye($callid, "contact");
			incrstats("termination","sendBye");
			#
			starttimer($callid, $dndata{$dn}{"waitingfor200duration"},
				"WAIT FOR 200 BYE");
			changeDnState($dn, "terminationstate", "WAITFOR200BYE");
			incrstats("termination","timedout-2");
		} elsif ($phdrs->{msgtype} =~ /INVITE/) {
			# busy, send 486
			send486Busy($callid, $phdrs, "contact");
			incrstats("termination","send486Busy");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
			incrstats("termination","inactive");
		} elsif ($phdrs->{msgtype} =~ /BYE/) {
			# onhook received
			send200OK($callid, $phdrs, "contact");
			incrstats("termination","send200OK");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
			incrstats("termination","inactive");
		} elsif ($phdrs->{msgtype} =~ /CANCEL/) {
			# last request was canceled. end call.
			send200OK($callid, $phdrs, "contact");
			incrstats("termination","send200OKCancel");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
			incrstats("termination","inactive");
		} else {
			incrstats("termination","unexpectedmsgs-3");
			vprint "\ntermination TALKING warning:\n";
			vprint "Unexpected msg $phdrs->{msgtype}.\n";
			vprint "(callid=$callid).\n";
		}
	} elsif ($termstate =~ /WAITFOR200BYE/) {
		if ($timerflag) {
			# check if my timer
			if (!isMyTimer($callid, $ptimer)) {
				incrstats("termination","invalidtimers-4");
				$ptimer = undef;
				return;
			}
			# call ends.
			$ptimer = undef;
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
			incrstats("termination","inactive");
			incrstats("termination","timedout-3");
		} elsif ($phdrs->{msgtype} =~ /INVITE/) {
			# busy, send 486
			send486Busy($callid, $phdrs, "contact");
			incrstats("termination","send486Busy");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
			incrstats("termination","inactive");
		} elsif ($phdrs->{msgtype} =~ /RETURNCODE/) {
			# call ends. the return code should be
			# 200OK, but really we are ending the call
			# whether it is or not.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
			incrstats("termination","inactive");
		} elsif ($phdrs->{msgtype} =~ /CANCEL/) {
			# last request was canceled. end call.
			send200OK($callid, $phdrs, "contact");
			incrstats("termination","send200OKCancel");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
			incrstats("termination","inactive");
		} elsif ($phdrs->{msgtype} =~ /BYE/) {
			# end call.
			send200OK($callid, $phdrs, "contact");
			incrstats("termination","send200OK");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
			incrstats("termination","inactive");
		} else {
			incrstats("termination","unexpectedmsgs-4");
			vprint "\ntermination WAITFOR200BYE warning:\n";
			vprint "Unexpected msg $phdrs->{msgtype}.\n";
			vprint "(callid=$callid).\n";
		}
	} else {
		vprint "\ntermination - unknown state $termstate error:\n";
		if ($timerflag) {
			incrstats("termination","invalidtimers-5");
			vprint "Unexpected timer.\n";
			$ptimer = undef;
		} else {
			incrstats("termination","unexpectedmsgs-5");
		}
		vprint "(callid=$callid).\n";
	}
	return;
}
#
sub terminationrefer {
	my ($callid, $timerflag, $current_time, $recvpaddr, 
	    $pdatablocks, $phdrs, $ptimer) = @_;
	#
	if ($verboseflag) {
		vprint "\nEntry termination: Call-ID = <$callid>\n";
		vprint "Timer Flag for $callid = <$timerflag>\n";
	}
	#
	my $dn = $dialogs{$callid}{dn};
	my $termstate = $dndata{$dn}{terminationstate};
	dumpDnState($dn, "terminationstate");
	#
	if ($termstate =~ /^INACTIVE$/) {
		if ($timerflag) {
			vprint "\ntermination INACTIVE warning:\n";
			vprint "Unexpected timer.\n";
			vprint "(callid=$callid).\n";
			$ptimer = undef;
		} elsif ($phdrs->{msgtype} =~ /INVITE/) {
			sendInvite180Ringing($callid, $phdrs, "contact");
			sendInvite200OK($callid, $phdrs, "contact");
			#
			removetimer($callid);
			starttimer($callid, $dndata{$dn}{"waitingforackduration"}, 
				"WAIT FOR ACK");
			changeDnState($dn, "terminationstate", "WAITFORACK");
		} else {
			vprint "\ntermination INACTIVE warning:\n";
			vprint "Unexpected msg $phdrs->{msgtype}.\n";
			vprint "(callid=$callid).\n";
		}
	} elsif ($termstate =~ /^WAITFORACK$/) {
		if ($timerflag) {
			# check if my timer
			if (!isMyTimer($callid, $ptimer)) {
				$ptimer = undef;
				return;
			}
			# call ends.
			$ptimer = undef;
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
		} elsif ($phdrs->{msgtype} =~ /ACK/) {
			removetimer($callid);
			starttimer($callid, $dndata{$dn}{"prerefercallduration"},
				"TALKING PRE-REFER CALL LENGTH");
			changeDnState($dn, "terminationstate", "TALKINGBEFOREREFER");
		} elsif ($phdrs->{msgtype} =~ /BYE/) {
			# end call.
			send200OK($callid, $phdrs, "contact");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
		} elsif ($phdrs->{msgtype} =~ /CANCEL/) {
			# last request was canceled. end call.
			send200OK($callid, $phdrs, "contact");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
		} else {
			vprint "\ntermination WAITFORACK warning:\n";
			vprint "Unexpected msg $phdrs->{msgtype}.\n";
			vprint "(callid=$callid).\n";
		}
	} elsif ($termstate =~ /^TALKINGBEFOREREFER$/) {
		if ($timerflag) {
			# check if my timer
			if (!isMyTimer($callid, $ptimer)) {
				$ptimer = undef;
				return;
			}
			# call ends, send bye.
			$dialogs{$callid}{cseq} += 1;
			sendRefer($callid, "contact");
			#
			starttimer($callid, $dndata{$dn}{"waitingfor202duration"},
				"WAIT FOR 202 REFER");
			changeDnState($dn, "terminationstate", "WAITFOR202REFER");
		} elsif ($phdrs->{msgtype} =~ /BYE/) {
			# onhook received
			send200OK($callid, $phdrs, "contact");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
		} elsif ($phdrs->{msgtype} =~ /CANCEL/) {
			# last request was canceled. end call.
			send200OK($callid, $phdrs, "contact");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
		} else {
			vprint "\ntermination TALKINGBEFOREREFER warning:\n";
			vprint "Unexpected msg $phdrs->{msgtype}.\n";
			vprint "(callid=$callid).\n";
		}
	} elsif ($termstate =~ /^WAITFOR202REFER$/) {
		if ($timerflag) {
			# check if my timer
			if (!isMyTimer($callid, $ptimer)) {
				$ptimer = undef;
				return;
			}
			# cancel call.
			$ptimer = undef;
			$dialogs{$callid}{cseq} += 1;
			sendBye($callid, "mycontact");
			starttimer($callid, $dndata{$dn}{"waitingfor200duration"}, 
				"WAIT FOR 200 BYE");
			changeDnState($dn, "terminationstate", "WAITFOR200BYE");
		} elsif ($phdrs->{msgtype} =~ /RETURNCODE/) {
			if ($phdrs->{returncode} == 202) {
				# got OK response
				removetimer($callid);
				starttimer($callid, $dndata{$dn}{"maxcallduration"},
					"TALKING MAX CALL LENGTH");
				changeDnState($dn, "terminationstate", "TALKING");
			} else {
				# not what we wanted, end call.
				$dialogs{$callid}{cseq} += 1;
				sendBye($callid, "mycontact");
				removetimer($callid);
				starttimer($callid, 
					$dndata{$dn}{"waitingfor200duration"}, 
					"WAIT FOR 200 BYE");
				changeDnState($dn, "terminationstate", "WAITFOR200BYE");
			}
		} elsif ($phdrs->{msgtype} =~ /CANCEL/) {
			# last request was canceled. end call.
			send200OK($callid, $phdrs, "contact");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
		} elsif ($phdrs->{msgtype} =~ /BYE/) {
			# other side is gone.
			send200OK($callid, $phdrs, "contact");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
		} else {
			vprint "\norigination WAITFOR202REFER warning:\n";
			vprint "Unexpected msg $phdrs->{msgtype}.\n";
			vprint "(callid=$callid).\n";
		}
	} elsif ($termstate =~ /^TALKING$/) {
		if ($timerflag) {
			# check if my timer
			if (!isMyTimer($callid, $ptimer)) {
				$ptimer = undef;
				return;
			}
			# call ends, send bye.
			$dialogs{$callid}{cseq} += 1;
			sendBye($callid, "contact");
			#
			starttimer($callid, $dndata{$dn}{"waitingfor200duration"},
				"WAIT FOR 200 BYE");
			changeDnState($dn, "terminationstate", "WAITFOR200BYE");
		} elsif ($phdrs->{msgtype} =~ /NOTIFY/) {
			# respond and stay in same state. timer already is active.
			send200OK($callid, $phdrs, "contact");
		} elsif ($phdrs->{msgtype} =~ /BYE/) {
			# onhook received
			send200OK($callid, $phdrs, "contact");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
		} elsif ($phdrs->{msgtype} =~ /CANCEL/) {
			# last request was canceled. end call.
			send200OK($callid, $phdrs, "contact");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
		} else {
			vprint "\ntermination TALKING warning:\n";
			vprint "Unexpected msg $phdrs->{msgtype}.\n";
			vprint "(callid=$callid).\n";
		}
	} elsif ($termstate =~ /WAITFOR200BYE/) {
		if ($timerflag) {
			# check if my timer
			if (!isMyTimer($callid, $ptimer)) {
				$ptimer = undef;
				return;
			}
			# call ends.
			$ptimer = undef;
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
		} elsif ($phdrs->{msgtype} =~ /RETURNCODE/) {
			# call ends. the return code should be
			# 200OK, but really we are ending the call
			# whether it is or not.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
		} elsif ($phdrs->{msgtype} =~ /BYE/) {
			# end call.
			send200OK($callid, $phdrs, "contact");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
		} elsif ($phdrs->{msgtype} =~ /CANCEL/) {
			# last request was canceled. end call.
			send200OK($callid, $phdrs, "contact");
			# call ends.
			removetimer($callid);
			delete $dialogs{$callid};
			changeDnState($dn, "terminationstate", "INACTIVE");
		} else {
			vprint "\ntermination WAITFOR200BYE warning:\n";
			vprint "Unexpected msg $phdrs->{msgtype}.\n";
			vprint "(callid=$callid).\n";
		}
	} else {
		vprint "\ntermination - unknown state $termstate error:\n";
		if ($timerflag) {
			vprint "Unexpected timer.\n";
			$ptimer = undef;
		}
		vprint "(callid=$callid).\n";
	}
	return;
}
#
##########################################################################
#
# general msg handlers
#
sub stopcallload {
	$loaddata{state} = "idle";
}
#
sub startcallload {
	my ($cps, $holdtime, $maxcalls) = @_;
	# calculate max simultaneous calls.
	my $ok = 1;
	if ($cps < 1) {
		printit "startcallload: CPS < 1.\n";
		$ok = 0;
	}
	if ($holdtime < 1) {
		printit "startcallload: HOLDTIME < 1.\n";
		$ok = 0;
	}
	if ($maxcalls < 1) {
		printit "startcallload: MAXCALLS < 1.\n";
		$ok = 0;
	}
	if (!$ok) {
		printit "startcallload: call load not started.\n";
		return;
	}
	my $simcalls = $cps*$holdtime;
	if ($simcalls > $loaddata{origdnsz}) {
		printit "Requested number of simultaneous calls > number of ORIG DNs.\n";
		return;
	}
	# check if a call load is already running
	if ($loaddata{state} ne "idle") {
		printit "startcallload: call load already running.\n";
		return;
	}
	#
	$loaddata{callspersec} = $cps;
	$loaddata{holdtime} = $holdtime;
	$loaddata{maxcalls} = $maxcalls;
	$loaddata{callsstarted} = 0;
	$loaddata{currentorigdn} = 0;
	$loaddata{state} = "running";
	$loaddata{tag} = int(rand(1000000000));
	#
	my $newcalls = 0;
	#
	for (my $o=0; $o<$loaddata{origdnsz}; ${o}++) {
		my $i = ($loaddata{currentorigdn}+$o)%$loaddata{origdnsz};
		my $odn = $loaddata{origdns}[$i];
		my $tdn = $loaddata{calls}{$odn};
		#
		if ($verboseflag) {
			vprint "startcallload: ORID DN - TRYING $odn.\n";
			vprint "startcallload: TERM DN - TRYING $tdn.\n";
		}
		#
		if ($dndata{$odn}{callloadstate} ne "INACTIVE") {
			# skip this orig dn.
			if ($verboseflag) {
				vprint "\tstartcallload: ORID DN - SKIPPING $odn.\n";
				vprint "\tstartcallload: TERM DN - SKIPPING $tdn.\n";
			}
			next;
		}
		if ($verboseflag) {
			vprint "\tstartcallload: ORID DN - USING $odn (state=$dndata{$odn}{callloadstate}).\n";
			vprint "\tstartcallload: TERM DN - USING $tdn.\n";
		}
		# set max length of call.
		$dndata{$odn}{"maxcallduration"} = $holdtime;
		# we found a dn to start a call.
		queueOrig($odn, $tdn, 1);
		$dndata{$odn}{callloadstate} = "SCHEDULED";
		incrstats("origination","queueOrigCalled");
		# 
		${newcalls}++;
		$loaddata{callsstarted}++;
		#
		if ((${newcalls} >= $cps) || 
		    ($loaddata{callsstarted} >= $loaddata{maxcalls})) {
			# done with starting calls for now.
			last;
		}
	}
	#
	if ($verboseflag) {
		vprint "startcallload: $newcalls new calls queue.\n";
	}
	# queue up next event to startup a call load.
	starttimer("CALL-LOAD", 2, "CALL-LOAD");
}
#
sub queueOrig {
	my ($odn, $tdn, $delta) = @_;
	#
	# verify both DNs exist
	#
	my $ok = 1;
	if (!exists($dndata{$odn})) {
		vprint "Unknown Orig DN $odn.\n";
		incrstats("origination","queueOrigUnknownOrigDN");
		$ok = 0;
	}
	if (!exists($dndata{$tdn})) {
		vprint "Unknown Term DN $tdn.\n";
		incrstats("origination","queueOrigUnknownTermDN");
		$ok = 0;
	}
	if (!$ok) {
		vprint "returning without starting call.\n";
		incrstats("origination","queueOrigCallNotStarted");
		return;
	}
	#
	# create call id
	#
	my $callid = int(rand(1000000000));
	$callid = "${callid}${odn}\@$parameters{mysipip}";
	#
	# create a dialog
	#
	$dialogs{$callid}{dn} = $odn;
	$dialogs{$callid}{origdn} = $odn;
	$dialogs{$callid}{termdn} = $tdn;
	$dialogs{$callid}{handler} = $dndata{$odn}{origination};
	$dialogs{$callid}{contact} = dn2contact($tdn);
	$dialogs{$callid}{mycontact} = dn2contact($odn);
	$dialogs{$callid}{cseq} = int(rand(1000000000));
	$dialogs{$callid}{"timertag"} = 0;
	$dialogs{$callid}{"mytag"} = int(rand(1000000000));
	$dialogs{$callid}{"mytag"} .= "mytag";
	$dialogs{$callid}{maxforwards} = $parameters{"maxforwards"};
	#
	my $odnip = $dndata{$odn}{sipip};
	my $odnport = $dndata{$odn}{sipport};
	$dialogs{$callid}{"from"} = "sip:${odn}\@${odnip}:${odnport}";
	#
	my $tdnip = $dndata{$tdn}{sipip};
	my $tdnport = $dndata{$tdn}{sipport};
	$dialogs{$callid}{"requesturi"} = "sip:${tdn}\@${tdnip}:${tdnport}";
	$dialogs{$callid}{"to"} = "sip:${tdn}\@${tdnip}:${tdnport}";
	#
	# queue up a timer request
	#
	incrstats("origination","queueOrigStartTimerCalled");
	starttimer($callid, $delta, "ORIGINATION");
	return;
}
#
sub queueReg {
	my ($rdn, $delta) = @_;
	#
}
#
$previousorigdn = undef;
$previoustermdn = undef;
#
sub handleInput {
	my ($pdone) = @_;
	#
	my $line = <STDIN>;
	if (!defined($line)) {
		return;
	}
	chomp($line);
	#
	if ($line =~ /^q[\s]*$/i) {
		printit "\nQuitting ...\n";
		$$pdone = 1;
	} elsif ($line =~ /^w/) {
		printit "\n$line\n";
	} elsif ($line =~ /^cls[\s]*$/) {
		printit "\nClear Statistics: \n";
		foreach my $key (sort keys %statistics) {
			printit "${key}:\n";
			foreach my $key2 (sort keys %{$statistics{$key}}) {
				$statistics{$key}{$key2} = 0;
			}
		}
	} elsif ($line =~ /^s[\s]*$/) {
		printit "\nStatistics: \n";
		foreach my $key (sort keys %statistics) {
			printit "${key}:\n";
			foreach my $key2 (sort keys %{$statistics{$key}}) {
				printit "\t${key2} = $statistics{$key}{$key2}\n";
			}
		}
	} elsif ($line =~ /^D[\s]*$/) {
		$debugflag = !$debugflag;
		if ($debugflag) {
			printit "Debugging is ON\n";
		} else {
			printit "Debugging is OFF\n";
		}
	} elsif ($line =~ /^V[\s]*$/) {
		$verboseflag = !$verboseflag;
		if ($verboseflag) {
			printit "Verbose is ON\n";
		} else {
			printit "Verbose is OFF\n";
		}
	} elsif ($line =~ /^cl[\s]*$/) {
		printit "\nListing Call Originator-Terminator Pairs:\n";
		foreach my $key (sort keys %{$loaddata{calls}}) {
			printit "\tORIG $key ==>> TERM $loaddata{calls}{$key}\n";
		}
	} elsif ($line =~ /^cs[\s]*$/) {
		printit "\nListing Call Load Data:\n";
		foreach my $key (sort keys %{loaddata}) {
			printit "\t$key ==>> $loaddata{$key}\n";
		}
	} elsif ($line =~ /^l[\s]+([^\s]+)/) {
		my $listdn = $1;
		if (!exists($dndata{$listdn})) {
			printit "DN $listdn not found.\n";
			return;
		}
		printit "\nListing DN $listdn data:\n";
		foreach my $key (sort keys %{$dndata{$listdn}}) {
			if (defined($dndata{$listdn}{$key})) {
				printit "\t$key => $dndata{$listdn}{$key}\n";
			} else {
				printit "\t\$dndata{$listdn}{$key} undefined\n";
			}
		}
	} elsif ($line =~ /^l[\s]*$/) {
		printit "\nListing DNs:\n";
		foreach my $dn (sort keys %dndata) {
			printit "DN $dn\n";
			printit "\tregistrationstate => $dndata{$dn}{registrationstate}\n";
			printit "\toriginationstate => $dndata{$dn}{originationstate}\n";
			printit "\tterminationstate => $dndata{$dn}{terminationstate}\n";
		}
	} elsif ($line =~ /^d[\s]*$/) {
		printit "\nListing Dialogs:\n";
		foreach my $callid (sort keys %dialogs) {
			printit "Call-ID $callid\n";
		}
	} elsif ($line =~ /^r[\s]+([^\s]+)/) {
		my $regdn = $1;
		printit "\nRegistering DN $regdn.\n";
		queueReg($regdn, 0);
	} elsif ($line =~ /^h[\s]*$/) {
		stopcallload();
	} elsif ($line =~ /^dpqaud[\s]*$/) {
		auditPQ($pq);
	} elsif ($line =~ /^dpq[\s]*$/) {
		dumpPQ($pq);
	} elsif ($line =~ /^dpqcnt[\s]*$/) {
		printit "\nPQ count = ".$pq->count()."\n";
	} elsif ($line =~ /^o[\s]*$/) {
		if (defined($previousorigdn) && defined($previoustermdn)) {
			printit "\nDN $previousorigdn calling DN $previoustermdn.\n";
			queueOrig($previousorigdn, $previoustermdn, 0);
			incrstats("origination","queueOrigCalled");
		} else {
			printit "Previous orig/term DNs not defined.\n";
		}
	} elsif ($line =~ /^o[\s]+([^\s]+)[\s]+([^\s]+)/) {
		my $origdn = $previousorigdn = $1;
		my $termdn = $previoustermdn = $2;
		printit "\nDN $origdn calling DN $termdn.\n";
		queueOrig($origdn, $termdn, 0);
		incrstats("origination","queueOrigCalled");
	} elsif ($line =~ /^c[\s]+([\d]+)[\s]+([\d]+)[\s]+([\d]+)/) {
		my $cps = $1;
		my $holdtime = $2;
		my $maxcalls = $3;
		#
		printit "\nStart call load:\n";
		printit "\tCalls Per Sec = $cps\n";
		printit "\tHold Time (secs) = $holdtime\n";
		printit "\tMaximum Number of Calls  = $maxcalls\n";
		#
		startcallload($cps, $holdtime, $maxcalls);
	} elsif ($line =~ /^\?/) {
		printit "\nhelp text:\n";
		printit "\t'?' - help text\n";
		printit "\t'c cps holdtime maxcalls' - start a call load.\n";
		printit "\t'cl' - list call originator-terminator pairs.\n";
		printit "\t'cls' - clear statistics.\n";
		printit "\t'cs' - list call load data.\n";
		printit "\t'd' - list active dialogs.\n";
		printit "\t'D' - toggle debugging.\n";
		printit "\t'dpq' - dump priority queue contents.\n";
		printit "\t'h' - stop call load gracefully.\n";
		printit "\t'l' - list DNs.\n";
		printit "\t'o dn dialdn' - dn calls dialdn.\n";
		printit "\t'q' - quit\n";
		printit "\t'r dn' - register dn.\n";
		printit "\t's' - list statistics.\n";
		printit "\t'V' - toggle verbose.\n";
		printit "\t'w text' - write 'text' to stdout/logfile.\n";
	} else {
		printit "\nunknown cmd\n";
	}
	return;
}
#
sub handleRTP {
	my ($current_time, $recvpaddr, $rawmsg) = @_;
	#
	my $msglen = length($rawmsg);
	vprint "\nRTP msg received: length=$msglen\n";
	#
	return;
}
#
sub handleRTCP {
	my ($current_time, $recvpaddr, $rawmsg) = @_;
	#
	my $msglen = length($rawmsg);
	vprint "\nRTCP msg received: length=$msglen\n";
	#
	return;
}
#
sub handleCallLoad {
	my ($ptimer) = @_;
	#
	if (!isMyTimer("CALL-LOAD", $ptimer)) {
		$ptimer = undef;
		return;
	}
	if ($loaddata{callsstarted} >= $loaddata{maxcalls}) {
		# done with starting calls for now.
		$loaddata{state} = "idle";
		printit "\thandleCallLoad: Call load done.\n";
		return;
	}
	#
	my $newcalls = 0;
	#
	for (my $o=0; $o<$loaddata{origdnsz}; ${o}++) {
		my $i = ($loaddata{currentorigdn}+$o)%$loaddata{origdnsz};
		my $odn = $loaddata{origdns}[$i];
		my $tdn = $loaddata{calls}{$odn};
		#
		if ($verboseflag) {
			vprint "handleCallLoad: ORID DN - TRYING $odn.\n";
			vprint "handleCallLoad: TERM DN - TRYING $tdn.\n";
		}
		#
		if ($dndata{$odn}{callloadstate} ne "INACTIVE") {
			# skip this orig dn.
			if ($verboseflag) {
				vprint "\thandleCallLoad: ORID DN - SKIPPING $odn.\n";
				vprint "\thandleCallLoad: TERM DN - SKIPPING $tdn.\n";
			}

			next;
		}
		if ($verboseflag) {
			vprint "\thandlecallload: ORID DN - USING $odn (state=$dndata{$odn}{callloadstate}).\n";
			vprint "\thandlecallload: TERM DN - USING $tdn.\n";
		}
		# set max length of call.
		$dndata{$odn}{"maxcallduration"} = $loaddata{holdtime};
		# we found a dn to start a call.
		queueOrig($odn, $tdn, 1);
		$dndata{$odn}{callloadstate} = "SCHEDULED";
		incrstats("origination","queueOrigCalled");
		# 
		${newcalls}++;
		$loaddata{callsstarted}++;
		#
		if ((${newcalls} >= $loaddata{callspersec}) ||
		    ($loaddata{callsstarted} >= $loaddata{maxcalls})) {
			# done with starting calls for now.
			last;
		}
	}
	#
	if ($verboseflag) {
		vprint "handleCallLoad: $newcalls new calls queue.\n";
	}
	# queue up next event to startup a call load.
	if ($loaddata{callsstarted} >= $loaddata{maxcalls}) {
		# done with starting calls for now.
		$loaddata{state} = "idle";
		printit "\thandleCallLoad: Call load done.\n";
	} else {
		# schedule next call load event
		starttimer("CALL-LOAD", 1, "CALL-LOAD");
	}
	return;
}
#
sub handleTimer {
	my ($current_time, $ptimer) = @_;
	#
	if ($verboseflag) {
		vprint "\nTimer expired: \n";
	}
	# check if call id data exits
	if (!defined($ptimer->{callid})) {
		vprint "\nNo Call-ID defined in timer.\n";
		$ptimer = undef;
		return;
	}
	my $callid = $ptimer->{callid};
	if (!defined($dialogs{$callid})) {
		vprint "\nNo timer dialog data for $callid defined.\n";
		vprint "Call-ID: ".$ptimer->{callid}."\n";
		vprint "Tag    : ".$ptimer->{expire}."\n";
		vprint "Label  : ".$ptimer->{label}."\n";
		$ptimer = undef;
		return;
	}
	# check for call load event.
	if ($ptimer->{callid} eq "CALL-LOAD") {
		# start a call load.
		handleCallLoad($ptimer);
		return;
	}
	#
	my $timertype = 0;
	if ($ptimer->{label} =~ /^ORIGINATION$/) {
		# call origination event
		$timertype = 2;
	} elsif ($ptimer->{label} =~ /^REGISTRATION$/) {
		# registration event
		$timertype = 3;
	} else {
		# regular timer
		$timertype = 1;
	}
	#
	my $handler = $dialogs{$callid}{handler};
	&{${handler}}($callid, $timertype, $current_time, 
		undef, undef, undef, $ptimer);
	return;
}
#
sub handleSIP {
	my ($current_time, $recvpaddr, $rawmsg) = @_;
	#
	my $msglen = length($rawmsg);
	if ($msglen < $parameters{minmsgsize}) {
		# garbage msg, skip it ...
		return;
	}
	if ($verboseflag) {
		vprint "\nSIP msg received: length=$msglen\n";
		dumpIncomingMsg($recvpaddr, $rawmsg);
	}
	#
	my %hdrs = ();
	my @datablocks = ();
	my $rawhdr = undef;
	my $rawdata = undef;
	#
	parseSipMsg($rawmsg, \$rawhdr, \$rawdata, \%hdrs, \@datablocks);
	if ($verboseflag) {
		dumphdrs(\%hdrs);
	}
	#
	my $callid = undef;
	if (defined($hdrs{"Call-ID"}) && 
	    defined($dialogs{$hdrs{"Call-ID"}})) {
		$callid = $hdrs{"Call-ID"};
	} else {
		if ($verboseflag) {
			vprint "\nNo dialog data found.\n";
		}
		incrstats("general", "handleSip-sendGratuitous200OK");
		sendGratuitous200OK(\%hdrs);
		return;
	}
	if (!defined($dialogs{$callid}{handler})) {
		vprint "\nNo handler for $callid defined.\n";
		incrstats("general", "handleSip-no-handler-for-call-id");
		return;
	}
	my $handler = $dialogs{$callid}{handler};
	&{${handler}}($callid, 0, $current_time, $recvpaddr, 
			\@datablocks, \%hdrs, undef);
	return;
}
#
#############################################################################
#
printit "\nSIP Simulator:\n";
#
# get cmd line options
#
my %opts;
getopts('?xVl:', \%opts);
foreach my $opt (%opts) {
	if ($opt eq "l") {
		$parameters{logfile} = $opts{$opt};
		printit "\n==>> logfile = $parameters{logfile}\n";
		open(LOGFILE, ">".$parameters{logfile}) or 
			die "can't open $parameters{logfile}: $!";
		LOGFILE->autoflush(1);
		$logflag = 1;
	} elsif ($opt eq "x") {
		$debugflag = 1;
		printit "\n==>> debugflag = $debugflag\n";
	} elsif ($opt eq "V") {
		$verboseflag = 1;
		printit "\n==>> verboseflag = $verboseflag\n";
	} elsif ($opt eq "?") {
		usage();
		exit 0;
	}
}
#
# read in config file
#
my ($configfile) = @ARGV;
if (!defined($configfile)) {
	$configfile = "sipsimcfg";
}
readconfigfile($configfile);
#
dumpparams();
dumpdndata();
#
# set up socket connections
#
my $proto = getprotobyname('udp');
defined($proto) or die "getprotobyname: $!";
#
socket(SIP, PF_INET, SOCK_DGRAM, $proto) or die "socket: $!";
my $ipaddr = gethostbyname($parameters{mysipip});
defined($ipaddr) or die "gethostbyname: $!";
my $paddr = sockaddr_in($parameters{mysipport}, $ipaddr);
defined($paddr) or die "getprotobyname: $!";
bind(SIP, $paddr) or die "bind: $!";
#
socket(RTP, PF_INET, SOCK_DGRAM, $proto) or die "socket: $!";
my $rtp_ipaddr = gethostbyname($parameters{myrtpip});
defined($ipaddr) or die "gethostbyname: $!";
my $rtp_paddr = sockaddr_in($parameters{myrtpport}, $rtp_ipaddr);
defined($rtp_paddr) or die "getprotobyname: $!";
bind(RTP, $rtp_paddr) or die "bind: $!";
#
socket(RTCP, PF_INET, SOCK_DGRAM, $proto) or die "socket: $!";
my $rtcp_paddr = sockaddr_in($parameters{myrtcpport}, $rtp_ipaddr);
defined($rtcp_paddr) or die "getprotobyname: $!";
bind(RTCP, $rtcp_paddr) or die "bind: $!";
#
my $rin = '';
my $rout = '';
#
vec($rin, fileno(STDIN), 1) = 1;
vec($rin, fileno(SIP), 1) = 1;
vec($rin, fileno(RTP), 1) = 1;
vec($rin, fileno(RTCP), 1) = 1;
#
# we don't want to I/O block. if no input, just return.
#
fcntl(STDIN, F_SETFL, O_NONBLOCK);
fcntl(SIP, F_SETFL, O_NONBLOCK);
fcntl(RTP, F_SETFL, O_NONBLOCK);
fcntl(RTCP, F_SETFL, O_NONBLOCK);
#
my $done = 0;
my $start_time = time();
my $current_time = $start_time;
my $elapsed_time= 0;
my $previous_time= 0;
my $total_elapsed_time= 0;
#
# priority queue for timer events
#
$pq = "mypqueue"->new();
defined($pq) or die "unable to create priority queue.";
#
# event loop for simulation. 
#
my $mydelta;
my $key;
my $pdata;
my $nf;
my $timeleft;
#
while ( ! $done) {
	$previous_time = $current_time;
	#
	# determine how long to sleep.
	#
	if ($pq->isEmpty()) {
		# no timers, just use default value.
		$mydelta = $parameters{delta};
		# dprint "default delta = $mydelta.\n";
	} elsif ($pq->front(\$pdata) == 1) {
		# sleep until next scheduled event.
		$mydelta = $pdata->{expire} - $current_time;
		$mydelta = 0 if ($mydelta < 0);
		# dprint "delta = $mydelta.\n";
	} else {
		printit "ERROR: event queue corruption, unable to calculate delta !!!\n";
		exit 2;
	}
	#
	# wait for input or timer to expire.
	#
	($nf, $timeleft) = select($rout=$rin, undef, undef, $mydelta);
	#
	# update internal clocks
	#
	$current_time = time();
	$elapsed_time = $current_time-$previous_time;
	$total_elapsed_time= $current_time-$start_time;
	# dprint "(currtime, etime, totaletime)=($current_time,$elapsed_time,$total_elapsed_time)\n";
	#
	# handle any expired timers
	#
	if ($timeleft <= 0) {
		while ($pq->dequeue(\$pdata) != 0) {
			if ($pdata->{expire} > $current_time) {
				$pq->enqueue($pdata);
				last;
			} 
			handleTimer($current_time, $pdata);
		}
	}
	#
	# my $pqcnt = $pq->count();
	# dprint "\nPQ count = $pqcnt\n";
	#
	# handle any input from user.
	#
	if (vec($rout, fileno(STDIN), 1)) {
		handleInput(\$done);
	}
	#
	# handle any msgs from sockets: RTP, RTCP, SIP.
	#
	if (vec($rout, fileno(SIP), 1)) {
		while (defined($recvpaddr = recv(SIP, my $msg, 8*1024, 0))) {
			handleSIP($current_time, $recvpaddr, $msg);
		}
	}
	if (vec($rout, fileno(RTCP), 1)) {
		while (defined($recvpaddr = recv(RTCP, my $msg, 8*1024, 0))) {
			handleRTCP($current_time, $recvpaddr, $msg);
		}
	}
	if (vec($rout, fileno(RTP), 1)) {
		while (defined($recvpaddr = recv(RTP, my $msg, 8*1024, 0))) {
			handleRTP($current_time, $recvpaddr, $msg);
		}
	}
}
#
close(SIP);
close(RTP);
close(RTCP);
close(LOGFILE) if (exists($parameters{logfile}));
#
exit 0;

