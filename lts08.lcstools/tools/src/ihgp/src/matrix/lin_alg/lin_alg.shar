#! /bin/sh
#
# This is a shell archive. Save this into a file, edit it
# and delete all lines above this comment.  Then give this
# file to sh by executing the command 'sh file'. The files
# will be extracted into the current directory owned by
# you with default permissions.

echo 'x - README'
sed 's/^X//' << '________This_Is_The_END________' > README
X			Numerical Math Class Library
X
X***** For version history, read on
X
X***** Highlights and idioms
X
X1. Never return complex objects (matrices or vectors)
XDanger: For example, when the following snippet 
X	Matrix foo(const int n)
X	{ Matrix foom(n,n); fill_in(foom); return foom; }
X	Matrix m = foo(5);
Xruns, it constructs matrix foo:foom, copies it onto stack as a return
Xvalue and destroys foo:foom. Return value (a matrix) from foo() is
Xthen copied over to m (via a copy constructor), and the return value
Xis destroyed. So, the matrix constructor is called 3 times and the
Xdestructor 2 times. For big matrices, the cost of multiple
Xconstructing/copying/destroying of objects may be very large. *Some*
Xoptimized compilers can cut down on 1 copying/destroying, but still it
Xleaves at least two calls to the constructor. Note, LazyMatrices (see
Xbelow) can construct Matrix m "inplace", with only a _single_ call to
Xthe constructor.
X
X
X2. Use "two-address instructions"
X	      "void Matrix::operator += (const Matrix& B);"
Xas much as possible
XThat is, to add two matrices, it's much more efficient to write
X	A += B;
Xthan
X	Matrix C = A + B;
X(if both operand should be preserved,
X	Matrix C = A; C += B;
Xis still better).
X
X3. Use glorified constructors when returning of an object seems
Xinevitable:
X		"Matrix A(Matrix::Transposed,B);"
X		"Matrix C(A,Matrix::TransposeMult,B);"
X
Xlike in the following snippet (from vmatrix1.cc) that verifies that
Xfor an orthogonal matrix T, T'T = TT' = E.
X
X    Matrix haar = haar_matrix(5);
X    Matrix unit(Matrix::Unit,haar);
X    Matrix haar_t(Matrix::Transposed,haar);
X    Matrix hth(haar,Matrix::TransposeMult,haar);
X    Matrix hht(haar,Matrix::Mult,haar_t);
X    Matrix hht1 = haar; hht1 *= haar_t;
X    verify_matrix_identity(unit,hth);
X    verify_matrix_identity(unit,hht);
X    verify_matrix_identity(unit,hht1);
X
X4. Accessing row/col/diagonal of a matrix without much fuss
X(and without moving a lot of stuff around)
X
X	  Matrix m(n,n); Vector v(n); MatrixDiag(m) += 4;
X	  v = MatrixRow(m,1);
X	  MatrixColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;
XNote, constructing of, say, MatrixDiag does *not* involve any copying
Xof any elements of the source matrix.
X
X5. It's possible (and encouraged) to use "nested" functions
XFor example, creating of a Hilbert matrix can be done as follows:
X
X   void foo(const Matrix& m)
X   {
X    Matrix m1(Matrix::Zero,m);
X    struct MakeHilbert : public ElementAction
X    {
X      void operation(REAL& element) { element = 1./(i+j-1); }
X    };
X    m1.apply(MakeHilbert());
X   }
X
Xof course, using a special method Matrix::hilbert_matrix() is still
Xmore optimal, but not by the whole lot. And that's right, class
XMakeHilbert is declared *within* a function and local to that
Xfunction. It means one can define another MakeHilbert class (within
Xanother function or outside of any function, that is, in the global
Xscope), and it still will be OK.
X
XAnother example is applying of a simple function to each matrix element
X
X void foo(Matrix& m, Matrix& m1)
X {
X  class ApplyFunction : public ElementPrimAction
X  {
X    double (*func)(const double x);
X    void operation(REAL& element) { element = func(element); }
X    public: ApplyFunction(double (*_func)(const double x)) : func(_func) {}
X  };
X  m.apply(ApplyFunction(sin));
X  m1.apply(ApplyFunction(cos));
X }
X
XValidation code vmatrix.cc and vvector.cc contains a few more examples
Xof that kind (especially vmatrix.cc:test_special_creation())
X
X6. Lazy matrices: instead of returning an object return a "recipe" how
Xto make it. The full matrix would be rolled out only when and where
Xit's needed:
X    Matrix haar = haar_matrix(5);
Xhaar_matrix() is a *class*, not a simple function. However similar
Xthis looks to a returning of an object (see note #1 above), it's
Xdramatically different. haar_matrix() constructs a LazyMatrix, an
Xobject of just a few bytes long. A special "Matrix(const LazyMatrix&
Xrecipe)" constructor follows the recipe and makes the matrix haar()
Xright in place. No matrix element is moved whatsoever!
X
XAnother example of matrix promises is
X  REAL array[] = {0,-4,0,  1,0,0,  0,0,9 };
X  test_svd_expansion(MakeMatrix(3,3,array,sizeof(array)/sizeof(array[0])));
X
XHere, MakeMatrix is a LazyMatrix that promises to deliver a matrix
Xfilled in from a specified array. Function test_svd_expansion(const Matrix&)
Xforces the promise: the compiler makes a temporary matrix, fills
Xit in using LazyMatrix's recipe, passes it out to test_svd_expansion()
Xfunction, Once the function returns, the temporary matrix is disposed of.
XAll this goes behind the scenes. See vsvd.cc for more details (this is
Xwhere the fragment was snipped from).
X
XOne more example is using Matrix/vector promises along with the
XElement actions:
X
X    class square_add : public LazyMatrix, public ElementAction
X    {
X      const Vector &v1; Vector &v2;
X      void operation(REAL& element)
X      		{ assert(j==1); element = v1(i)*v1(i) + v2(i)*v2(i); }
X     void fill_in(Matrix& m) const { m.apply(*this); }
X     public: square_add(const Vector& _v1, Vector& _v2) :
X   	LazyMatrix(_v1.q_row_lwb(),_v1.q_row_upb(),1,1),
X   	v1(_v1), v2(_v2) {}
X    };
X    Vector vres = square_add(v2,v3);
X    Vector vres1 = v2; assert( !(vres1 == vres) );
X    verify_element_value(vres,1);
X    vres1 = square_add(v2,v3);
XHere square_add promises to deliver a vector with elements being sums
Xof squares of elements of two other vectors. The promise is forced either
Xby a Vector constructor, or by an assignment to another vector (in the
Xlatter case, a check is made that the dimensions of the promise are
Xcompatible with those of the target). In either case, computation of
Xnew vector elements is done "inplace", no temporary storage is ever
Xallocated/used. Iteration is also done "behind the scenes", relieving the
Xuser of worries about index range checking, etc.
X
X7. SVD decomposition and its applications
XClass SVD performs a  Singular Value Decomposition of a rectangular matrix
XA = U * Sig * V'. Here, matrices U and V are orthogonal; matrix Sig is a
Xdiagonal matrix: its diagonal elements, which are all non-negative, are
Xsingular values (numbers) of the original matrix A. In another interpretation,
Xthe singular values are eigenvalues of matrix A'A.
X
XApplication of SVD: _regularized_ solution of a set of simultaneous
Xlinear equations Ax=B.  Matrix A does _not_ have to be a square matrix.
XIf A is a MxN rectangular matrix with M>N, the set Ax=b is obviously
Xoverspecified. The solution x produced by SVD_inv_mult would be then 
Xthe least-norm solution, that is, a least-squares solution.
XNote, B can be either a vector (Mx1-matrix), or a "thick" matrix. If B is
Xchosen to be a unit matrix, then x is A's inverse, or a pseudo-inverse if
XA is non-square and/or singular.
XAn example of using SVD:
X	SVD svd(A);
X	cout << "condition number of matrix A " << svd.q_cond_number();
X	Vector x = SVD_inv_mult(svd,b);		// Solution of Ax=b
XNote that SVD_inv_mult is a LazyMatrix. That is, the actual computation
Xoccurs not when the object SVD_inv_mult is constructed, but when it's
Xrequired (in an assignment).
X
X***** Grand plans
X	computing a random orthogonal matrix
X	use M_PI instead of PI (in the fft package)
X	saving/loading of a matrix
X	finding matrix Extrema (and extrema of abs(matrix))
X	compute X'AX for a square matrix
X	compute x'Ax (a square form)
X	asymmetry index
X	add ArithmeticProgression class ("virtual" constant vector)
X	In fft, overload * and / for the direct/inverse FFT: FFT f(n);
X		Vk = f*V; V = Vk/f;
X	make Matrix(ElementAction& action, const Matrix& prototype);
X	Make a special class for SymmetricMatrix
X	Make Matrix, symmetric matrix, etc. inherit from the class
X	matrixstorage, which holds refs to the data storage (starting
X	ptr, the end pointer, the number of elements) and can perform
X	element-by-element operations like assignment, assignment of a
X	scalar, etc.
X	When gcc starts supporting member function templates, make
X	iterator classes for iterating over a vector, two vectors, Matrix
X	slices, etc.
X	Use <const_cast> when gcc starts supporting it
X	Make procedures to perform row/col rotations, and use it
X	in SVD
X	Code to verify a matrix (pseudo)inverse, that is,
X	test Moore-Penrose  conditions XAX = X, AXA = A; AX and XA are
X	symmetric (that is, AX = (AX)', etc.) where X is a (pseudo)inverse
X	of A. Another SVD application: compute a covariance matrix for a
X	given design matrix X, i.e. find the inverse of the X'X for a
X	rectangular matrix X.
X 	Add ispline(): building a spline and integrating it
X	Add slehol: solve a set of SLE with a symmetric matrix
X	
X***** Revision history
X
XVersion 3.2
X	hjmin(), Hooks-Jeevse optimization, embellished and tested
X	ali.cc beautified, using nested functions, etc. (nice style)
X	Added SVD, singular value decomposition, and a some code
X	to use it (Solving Ax=b, where A doesn't have to be rectangular,
X	and b doesn't have to be a vector)
X	Minor embellishments
X	using bool datatype wherever appropriate
X	short replaced by 'int' as a datatype for indices, etc.: all
X	modern CPUs handle int more efficiently than short
X	(and memory isn't that of a problem any more)
X	Forcing promise (LazyMatrix) on assignment
X	Testing Matrix(Matrix::Inverted,m) glorified constructor
X	added retrieving an element from row/col/diag
X	added Matrix C.mult(A,B);	// Product A*B
X	*= operation on Matrix slices
X	Making a vector from a LazyMatrix
X	made sure that if memory is allocated via new, it's disposed
X	of via delete; if it was allocated via malloc/calloc, it's
X	disposed of via free(). It's important for CodeWarrior, where
X	new and malloc() are completely different beasts.
X	
X
XVersion 3.1
X	Deleted dummy destructors (they're better left inferred: it results
X	in more optimal code, especially in a class with virtual functions)
X	Minor tweaking and embellishments to please gcc 2.6.3
X	#included <float.h> and <minmax.h> where missing
X
XVersion 3.0 (beta): only Linear Algebra package was changed
X	got rid of a g++ extension when returning objects (in a_columns, etc)
X	removed "inline MatrixColumn Matrix::a_column(const int coln) const"
X	  and likes: less problems with non-g++ compilers, better portability
X	Matrix(operation::Transpose) constructors and likes, 
X	  (plus like-another constructor) Zero:, Unit, constructors
X	invert() matrix
X	true copy constructor (*this=another; at the very end)
X	fill in the matrix (with env) by doing ElementAction
X
X	cleaned Makefile (pruned dead wood, don't growl creating libla
X	  for the first time), a lots of comments as to how to make things
X	used M_PI instead of PI
X	#ifndef around GNU #pragma's
X	REAL is introduced via 'typedef' rather than via '#define': more
X	  portable and flexible
X	added verify_element_value(), verify_matrix_identity() to the main
X	  package (used to be local functions). They are useful in
X	  writing the validation code
X	added inplace and regular matrix multiplication: computing A*B and A'*B
X	all matrix multiplication code is tested now
X	implemented A*x = y (inplace (w/resizing))
X	Matrix::allocate() made virtual
X	improved allocation of vectors (more optimal now)
X	added standard function to make an orthogonal Haar matrix
X	  (useful for testing/validating purposes)
X	Resizing a vector keeps old info now (expansion adds zeros (but still
X	  keeps old elements)
X	universal matrix creator from a special class: Lazy Matrices
X
XVersion 2.0, Mar 1994: Only LinAlg package was changed significantly
X	Linear Algebra library was made more portable and compiles now
X	  under gcc 2.5.8 without a single warning.
X	Added comparisons between a matrix and a scalar (for-every/all -type
X	  comparisons)
X	More matrix slice operators implemented
X	  (operations on a col/row/diag of a matrix, assignments them
X	  to/from a vector)
X	Other modules weren't changed (at least, significantly), but work
X	  fine with the updated libla library
X
XVersion 1.1, Mar 1992 (initial revision)
X
________This_Is_The_END________
if test `wc -l < README` -ne 277; then
echo 'shar: README was damaged during transit (should have had 277 lines)'
fi


echo 'x - NumMath.dr'
sed 's/^X//' << '________This_Is_The_END________' > NumMath.dr
X			Numerical Mathematical Library
X
XREADME			Simple Introduction plus revision history
XMakefile		Makefile for making the library
X
X		Linear Algebra, Basic Operations
XLinAlg.h		Declaration of Matrices, Vectors, etc. over
X			real numbers
Xmatrix1.cc		Level 1 BLAS, element-wise operations
Xmatrix2.cc		Level 2 BLAS, multiplications
Xmatrix_sub.cc		Level 1 & 2 BLAS, Matrix row/col/diag
Xmatrix_inv.cc		Find a matrix inverse
Xvector.cc		Specific vector operations, Level 1 & 2 BLAS
Xdeterminant.cc		Evaluate the determinant of a square matrix
X
Xvvector.cc		Verify operations on vectors
Xvvector.dat		Verification protocol
X
Xvmatrix.cc		Verify primitive operations on matrices
Xvmatrix1.cc		Verify multiplication/inv operations on matrices
Xvmatrix.dat		Verification protocol
Xvmatrix1.dat		Verification protocol
X
Xsample_adv.cc		Sample code demonstrating a few "advanced" features
Xsample_adv.dat		and comparisons with the traditional style
X
X
X		Numerical Math
Xmath_num.h		Declaration of the routines implementing various
X			numerical math algorithms
X
Xali.cc			Interpolation over the table of function values
Xvali.cc			Verification program
Xvali.dat		Verification protocol
X
Xhjmin.cc		Hooks-Jeevse multivariate optimization
Xvhjmin.cc		Validation code
Xvhjmin.dat		Validation test run
X
Xzeroin.cc		Brent's root finder
Xfminbr.cc		Brent's one-dimensional minimizer
Xvzeroin.cc		Verification program
Xvfminbr.cc		Verification program
Xvzeroin.dat		Verification protocol
Xvfminbr.dat		Verification protocol
X
Xsvd.h			Singular Value Decomposition
Xsvd.cc			Implementation of the SVD class
Xvsvd.cc			Verification code
Xvslesing.cc		Verification of the SVD applications
Xvsvd.dat		Verification protocol
Xvslesing.dat		Verification protocol
________This_Is_The_END________
if test `wc -l < NumMath.dr` -ne 52; then
echo 'shar: NumMath.dr was damaged during transit (should have had 52 lines)'
fi


echo 'x - Makefile'
sed 's/^X//' << '________This_Is_The_END________' > Makefile
X#				Makefile
X# 	to build and test the Numerical Math Library (libla.a)
X#
X# To build the library, you may want to edit the list of the library modules
X# below (MODULES). Say, if you don't need/want FFT, remove all the names
X# that contain fft from MODULES= below. Then make the modules you left
X# into the library by
X#		make lib
X# simple 'make' would suffice, too.
X#
X# To verify the library, do
X#	make check-all
X# or, more specifically,
X#	make vmatrix		(checks elementary matrix operations)
X#	make vvector		(checks elementary vector operations)
X#	make vmatrix1		(checks advanced matrix operations: multipl)
X#	
X#	make vzeroin		(verifies Brent's 1D root finder)
X#	make vfminbr		(verifies Brent's 1D minimizer)
X#
X# Note, this Makefile was built (and works under) GNU make 3.71
X#
X# Please check RANLIB below and adjust it to your system if necessary
X# (it was made for a BSD-like system)
X#
XCC=./c++
XCCL=./c++l
X.SUFFIXES: .cc
XMODULES=myenv.cc matrix1.cc matrix2.cc matrix_sub.cc \
X	vector.cc determinant.cc matrix_inv.cc \
X	zeroin.cc fminbr.cc ali.cc hjmin.cc svd.cc
X#	fft_init.cc fft_input.cc fft_output.cc
XLIBRARY=libla.a
X#RANLIB = (ar d $(LIBRARY) __.SYMDEF || true); ranlib $(LIBRARY) ; BSD-like
XRANLIB=/bin/true		# SYSV-based
X#	Rules, new style
X
X%.o : %.cc
X	$(CC) $*.cc
X
X% : %.o $(LIBRARY)
X	$(CCL) $< $(LIBRARY) -o $@
X	./$@
X
X% :: %.cc
X	$(CC) $*.cc
X	$(CCL) $*.o $(LIBRARY) -o $@
X	./$@
X
X#	Rules, old style
X#.o:	$*.o $(LIBRARY)
X#	$(CCL) $*.o $(LIBRARY) -o $*
X#	./$*
X#.cc: 	$*.cc $(LIBRARY)
X#	$(CC) $*.cc
X#	$(CCL) $*.o $(LIBRARY) -o $*
X#	./$*
X#.cc.o:
X#	$(CC) $*.cc
X#
X	
X# Primary goal
X
X# Library
X
Xlib:	$(LIBRARY)
X.PHONY: lib
X.PRECIOUS:	$(LIBRARY)
X
X$(LIBRARY)::    $(MODULES)
X# 			Compile the source files that have been changed 
X	$(CC) $?
X	listobj=`echo $? | sed s/.cc/.o/g` ; \
X	ar rv $(LIBRARY) $$listobj &&	\
X	rm $$listobj
X	$(RANLIB)
X
X# Verification routines
Xcheck-all:	vmatrix vvector vmatrix1 vali vhjmin vfminbr vzeroin \
X		vsvd vslesing
X
X#vmatrix1:	vmatrix1.o $(LIBRARY)
X#	$(CCL) vmatrix1.o $(LIBRARY) -o vmatrix1
X#	./vmatrix1
X
X
X# Specific dependent goals
X
X
X# Dependence rules
X
X$(LIBRARY)::	LinAlg.h
X	$(MAKE) -W matrix1.cc lib
X#vquadtree.o:	quadtree.h
________This_Is_The_END________
if test `wc -l < Makefile` -ne 94; then
echo 'shar: Makefile was damaged during transit (should have had 94 lines)'
fi


echo 'x - c++'
sed 's/^X//' << '________This_Is_The_END________' > c++
X#!/bin/sh
X#	GNU C++ compilation
X# Note, ${foo:+foo} is just a weird way of commenting out bar
Xgcc -c -O -pipe -W -Wall -Wpointer-arith -Wenum-clash -Woverloaded-virtual \
X-Wstrict-prototypes -Wmissing-prototypes ${foo:+'-Winline -Wredundant-decls'} \
X-finline-functions  -fforce-mem ${foo:+'-funsigned-char -fshort-enums'} \
X-fforce-addr -fstrict-prototype -felide-constructors -fno-implicit-templates \
X-fomit-frame-pointer -freg-struct-return -msupersparc ${foo:+'-fsave-memoized'} \
X-I. -I- $*
________This_Is_The_END________
if test `wc -l < c++` -ne 9; then
echo 'shar: c++ was damaged during transit (should have had 9 lines)'
fi


echo 'x - c++l'
sed 's/^X//' << '________This_Is_The_END________' > c++l
X#!/bin/sh
X#	GNU C++ linking
Xgcc -O -pipe -W -Wall -Wpointer-arith -Wenum-clash -Woverloaded-virtual \
X-Wstrict-prototypes -Wmissing-prototypes \
X-finline-functions  -fforce-mem -funsigned-char \
X-fforce-addr -fomit-frame-pointer \
X$* -liberty -lg++ -lm
________This_Is_The_END________
if test `wc -l < c++l` -ne 7; then
echo 'shar: c++l was damaged during transit (should have had 7 lines)'
fi


echo 'x - LinAlg.h'
sed 's/^X//' << '________This_Is_The_END________' > LinAlg.h
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *			  Linear Algebra Package
X *
X * The present package implements all the basic algorithms dealing
X * with vectors, matrices, matrix columns, etc.
X * Matrix is a basic object in the package; vectors, symmetric matrices,
X * etc. are considered matrices of a special type.
X *
X * Matrix elements are arranged in memory in a COLUMN-wise
X * fashion (in FORTRAN's spirit). In fact, it makes it very easy to
X * feed the matrices to FORTRAN procedures, which implement more
X * elaborate algorithms.
X *
X * Unless otherwise specified, matrix and vector indices always start
X * with 1, spanning up to the specified limit.
X *
X * The present package provides all facilities to completely AVOID returning
X * matrices. Use "Matrix A(Matrix::Transposed,B);" and other fancy constructors
X * as much as possible. If one really needs to return a matrix, return
X * a LazyMatrix object instead. The conversion is completely transparent
X * to the end user, e.g. "Matrix m = haar_matrix(5);" and _is_ efficient.
X *
X * $Id: LinAlg.h,v 3.1 1995/02/03 15:26:10 oleg Exp oleg $
X *
X ************************************************************************
X */
X
X#ifndef __GNUC__
X#pragma once
X#endif
X#ifndef _LinAlg_h
X#define _LinAlg_h 1
X
X#ifdef __GNUC__
X#pragma interface
X#endif
X
X#include "myenv.h"
X#include "std.h"
X#include <math.h>
X#include "builtin.h"
X#include <minmax.h>
X
Xtypedef float REAL;			// Scalar field of the Linear Vector
X					// space
X
Xclass Vector;				// Vector over the real domain
X
Xclass MatrixRow;			// A row of the matrix
Xclass MatrixColumn;			// A column of the matrix
Xclass MatrixDiag;			// The diagonal of the matrix
Xclass MatrixPivoting;			// For the determinant evaluation
X
X				// A class to do a specific operation on 
X				// every matrix element regardless of its
X				// position
Xclass ElementPrimAction
X{
X  friend class Matrix;
X  friend class Vector;
X  virtual void operation(REAL& element) = 0;
X				// Those are'n implemented; but since they're
X				// private, it forbids the assignement
X//  ElementPrimAction(const PixelPrimAction&);
X  ElementPrimAction& operator= (const ElementPrimAction&);
X};
X
X				// A class to do a specific operation on 
X				// every matrix element as the matrix
X				// is efficiently traversed
Xclass ElementAction
X{
X  friend class Matrix;
X  friend class Vector;
X  virtual void operation(REAL& element) = 0;
Xprotected:
X  int i, j;			// position of the element being passed to
X				// 'operator()'
X
Xprivate:			// Those are'n implemented; but since they're
X				// private, it forbids the assignement
X//  ElementAction(const PixelAction&);
X  ElementAction& operator= (const ElementAction&);
X};
X
X				// Lazy matrix constructor
X				// That is, a promise of a matrix rather than
X				// a matrix itself. The promise is forced
X				// by a Matrix constructor or assignment
X				// operator, see below.
X				// It's highly recommended a function never
X				// return Matrix itself. Use LazyMatrix
X				// instead
Xclass LazyMatrix
X{
X  friend class Matrix;
X  virtual void fill_in(Matrix& m) const = 0;
X
X  LazyMatrix(const LazyMatrix&);	// Don't implement to forbid assignment
X  LazyMatrix& operator = (const LazyMatrix&);
Xprotected:
X  int row_upb, row_lwb, col_upb, col_lwb;
Xpublic:
X  LazyMatrix(const int nrows, const int ncols)	// Indices start with 1
X    : row_upb(nrows), row_lwb(1), col_upb(ncols), col_lwb(1) {}
X  LazyMatrix(const int _row_lwb, const int _row_upb,// Or with low:upper
X	     const int _col_lwb, const int _col_upb)// boundary specif.
X    : row_upb(_row_upb), row_lwb(_row_lwb),
X      col_upb(_col_upb), col_lwb(_col_lwb) {}
X};
X
Xclass MinMax
X{
X  REAL min_val, max_val;
Xpublic:
X  MinMax(REAL _min_val, REAL _max_val)
X    : min_val(_min_val), max_val(_max_val) {}
X  REAL min(void) const		{ return min_val; }
X  REAL max(void) const		{ return max_val; }
X  double ratio(void) const	{ return max_val/min_val; }
X};
X
X/*
X *------------------------------------------------------------------------
X *			Basic class of matrix
X */
X
Xclass Matrix			// General type matrix
X{
X  friend class Vector;
X  friend class MatrixRow;
X  friend class MatrixColumn;
X  friend class MatrixDiag;
X  friend class MatrixPivoting;
X
Xprivate:			// Private part
X  int valid_code;			// Validation code
X  enum { MATRIX_val_code = 575767 };	// Matrix validation code value
X
Xprotected:			// May be used in derived classes
X  int nrows;				// No. of rows
X  int ncols;				// No. of columns
X  int row_lwb;				// Lower bound of the row index
X  int col_lwb;				// Lower bound of the col index
X  char * name;				// Name for the matrix
X  int nelems;				// Total no of elements, nrows*ncols
X  REAL ** index;			// index[i] = &matrix(0,i) (col index)
X  REAL * elements;			// Elements themselves
X
X  void allocate(const int nrows, const int ncols,
X			const int row_lwb = 1, const int col_lwb = 1);
X
X				// Elementary constructors
X  void _transpose(const Matrix& m);	// Allocate new matrix and set it to m'
X  void _invert(const Matrix& m);	// Allocate new matrix and set it to minv
X  void _AmultB(const Matrix& A, const Matrix& B);	// Matrix multipli-
X  void _AtmultB(const Matrix& A, const Matrix& B);	// cators
X
X  friend void _make_haar_matrix(Matrix& m);
X
Xpublic:			// Public interface
X
X				// Constructors and destructors
X					// Make a blank matrix
X  Matrix(const int nrows, const int ncols);	// Indices start with 1
X  Matrix(const int row_lwb, const int row_upb,	// Or with low:upper
X	 const int col_lwb, const int col_upb);	// boundary specif.
X
X  Matrix(const Matrix&  another);	// A real copy constructor, expensive
X
X					// Construct a matrix applying a spec
X					// operation to the prototype
X					// Example: Matrix A(10,12);
X					// Matrix B(Matrix::Transposed,A);
X  enum MATRIX_CREATORS_1op { Zero, Unit, Transposed, Inverted };
X  Matrix(const MATRIX_CREATORS_1op op, const Matrix& prototype);
X
X					// Construct a matrix applying a spec
X					// operation to two prototypes
X					// Example: Matrix A(10,12), B(12,5);
X					// Matrix C(A,Matrix::Mult,B);
X  enum MATRIX_CREATORS_2op { Mult, 		// A*B
X			     TransposeMult, 	// A'*B
X			     InvMult, 		// A^(-1)*B
X			     AtBA }; 		// A'*B*A
X  Matrix(const Matrix& A, const MATRIX_CREATORS_2op op, const Matrix& B);
X  Matrix(const Vector& x, const Vector& y);	// x'*y (diad) matrix
X					// Construct a matrix applying an
X					// arbitrary action to the prototype
X//  Matrix(ElementAction& action, const Matrix& prototype);
X  Matrix(const LazyMatrix& lazy_constructor);//Make a matrix using given recipe
X  Matrix(const char * file_name);	// Read the matrix from the file
X					// (not yet implemented!)
X
X  virtual ~Matrix();			// Destructor
X
X  void set_name(const char * name);	// Set a new matrix name
X
X					// Erase the old matrix and create a
X					// new one according to new boundaries
X  void resize_to(const int nrows, const int ncols);	// Indexation @ 1
X  void resize_to(const int row_lwb, const int row_upb,	// Or with low:upper
X		 const int col_lwb, const int col_upb);	// boundary specif.
X  void resize_to(const Matrix& m);			// Like other matrix m
X
X
X  void is_valid() const
X  { assure(valid_code == MATRIX_val_code,"Invalid matrix"); }
X
X				// Status inquires
X  int q_row_lwb() const			{ return row_lwb; }
X  int q_row_upb() const			{ return nrows+row_lwb-1; }
X  int q_nrows()	const			{ return nrows; }
X  int q_col_lwb() const			{ return col_lwb; }
X  int q_col_upb() const			{ return ncols+col_lwb-1; }
X  int q_ncols()	const			{ return ncols; }
X
X  int q_no_elems() const		{ return nelems; }
X
X  const char * q_name() const		{ return name; }
X
X				// Individual element manipulations
X  inline const REAL& operator () (const int rown, const int coln) const;
X  REAL& operator () (const int rown, const int coln)
X	{ return (REAL&)((*(const Matrix *)this)(rown,coln)); }
X
X
X			// Element-wise matrix operations
X
X				// Matrix-scalar arithmetics
X				// Modify every element of the
X				// Matrix according to the operation
X  Matrix& operator =   (const REAL val);	// Assignment to all the elems
X  Matrix& operator -=  (const double val);	// Add to elements
X  Matrix& operator +=  (const double val);	// Take from elements
X  Matrix& operator *=  (const double val);	// Multiply elements by a val
X
X				// Comparisons
X				// Find out if the predicate
X				// "element op val" is true for ALL matrix
X				// elements
X  bool	  operator ==  (const REAL val) const;	// ? all elems == val
X  bool	  operator !=  (const REAL val) const;	// ? all elems != val
X  bool	  operator <   (const REAL val) const;	// ? all elems <  val
X  bool	  operator <=  (const REAL val) const;	// ? all elems <= val
X  bool	  operator >   (const REAL val) const;	// ? all elems >  val
X  bool	  operator >=  (const REAL val) const;	// ? all elems >= val
X
X				// Other element-wise matrix operations
X  Matrix& clear(void);			// Clear the matrix (fill out with 0)
X  Matrix& abs(void);			// Take an absolute value of a matrix
X  Matrix& sqr(void);			// Square each element
X  Matrix& sqrt(void);			// Take a square root
X
X  Matrix& apply(ElementPrimAction& action);	// Apply a user-defined action
X  Matrix& apply(ElementAction& action);		// to each matrix element
X
X					// Invert the matrix returning the
X					// determinant if desired
X					// determinant = 0 if the matrix is
X					// singular
X					// If determ_ptr=0 and the matrix *is*
X					// singular, throw up
X  Matrix& invert(double * determ_ptr = 0);
X
X				// Element-wise operations on two matrices
X  inline Matrix& operator = (const Matrix& source);	// Assignment
X  Matrix& operator = (const LazyMatrix& source);// Force the promise of a matrix
X 
X					// Arithmetics
X  friend Matrix& operator += (Matrix& target, const Matrix& source);
X  friend Matrix& operator -= (Matrix& target, const Matrix& source);
X  friend Matrix& add(Matrix& target, const double scalar,const Matrix& source);
X  friend Matrix& element_mult(Matrix& target, const Matrix& source);
X  friend Matrix& element_div(Matrix& target, const Matrix& source);
X
X					// Comparisons
X  friend bool  operator == (const Matrix& im1, const Matrix& im2);
X  friend void compare(const Matrix& im1, const Matrix& im2, 
X		      const char * title);
X  friend inline void are_compatible(const Matrix& im1, const Matrix& im2);
X
X
X				// True matrix operations
X				// (on a matrix as a whole)  
X  Matrix& operator *= (const Matrix& source);	// Inplace multiplication
X						// possible only for square src
X
X  Matrix& operator *= (const MatrixDiag& diag);	// Multiply by the diagonal of
X						// another matrix
X  
X  void mult(const Matrix& A, const Matrix& B);  // Compute A*B
X
X				// Compute matrix norms
X  double row_norm(void) const;		// MAX{ SUM{ |M(i,j)|, over j}, over i}
X  double norm_inf(void) const		// Alias, shows the norm is induced
X         { return row_norm(); }		// 	by the vector inf-norm
X  double col_norm(void) const;		// MAX{ SUM{ |M(i,j)|, over i}, over j}
X  double norm_1(void) const		// Alias, shows the norm is induced
X         { return col_norm(); }		// 	by the vector 1-norm
X  double e2_norm(void) const;		// SUM{ m(i,j)^2 }, Note it's square
X					// of the Frobenius rather than 2. norm
X
X  friend double e2_norm(const Matrix& m1, const Matrix& m2);
X					// e2_norm(m1-m2)
X
X  double determinant(void) const;	// Matrix must be a square one
X
X  double asymmetry_index(void) const;	// How far is the matrix from being
X					// symmetrical (0 means complete symm)
X					// (not yet implemented)
X
X				// Make matrices of a special kind
X  Matrix& unit_matrix(void);		// Matrix needn't be a square
X  Matrix& hilbert_matrix(void);		// Hilb[i,j] = 1/(i+j-1); i,j=1..max
X
X				// I/O: write, read, print 
X  					// Write to a file
X					// "| command name" is OK as a file
X					// name
X  void write(const char * file_name,const char * title = "") const;
X  void info(void) const;		// Print the info about the Matrix
X  void print(const char * title) const;	// Print the Matrix as a table
X
X};
X
X				// Create an orthogonal (2^n)*(no_cols) Haar
X				// (sub)matrix, whose columns are Haar
X				// functions
X				// If no_cols is 0, create the complete matrix
X				// with 2^n columns
Xclass haar_matrix : public LazyMatrix
X{
X  void fill_in(Matrix& m) const		{ _make_haar_matrix(m); }
Xpublic:
X  haar_matrix(const int n, const int no_cols=0);
X};
X
X
X/*
X *------------------------------------------------------------------------
X *			Inline Matrix operations
X */
X
Xinline Matrix::Matrix(const int no_rows, const int no_cols)
X{
X  allocate(no_rows,no_cols);
X}
X
Xinline Matrix::Matrix(const int row_lwb, const int row_upb,
X		      const int col_lwb, const int col_upb)
X{
X  allocate(row_upb-row_lwb+1,col_upb-col_lwb+1,row_lwb,col_lwb);
X}
X
Xinline Matrix::Matrix(const LazyMatrix& lazy_constructor)
X{
X  allocate(lazy_constructor.row_upb-lazy_constructor.row_lwb+1,
X	   lazy_constructor.col_upb-lazy_constructor.col_lwb+1,
X	   lazy_constructor.row_lwb,lazy_constructor.col_lwb);
X  lazy_constructor.fill_in(*this);
X}
X
X
X				// Force the promise of a matrix
X				// That is, apply a lazy_constructor
X				// to the current matrix
Xinline Matrix& Matrix::operator = (const LazyMatrix& lazy_constructor)
X{
X  is_valid();
X  if( lazy_constructor.row_upb != q_row_upb() ||
X      lazy_constructor.col_upb != q_col_upb() ||
X      lazy_constructor.row_lwb != q_row_lwb() ||
X      lazy_constructor.col_lwb != q_col_lwb() )
X    info(),
X    _error("The matrix above is incompatible with the assigned "
X    	   "Lazy matrix");
X      
X  lazy_constructor.fill_in(*this);
X  return *this;
X}
X
X					// Copy constructor, expensive: use
X					// sparingly
Xinline Matrix::Matrix(const Matrix& another)
X{
X  another.is_valid();
X  allocate(another.nrows,another.ncols,another.row_lwb,another.col_lwb);
X  *this = another;
X}
X
X				// Resize the matrix to accomodate to a pattern
Xinline void Matrix::resize_to(const Matrix& m)
X{
X  resize_to(m.q_row_lwb(),m.q_row_upb(),m.q_col_lwb(),m.q_col_upb());
X}
X
Xinline const REAL& Matrix::operator () (const int rown, const int coln) const
X{
X  is_valid();
X  register int arown = rown-row_lwb;		// Effective indices
X  register int acoln = coln-col_lwb;
X
X  if( arown >= nrows || arown < 0 )
X    _error("Row index %d is out of Matrix boundaries [%d,%d]",
X	   rown,row_lwb,nrows+row_lwb-1);
X  if( acoln >= ncols || acoln < 0 )
X    _error("Col index %d is out of Matrix boundaries [%d,%d]",
X	   coln,col_lwb,ncols+col_lwb-1);
X  
X  return (index[acoln])[arown];
X}
X
Xinline Matrix& Matrix::clear(void)	// Clean the Matrix
X{
X  is_valid();
X  memset(elements,0,nelems*sizeof(REAL));
X  return *this;
X}
X
Xinline void are_compatible(const Matrix& im1, const Matrix& im2)
X{
X  im1.is_valid();
X  im2.is_valid();
X  
X  if( im1.nrows != im2.nrows || im1.ncols != im2.ncols ||
X      im1.row_lwb != im2.row_lwb || im1.col_lwb != im2.col_lwb )
X    im1.info(), im2.info(), _error("The matrices above are incompatible");
X}
X
X				// Assignment
Xinline Matrix& Matrix::operator = (const Matrix& source)
X{
X  are_compatible(*this,source);
X  memcpy(elements,source.elements,nelems*sizeof(REAL));
X  return *this;
X}
X
X				// Apply a user-defined action to each matrix
X				// element
Xinline Matrix& Matrix::apply(ElementPrimAction& action)
X{
X  is_valid();
X  for(register REAL * ep=elements; ep < elements+nelems; ep++)
X    action.operation(*ep);
X
X  return *this;
X}
X
X/*
X *------------------------------------------------------------------------
X *		Friend classes - MatrixRow, MatrixCol, MatrixDiag
X */
X
Xclass MatrixColumn		// Special representation of a Col of the
X{				// matrix
X  friend class Matrix;
X  friend class Vector;
X
X  const Matrix& matrix;			// The matrix i am a column of
X  REAL * ptr;				// Pointer to the a[0,i]
X
Xpublic:					// Take a col of the matrix
X  MatrixColumn(const Matrix& matrix, const int col);
X
X					// Assign a value to all the elements
X					// of the Matrix Col
X  void operator = (const REAL val);
X  					// Modify the elements in the col
X  void operator +=  (const double val);
X  void operator *=  (const double val);
X
X  void operator = (const Vector& vec);	// Assign a vector to a matrix col
X
X  					// Individual element manipulations
X  inline const REAL& operator () (const int i) const;
X  inline REAL& operator () (const int i)
X	{ return (REAL&)((*(const MatrixColumn *)this)(i)); }
X};
X
X				// Construct the MatrixColumn
Xinline MatrixColumn::MatrixColumn(const Matrix& _matrix, const int col)
X	: matrix(_matrix)
X{
X  matrix.is_valid();
X
X  register int colind = col - matrix.col_lwb;
X
X  if( colind >= matrix.ncols || colind < 0 )
X    matrix.info(),
X    _error("Column #%d is not within the above matrix",col);
X
X  MatrixColumn::ptr = &(matrix.index[colind][0]);
X}
X
X				// Access the i-th element of the column
Xinline const REAL& MatrixColumn::operator () (const int i) const
X{
X  matrix.is_valid();
X  register int arown = i-matrix.row_lwb;		// Effective indices
X
X  if( arown >= matrix.nrows || arown < 0 )
X    _error("MatrixColumn index %d is out of column boundaries [%d,%d]",
X	   i,matrix.row_lwb,matrix.nrows+matrix.row_lwb-1);
X  return ptr[arown];
X}
X
Xclass MatrixRow			// Special representation of a Row of the
X{				// matrix
X  friend class Matrix;
X  friend class Vector;
X
X  const Matrix& matrix;			// The matrix i am a row of
X  const int inc;			// if ptr=@a[row,i], then
X					//    ptr+inc = @a[row,i+1]
X					// Since elements of a[] are stored
X					// col after col, inc = nrows
X  REAL * ptr;				// Pointer to the a[row,0]
X
Xpublic:				// Take a row of the matrix
X  MatrixRow(const Matrix& matrix, const int row);
X
X					// Assign a value to all the elements
X					// of the Matrix Row   
X  void operator = (const REAL val);
X  					// Modify the elements in the row
X  void operator +=  (const double val);
X  void operator *=  (const double val);
X
X  void operator = (const Vector& vec);	// Assign a vector to a matrix row
X
X  					// Individual element manipulations
X  inline const REAL& operator () (const int i) const;
X  inline REAL& operator () (const int i)
X	{ return (REAL&)((*(const MatrixRow *)this)(i)); }
X};
X
X				// Construct the MatrixRow
Xinline MatrixRow::MatrixRow(const Matrix& _matrix, const int row)
X  : matrix(_matrix), inc(_matrix.nrows)
X{
X  matrix.is_valid();
X
X  register int rowind = row - matrix.row_lwb;
X
X  if( rowind >= matrix.nrows || rowind < 0 )
X    matrix.info(),
X    _error("Row #%d is not within the above matrix",row);
X
X  MatrixRow::ptr = &(matrix.index[0][rowind]);
X}
X
X				// Get hold of the i-th row's element
Xinline const REAL& MatrixRow::operator () (const int i) const
X{
X  matrix.is_valid();
X  register int acoln = i-matrix.col_lwb;		// Effective index
X
X  if( acoln >= matrix.ncols || acoln < 0 )
X    _error("MatrixRow index %d is out of row boundaries [%d,%d]",
X	   i,matrix.col_lwb,matrix.ncols+matrix.col_lwb-1);
X  return matrix.index[acoln][ptr-matrix.elements];
X}
X
X
X
Xclass MatrixDiag		// Special representation of the diagonal of a
X{				// matrix (for easy manipulation)
X  friend class Matrix;
X  friend class Vector;
X
X  const Matrix& matrix;			// The matrix i am the diagonal of
X  const int inc;			// if ptr=@a[i,i], then
X					//    ptr+inc = @a[i+1,i+1]
X					// Since elements of a[] are stored
X					// col after col, inc = nrows+1
X  const int ndiag;			// No of diag elems, min(nrows,ncols)
X  REAL * ptr;				// Pointer to the a[0,0]
X
Xpublic:					// Take a diag of the matrix
X  MatrixDiag(const Matrix& matrix);
X					// Assign a value to all the elements
X					// of the Matrix Diag
X  void operator = (const REAL val);
X  					// Modify the elements in the diag
X  void operator +=  (const double val);
X  void operator *=  (const double val);
X
X  void operator = (const Vector & vec);	// Assign a vector to a matrix diag
X
X  					// Individual element manipulations
X  inline const REAL& operator () (const int i) const;
X  inline REAL& operator () (const int i)
X	{ return (REAL&)((*(const MatrixDiag *)this)(i)); }
X  int q_ndiags(void) const		{ return ndiag; }
X};
X
X				// Construct the MatrixDiag
Xinline MatrixDiag::MatrixDiag(const Matrix& _matrix)
X: matrix(_matrix), inc(_matrix.nrows+1), 
X  ndiag(::min(_matrix.nrows,_matrix.ncols))
X{
X  matrix.is_valid();
X  MatrixDiag::ptr = &(matrix.elements[0]);
X}
X
X				// Get hold of the i-th diag element
X				// (indexing always starts at 1, regardless
X				// of matrix' col_lwb and row_lwb)
Xinline const REAL& MatrixDiag::operator () (const int i) const
X{
X  matrix.is_valid();
X  if( i > ndiag || i < 1 )
X    _error("MatrixDiag index %d is out of diag boundaries [1,%d]",
X	   i,ndiag);
X  return matrix.index[i-1][i-1];
X}
X
X/*
X *------------------------------------------------------------------------
X *		   Vector as a n*1 matrix (that is, a col-matrix)
X */
X
Xclass Vector : public Matrix
X{
X  friend class MatrixRow;
X  friend class MatrixColumn;
X  friend class MatrixDiag;
X
Xpublic:
X  Vector(const int n);		// Specify a blank vector for a given
X					// dimension, with indexation at 1
X  Vector(const int lwb, const int upb); // Specify a general lwb:upb vector
X//  Vector(const Vector& another);	// a copy constructor (to be inferred)
X
X					// Make a vector and assign init vals
X  Vector(const int lwb, const int upb,  // lower and upper bounds
X	 double iv1, ...    		// DOUBLE numbers. The last arg of
X	 ); 				// the list must be string "END"
X					// E.g: Vector f(1,2,0.0,1.5,"END");
X
X  Vector(const LazyMatrix& lazy_constructor);//Make a vector using given recipe
X
X				// Resize the vector (keeping as many old
X				// elements as possible), expand by zeros
X  void resize_to(const int n);			// Indexation @ 1
X  void resize_to(const int lwb, const int upb); 	// lwb:upb specif
X  void resize_to(const Vector& v);			// like other vector
X
X  inline REAL & operator () (const int index) const;
X  inline REAL& operator () (const int index)
X	{ return (REAL&)((*(const Vector *)this)(index)); }
X
X				// Listed below are specific vector operations
X				// (unlike n*1 matrices)
X
X					// Status inquires
X  int q_lwb(void) const		{ return row_lwb; }
X  int q_upb(void) const		{ return nrows + row_lwb - 1; }
X
X					// Compute the scalar product
X  friend double operator * (const Vector& v1, const Vector& v2);
X
X					// "Inplace" multiplication
X					// target = A*target
X					// A needn't be a square one (the
X					// target will be resized to fit)
X  Vector& operator *= (const Matrix& A);
X
X  Vector& operator *=  (const double val)	// Multiply elements by a val
X	{ Matrix::operator *=(val); return *this; }
X
X					// Vector norms
X  double norm_1(void) const;   			// SUM{ |v[i]| }
X  double norm_2_sqr(void) const;	       	// SUM{ v[i]^2 }
X  double norm_inf(void) const;			// MAX{ |v[i]| }
X
X  Vector& operator = (const Vector& v)
X  	{ Matrix::operator =(v); return *this; }
X  Vector& operator = (const REAL val)	// Assign to all elems of a vector
X  	{ Matrix::operator =(val); return *this; }
X  Vector& operator = (const LazyMatrix& source)// Force the promise of a vector
X  	{ Matrix::operator =(source); return *this; }
X
X  Vector& operator = (const MatrixRow& mr);
X  Vector& operator = (const MatrixColumn& mc);
X  Vector& operator = (const MatrixDiag& md);
X};
X  
X				// Create a blank vector of a given size
Xinline Vector::Vector(const int n) : Matrix(n,1)
X{}
X
X				// Create a general blank vector
Xinline Vector::Vector(const int lwb, const int upb) : Matrix(lwb,upb,1,1)
X{}
X
X				// Resize the vector for a specified number
X				// of elements, trying to keep intact as many
X				// elements of the old vector as possible.
X				// If the vector is expanded, the new elements
X				// will be zeroes
Xinline void Vector::resize_to(const int n)	{ Vector::resize_to(1,n); }
X
Xinline void Vector::resize_to(const Vector& v)
X{
X  Vector::resize_to(v.q_lwb(),v.q_upb());
X}
X
X				// Get access to a vector element
Xinline REAL& Vector::operator () (const int ind) const
X{
X  is_valid();
X  register int aind = ind - row_lwb;
X  if( aind >= nelems || aind < 0 )
X    _error("Requested element %d is out of Vector boundaries [%d,%d]",
X	   ind,row_lwb,nrows+row_lwb-1);
X  
X  return elements[aind];
X}
X
X				// Make a vector follow a recipe
Xinline Vector::Vector(const LazyMatrix& lazy_constructor)
X  : Matrix(lazy_constructor)
X{
X  assure(ncols == 1 && col_lwb == 1,
X         "cannot make a vector from a promise of a full matrix");
X}
X
X				// Service functions (useful in the
X				// verification code). They print some detail
X				// info if the validation condition fails
Xvoid verify_element_value(const Matrix& m,const REAL val);
Xvoid verify_matrix_identity(const Matrix& m1, const Matrix& m2);
X
X#endif
________This_Is_The_END________
if test `wc -l < LinAlg.h` -ne 739; then
echo 'shar: LinAlg.h was damaged during transit (should have had 739 lines)'
fi


echo 'x - builtin.h'
sed 's/^X//' << '________This_Is_The_END________' > builtin.h
X// This may look like C code, but it is really -*- C++ -*-
X
X/* 
XCopyright (C) 1988, 1992 Free Software Foundation
X    written by Doug Lea (dl@rocky.oswego.edu)
X
XThis file is part of the GNU C++ Library.  This library is free
Xsoftware; you can redistribute it and/or modify it under the terms of
Xthe GNU Library General Public License as published by the Free
XSoftware Foundation; either version 2 of the License, or (at your
Xoption) any later version.  This library is distributed in the hope
Xthat it will be useful, but WITHOUT ANY WARRANTY; without even the
Ximplied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
XPURPOSE.  See the GNU Library General Public License for more details.
XYou should have received a copy of the GNU Library General Public
XLicense along with this library; if not, write to the Free Software
XFoundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X*/
X
X/*
X  arithmetic, etc. functions on built in types
X*/
X
X
X#ifndef _builtin_h
X#ifdef __GNUG__
X#pragma interface
X#endif
X#define _builtin_h 1
X
X#include <stddef.h>
X#include <std.h>
X#include <math.h>
X
X#ifdef __GNUG__
X#define _VOLATILE_VOID volatile void
X#else
X#define _VOLATILE_VOID void
X#endif
X
Xtypedef void (*one_arg_error_handler_t)(const char*);
Xtypedef void (*two_arg_error_handler_t)(const char*, const char*);
X
Xlong         gcd(long, long);
Xlong         lg(unsigned long); 
Xdouble       pow(double, long);
Xlong         pow(long, long);
X
Xextern "C" double       start_timer();
Xextern "C" double       return_elapsed_time(double last_time = 0.0);
X
Xchar*        dtoa(double x, char cvt = 'g', int width = 0, int prec = 6);
X
Xunsigned int hashpjw(const char*);
Xunsigned int multiplicativehash(int);
Xunsigned int foldhash(double);
X
Xextern _VOLATILE_VOID default_one_arg_error_handler(const char*);
Xextern _VOLATILE_VOID default_two_arg_error_handler(const char*, const char*);
X
Xextern two_arg_error_handler_t lib_error_handler;
X
Xextern two_arg_error_handler_t 
X       set_lib_error_handler(two_arg_error_handler_t f);
X
X
X#if !defined(IV)
X
X#if ! _G_MATH_H_INLINES /* hpux and SCO define this in math.h */
Xinline double abs(double arg) 
X{
X  return (arg < 0.0)? -arg : arg;
X}
X#endif
X
Xinline float abs(float arg) 
X{
X  return (arg < 0.0)? -arg : arg;
X}
X
Xinline short abs(short arg) 
X{
X  return (arg < 0)? -arg : arg;
X}
X
Xinline long abs(long arg) 
X{
X  return (arg < 0)? -arg : arg;
X}
X
Xinline int sign(long arg)
X{
X  return (arg == 0) ? 0 : ( (arg > 0) ? 1 : -1 );
X}
X
Xinline int sign(double arg)
X{
X  return (arg == 0.0) ? 0 : ( (arg > 0.0) ? 1 : -1 );
X}
X
Xinline long sqr(long arg)
X{
X  return arg * arg;
X}
X
X#if ! _G_MATH_H_INLINES /* hpux and SCO define this in math.h */
Xinline double sqr(double arg)
X{
X  return arg * arg;
X}
X#endif
X
Xinline int even(long arg)
X{
X  return !(arg & 1);
X}
X
Xinline int odd(long arg)
X{
X  return (arg & 1);
X}
X
Xinline long lcm(long x, long y)
X{
X  return x / gcd(x, y) * y;
X}
X
Xinline void (setbit)(long& x, long b)
X{
X  x |= (1 << b);
X}
X
Xinline void clearbit(long& x, long b)
X{
X  x &= ~(1 << b);
X}
X
Xinline int testbit(long x, long b)
X{
X  return ((x & (1 << b)) != 0);
X}
X
X#endif
X#endif
________This_Is_The_END________
if test `wc -l < builtin.h` -ne 144; then
echo 'shar: builtin.h was damaged during transit (should have had 144 lines)'
fi


echo 'x - math_num.h'
sed 's/^X//' << '________This_Is_The_END________' > math_num.h
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *			  Numerical Math Package
X *
X * The present package implements various algorithms of Numerical Math
X *
X * $Id: math_num.h,v 3.1 1995/02/07 15:08:22 oleg Exp oleg $
X *
X ************************************************************************
X */
X
X#ifndef __GNUC__
X#pragma once
X#endif
X#ifndef _math_num_h
X#define _math_num_h 1
X
X#pragma interface
X
X#include "myenv.h"
X#include <math.h>
X#include "builtin.h"
X#include "std.h"
X
X/*
X *------------------------------------------------------------------------
X *				Some constants
X * Compile and run the program epsilon.c to determine the values below for
X * your computer
X */
X
X#define EPSILON		2.22045e-16	// DBL_EPSILON
X#define SQRT_EPSILON	1.49012e-08
X
X/*
X *------------------------------------------------------------------------
X *		Brent's minimum and zero finders for 
X *		  a function of a single argument
X */
X
X				// Obtain a zero of function f
X				// over the range [ax,bx] with the
X				// accuracy tol.
Xdouble zeroin(const double ax, const double bx, 
X	      double (*f)(const double x), const double tol=EPSILON);
X
X				// Find a minimum of function f
X				// over the range [a,b] with the
X				// accuracy tol.
X				// Returns an approx. to the min location
Xdouble fminbr(const double a, const double b, 
X	      double (*f)(const double x), const double tol=EPSILON);
X
Xclass Vector;			// Opaque class used by the routines below
X
X/*
X *------------------------------------------------------------------------
X *			Interpolation of the function
X *			specified in the tabular form
X */
X
X
X				// Aitken-Lagrange interpolation to the
X				// point q over the table of function values
X				// y[i] = y(x[i]), i = y.lwb..y.upb
X
X				// Uniform mesh x[i] = x0 + s*(i-y.lwb)
Xdouble ali(const double q, const double x0, const double s, const Vector& y);
X				// Nonuniform grid with nodes in x[i]
Xdouble ali(const double q, const Vector& x, const Vector& y);
X
X/*
X *------------------------------------------------------------------------
X *			Multi-dimensional minimization
X */
X
X				// Find a local minimum of a given
X				// function by the Hook-Jeevse method
Xdouble hjmin(				// Return the function value at min
X	Vector& b,			// Input: initial guess to min loc
X					// Output: loc for the min found
X 	Vector& h,			// Input: initial values for the
X 					// 	  steps along each b(i)
X 					// Output: final steps right before
X 					// 	  the termination
X 	double (*f)(const Vector& x)	// Procedure to compute a function
X 					// value at the specified point
X	    );
X
X
X	    			// The same as above with the only difference
X	    			// initial steps are given to be the same
X	    			// along every direction. The final steps
X	    			// aren't reported back though
Xdouble hjmin(Vector& b,	const double h0,
X 	     double (*f)(const Vector& x));
X
X#endif
________This_Is_The_END________
if test `wc -l < math_num.h` -ne 100; then
echo 'shar: math_num.h was damaged during transit (should have had 100 lines)'
fi


echo 'x - myenv.h'
sed 's/^X//' << '________This_Is_The_END________' > myenv.h
X// This may look like C code, but it is really -*- C++ -*-
X//************************************************************************
X//
X//			A standard environment
X//			  I am accustomed to
X//
X// $Id: myenv.h,v 1.4 1995/06/05 16:15:43 oleg Exp oleg $
X
X#ifndef __GNUC__
X#pragma once
X#endif
X#ifndef _myenv_h
X#define _myenv_h
X
X#ifdef __GNUC__
X#pragma interface
X#endif
X
X				/* Strings of symbols			*/
X				/* They may be used as a delimiting lines*/
Xextern const char _Minuses [];
Xextern const char _Asteriscs [];
Xextern const char _Equals [];
X
X				/* Print an error message at stderr and	*/
X				/* abort				*/
Xvolatile void _error(
X	const char * message,		/* Message to be printed	*/
X	...                             /* Additional args to printf	*/
X	   );
X
X				/* Print a message at stderr 		*/
Xvoid message(
X	const char * text,		/* Message to be printed	*/
X	...                             /* Additional args to printf	*/
X	   );
X
X//------------------------------------------------------------------------
X//		    Patches to the standard environment
X
X                                // Like strncpy(), but ALWAYS terminates
X                                // the destination string
Xchar * xstrncpy(char * dest, const char * src, const int len);
X
Xinline long int sqr(const int x)		{ return x*x; }
X
X				// Uncomment if the compiler sucks
X#ifdef __MWERKS__
X#define bool Boolean
X#endif
X#if 0
Xenum bool {false,true};
X#endif
X
X				// libg++ nifty timing functions
X				// return_elapsed_time(Last_time) returns
X				// process time (in secs) since Last_Time
X				// If Last_time == 0.0, return time since
X				// the last call to start_timer()
X#ifndef __GNUC__
Xdouble start_timer(void);
Xdouble return_elapsed_time(const double Last_Time);
X#endif
X
X
X//------------------------------------------------------------------------
X//			Verify the assertion
X
X#if 0
X  					/* Print a message and abort*/
Xextern volatile void _error( const char * message,... ); 
X#endif
X
X#define assert(ex) \
X        (void)((ex) ? 1 : \
X              (_error("Failed assertion " #ex " at line %d of `%s'.\n", \
X               __LINE__, __FILE__), 0))
X#define assertval(ex) assert(ex)
X
X#define assure(expr,message)				\
X	if	(expr) ;				\
X	else _error("%s\n at line %d of '%s'.",message,__LINE__, __FILE__)
X
X
X#endif
________This_Is_The_END________
if test `wc -l < myenv.h` -ne 85; then
echo 'shar: myenv.h was damaged during transit (should have had 85 lines)'
fi


echo 'x - std.h'
sed 's/^X//' << '________This_Is_The_END________' > std.h
X// This may look like C code, but it is really -*- C++ -*-
X/* 
XCopyright (C) 1988, 1992 Free Software Foundation
X    written by Doug Lea (dl@rocky.oswego.edu)
X
XThis file is part of the GNU C++ Library.  This library is free
Xsoftware; you can redistribute it and/or modify it under the terms of
Xthe GNU Library General Public License as published by the Free
XSoftware Foundation; either version 2 of the License, or (at your
Xoption) any later version.  This library is distributed in the hope
Xthat it will be useful, but WITHOUT ANY WARRANTY; without even the
Ximplied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
XPURPOSE.  See the GNU Library General Public License for more details.
XYou should have received a copy of the GNU Library General Public
XLicense along with this library; if not, write to the Free Software
XFoundation, 675 Mass Ave, Cambridge, MA 02139, USA.
X*/
X
X#ifndef _std_h
X#define _std_h 1
X
X#include <_G_config.h>
X#include <defines.h>
X#include <stdlib.h>
X#include <string.h>
X#include <unistd.h>
X#include <stdio.h> 
X#include <errno.h>
X#include <fcntl.h>
X
Xextern "C" {
Xint strcasecmp _G_ARGS((const char*, const char*));
X}
X
X#endif 
________This_Is_The_END________
if test `wc -l < std.h` -ne 35; then
echo 'shar: std.h was damaged during transit (should have had 35 lines)'
fi


echo 'x - svd.h'
sed 's/^X//' << '________This_Is_The_END________' > svd.h
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *			  Numerical Math Package
X *
X *	Singular Value Decomposition of a rectangular matrix
X *			   A = U * Sig * V'
X *			and its applications
X *
X * In the decomposition above, matrices U and V are orthogonal; matrix
X * Sig is a diagonal matrix: its diagonal elements, which are all
X * non-negative, are singular values (numbers) of the original matrix A.
X * In another interpretation, the singular values are eigenvalues
X * of matrix A'A.
X *
X * $Id$
X *
X ************************************************************************
X */
X
X#ifndef __GNUC__
X#pragma once
X#endif
X#ifndef _svd_h
X#define _svd_h 1
X
X#pragma interface
X
X#include "LinAlg.h"
X
X				// A class that holds U,V,Sig - the singular
X				// value decomposition of a matrix
Xclass SVD
X{
X  const int M,N;			// Dimensions of the problem (M>=N)
X  Matrix U;				// M*M orthogonal matrix U
X  Matrix V;				// N*N orthogonal matrix V
X  Vector sig;				// Vector(1:N) of N onordered singular
X  					// values
X  
X  					// Internal procedures used in SVD
X inline double left_hausholder(Matrix& A, const int i);
X inline double right_hausholder(Matrix& A, const int i);
X double bidiagonalize(Vector& super_diag, const Matrix& _A);
X
X inline void rotate(Matrix& U, const int i, const int j,
X		    const double cos_ph, const double sin_ph);
X inline void rip_through(
X	Vector& super_diag, const int k, const int l, const double eps);
X inline int get_submatrix_to_work_on(
X	Vector& super_diag, const int k, const double eps);
X void diagonalize(Vector& super_diag, const double eps);
X 
Xpublic:
X  SVD(const Matrix& A);			// Decompose Matrix A, of M rows and
X  					// N columns, M>=N
X  
X  					// Regularization: make all sig(i)
X  					// that are smaller than min_sig
X  					// exactly zeros
X  void cut_off(const double min_sig);
X  
X  				// Inquiries
X  const Matrix& q_U(void) const		{ return U; }
X  const Matrix& q_V(void) const		{ return V; }
X  const Vector& q_sig(void) const	{ return sig; }
X
X  operator MinMax(void) const;		// Return min and max singular values
X  double q_cond_number(void) const;	// sig_max/sig_min
X  void info(void) const;		// Print the info about the SVD
X};
X
X/*
X *------------------------------------------------------------------------
X * Application of SVD to a regularized solution of a set of simultaneous
X * linear equations Ax=B
X * B can be either a vector (Mx1-matrix), or a full-blown matrix.
X * Note, if B=Unit(A), SVD_inv_mult class gives a (pseudo)inverse matrix;
X * btw, A doesn't even have to be a square matrix.
X * In the case of a rectangular matrix MxN matrix A with M>N, the set
X * Ax=b is obviously overspecified. The solution x produced by SVD_inv_mult
X * is the least-norm solution: the solution returned by the least-squares
X * method.
X * tau is a regularization criterion: only singular values bigger than tau
X * would participate. If tau is not given, it's assumed to be
X * dim(sig)*max(sig)*FLT_EPSILON
X *
X * Use the SVD_inv_mult object as follows:
X * 	SVD svd(A);
X *	cout << "condition number of matrix A " << svd.q_cond_number();
X *	Vector x = SVD_inv_mult(svd,b);		// Solution of Ax=b
X *
X */
X
Xclass SVD_inv_mult : public LazyMatrix
X{
X  const SVD& svd;
X  const Matrix& B;
X  double tau;			// smallness threshold for sig[i]
X  bool are_zero_coeff;		// true if A had an incomplete rank
X  void fill_in(Matrix& m) const;
Xpublic:	
X  SVD_inv_mult(const SVD& _svd, const Matrix& _B,const double tau=0);
X};
X
X#endif
________This_Is_The_END________
if test `wc -l < svd.h` -ne 107; then
echo 'shar: svd.h was damaged during transit (should have had 107 lines)'
fi


echo 'x - ali.cc'
sed 's/^X//' << '________This_Is_The_END________' > ali.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *			  Numerical Math Package
X *		     Aitken-Lagrange interpolation
X *
X * This package allows one to interpolate a function value for a given
X * argument value using function values tabulated over either uniform or
X * non-uniform grid. The latter is specified by a vector of node point
X * abscissae. The uniform grid is specified by a grid mesh and the
X * abscissa of the first grid point.
X *
X * Synopsis
X *	double ali(q,x0,s,y)
X *	double q 			Argument value specified
X *	double x0 			Abscissae for the 1. grid point
X *	double s 			Grid mesh, >0
X *	VECTOR y			Vector of function values
X *					tabulated at points
X *					x0 + s*(i-y.q_lwb()))
X *                                      The vector must contain at 
X *					least 2 elements
X *
X *	double ali(q,x,y)
X *	const double q			Argument value specified
X *	const VECTOR x			Vector of grid node abscissae
X *	const VECTOR y			Vector of function values
X *					tabulated at points x[i]
X *                                      The vector must contain at 
X *					least 2 elements
X * Output
X *	Both functions return the interpolated function value at point q
X *	Interpolating process finishes either
X *		- if the difference between two successive interpolated
X *		  values is absolutely less than EPSILON
X *		- if the absolute value of this difference stops
X *		  diminishing
X *		- after (N-1) steps, N being the no. of elements in vector y
X *
X * Algorithm
X *	Aitken scheme of Lagrange interpolation
X *	Algorithm is described in the book
X *		"Mathematical software for computers", Institute of
X *		 Mathematics of the Belorussian Academy of Sciences,
X *		 Minsk, 1974, issue #4,
X *		 p. 146 (description of ALI, DALI subroutines)
X *		 p. 180 (description of ATSE, DATSE subroutines)
X *	The book essentially describes IBM's SSP package.
X *
X * $Id$
X *
X ************************************************************************
X */
X
X
X#include "LinAlg.h"
X#include "math_num.h"
X#include <std.h>
X#include <float.h>
X
X
X//#define DEBUG
X
X/*
X *------------------------------------------------------------------------
X *		     Class that handles the interpolation
X */
X
Xclass ALInterp
X{
X  Vector arg;			// [1:n] Arranged table of arguments
X  Vector val;			// [1:n] Arranged table of function values
X  double q;           		// Argument value the function is to be
X				// interpolated at
X
Xpublic:
X				// Construct the arranged tables for the
X				// uniform grid
X  ALInterp(const double q, const double x0, const double s, const Vector& y);
X				// Construct the arranged tables for the
X				// non-uniform grid
X  ALInterp(const double q, const Vector& x, const Vector& y);
X
X  double interpolate(void);	// Perform actual interpolation
X};
X
X/*
X *------------------------------------------------------------------------
X *
X *		Arranging data for the Aitken-Lagrange interpolation
X *
X * Abscissae (arg) and ordinates (val) of the grid points should be arranged
X * in such a way that the distance abs(q-arg[i]) would increase as i
X * increases. 
X * Here q is the point the function is to be interpolated at.
X *
X */
X
X				// Construct the arranged tables for the
X				// uniform grid
XALInterp::ALInterp(const double _q, const double x0,
X		   const double s, const Vector& y)
X	: arg(y.q_no_elems()), val(y.q_no_elems()), q(_q)
X{
X  const int n = y.q_no_elems();
X  assure( n > 1, "Vector y (function values) must have at least 2 points");
X  assure( s > 0, "The grid mesh has to be positive");
X
X			// First find the index of the grid node which
X			// is closest to q. Assign index 1 to this
X			// node. Then look at neighboring grid nodes
X			// and assign indices to them
X			// (kind of breadth-first search)
X  int js = (int)( (q-x0)/s + 1.5 );	// Index j for the point x0+s*j
X					// which is the closest to q
X  if( js < 1 )				// Check for the case of extrapolation
X    js = 1;				// to the left end
X  else if( js > n )
X    js = n;				// or to the right end
X
X  register int dir;			// Direction to the next closest
X					// to q grid node
X  dir = ( q > x0 + (js-1)*s ? 1 : -1 );
X
X  register int jcurr = js, jleft = js, jright = js;
X  register int i;
X  for(i=arg.q_lwb(); i<=arg.q_upb(); ++i) // Pick up elements x0+s*i
X  {					// in the neighborhood of q
X    arg(i) = x0 + (jcurr-1)*s;
X    val(i) = y(jcurr-1+y.q_lwb());	// Once the closest to q point js
X    if( jright >= n )			// is found, we pick up points
X      dir = -1;				// alternatively to the right
X    if( jleft <= 1 )			// and to the left of the js
X      dir = 1;				// further and further
X    if( dir > 0 )
X    {
X      jcurr = ++jright;
X      dir = -1;
X    }
X    else
X    {
X      jcurr = --jleft;
X      dir = 1;
X    }
X  }
X}
X
X
Xstatic inline int fsign(const float f)		// Return the sign of f
X{ return f < 0 ? -1 : f==0 ? 0 : 1; }
X
X				// Construct the arranged tables for a
X				// non-uniform grid
XALInterp::ALInterp(const double _q, const Vector& x, const Vector& y)
X	: arg(x.q_no_elems()), val(y.q_no_elems()), q(_q)
X{
X  assure( y.q_no_elems() > 1,
X  	  "Vector y (function values) must have at least 2 points");
X  are_compatible(x,y);
X
X	                // Selection is done by sorting x,y arrays
X			// in the way mentioned above. Fisrt an array
X	                // of indices is created and sorted, then arg,
X			// val arrays are filled in using the sorted indices
X  class index_permutation
X  {
X    struct El { int x_ind; float x_to_q; };	// x_to_q = |x[x_ind]-q|
X    El * permutation;
X    const int n;
X    static int comparison_func(const void * ip, const void * jp)
X      { return fsign(((const El*)ip)->x_to_q - ((const El*)jp)->x_to_q); }
X  public:
X    index_permutation(const double q, const Vector& x) :
X	permutation(new El[x.q_no_elems()]), n(x.q_no_elems())
X    {
X      register El * pp = permutation;
X      for(register int i=x.q_lwb(); i<=x.q_upb(); i++,pp++)
X        pp->x_ind = i, pp->x_to_q = fabs(q-x(i));
X    				// Sort indices so that
X				// |q-x[x_ind[i]]| < |q-x[x_ind[j]]|
X				// for all i<j
X      qsort(permutation,n,sizeof(permutation[0]),comparison_func);
X    }
X    ~index_permutation(void) { delete permutation; }
X    				// Apply the permutation to x to get arg
X    				// and to y to get val
X    void apply(Vector& arg, Vector& val, const Vector& x, const Vector& y)
X    {
X      register const El* pp = permutation;
X      for(register int i=arg.q_lwb(); i<=arg.q_upb(); i++,pp++)
X        arg(i) = x(pp->x_ind), val(i) = y(pp->x_ind);
X      assert(pp==permutation+n);
X    }
X  };
X  
X  index_permutation(q,x).apply(arg,val,x,y);
X }
X
X/*
X *------------------------------------------------------------------------
X *			Aitken - Lagrange process
X *
X *  arg and val tables are assumed to be arranged in the proper way
X *
X */
X
Xdouble ALInterp::interpolate()
X{
X  register double valp = val(1);	// The best approximation found so far
X  register double diffp = DBL_MAX;	// abs(valp - prev. to valp)
X  register int i,j;
X
X#ifdef DEBUG
X  arg.print("arg - interpolation nodes");
X  val.print("Arranged table of function values");
X#endif
X			// Compute the j-th row of the Aitken scheme and
X			// place it in the 'val' array
X  for(j=2; j<=val.q_upb(); j++)
X  {
X    register double argj = arg(j);
X    register REAL&  valj = val(j);
X    for(i=1; i<=j-1; i++)
X      valj = ( val(i)*(q-argj) - valj*(q-arg(i)) ) / (arg(i) - argj);
X
X#ifdef DEBUG
X    message("\nval(j) = %g, valp = %g, arg(j) = %g",valj,valp,argj);
X#endif
X
X    register double diff = fabs( valj - valp );
X
X    if( j>2 && diff == 0 )  		// An exact result has been achieved
X      break;
X
X    if( j>4 && diff > diffp )		// Difference stoped diminishing
X      break;				// after the 4. step
X
X    valp = valj;  diffp = diff;
X  }
X
X  return valp;
X}
X
X
X
X/* 
X *=======================================================================
X *				Root modules
X */
X
X				// Uniform mesh x[i] = x0 + s*(i-y.lwb)
Xdouble ali(const double q, const double x0, const double s, const Vector& y)
X{
X  ALInterp al(q,x0,s,y);
X  return al.interpolate();
X}
X
X				// Nonuniform grid with nodes in x[i]
Xdouble ali(const double q, const Vector& x, const Vector& y)
X{
X  ALInterp al(q,x,y);
X  return al.interpolate();
X}
________This_Is_The_END________
if test `wc -l < ali.cc` -ne 264; then
echo 'shar: ali.cc was damaged during transit (should have had 264 lines)'
fi


echo 'x - determinant.cc'
sed 's/^X//' << '________This_Is_The_END________' > determinant.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *			Linear Algebra Package
X *
X *	    Compute the determinant of a general square matrix
X *
X * Synopsis
X *	Matrix A;
X *	double A.determinant();
X * The matrix is assumed to be square. It is not altered.
X *
X * Method
X *	Gauss-Jordan transformations of the matrix
X *	Matrix elements are arranged in columns. But it doesn't really
X *	matter since the determinant remains invariant under the
X *	matrix transposition. Therefore, it makes sence to eliminate rows
X *	rather than columnss in the Gauss-Jordan transformations.
X *	The matrix is copied to a special object of type MatrixPivoting,
X *	where all Gauss-Jordan eliminations with full pivoting are to
X *	take place.
X *
X * $Id: determinant.cc,v 2.0 1994/03/25 15:02:29 oleg Exp $
X *
X ************************************************************************
X */
X
X#include "LinAlg.h"
X#include <math.h>
X
X/*
X *------------------------------------------------------------------------
X *			Class MatrixPivoting
X *
X * It is a descendant of a Matrix which keeps some information
X * that makes pivoting easy. 
X */
X
Xclass MatrixPivoting
X  : public Matrix
X{
X  int * row_pivoted;			// row_pivoted[i] = 1 if the i-th
X					// row has been pivoted. Note,
X					// pivoted columns are marked
X					// by putting index[j] to zero.
X
X				// Information about the pivot that was
X				// just picked up
X  double pivot_value;			// Value of the pivoting element
X  int pivot_row;			// Row and column for the pivot
X  int pivot_col;			// just found
X  int pivot_parity;			// +1/-1, reflects the parity
X
X  void pick_up_pivot(void);		// Pick up a pivot from the
X					// not-pivoted rows and cols
X
Xpublic:
X  MatrixPivoting(const Matrix& m);	// Construct an object 
X					// for a given matrix
X  ~MatrixPivoting(void);
X
X  double pivoting_and_elimination(void);// Perform the pivoting, return
X					// the pivot value times (-1)^(pi+pj)
X					// (pi,pj - pivot el row & col)
X};
X
X
X/*
X *------------------------------------------------------------------------
X *		Constructing and decomissioning MatrixPivoting
X */
X
XMatrixPivoting::MatrixPivoting(const Matrix& m)
X  : Matrix(m.q_row_lwb(),m.q_row_upb(),m.q_col_lwb(),m.q_col_upb())
X{
X  m.is_valid();
X  memcpy(elements,m.elements,nelems*sizeof(REAL));
X  assert( (row_pivoted = (int *)calloc(nrows,sizeof(row_pivoted[0]))) != 0 );
X}
X
XMatrixPivoting::~MatrixPivoting(void)
X{
X  is_valid();
X  assert( row_pivoted != 0 );
X  free(row_pivoted);
X}
X
X/*
X *------------------------------------------------------------------------
X *				Pivoting itself
X */
X
X			// Pick up a pivot, the element with the largest
X			// abs value from the yet not-pivoted rows and cols
Xvoid MatrixPivoting::pick_up_pivot(void)
X{
X  register int i,j;
X  register int si,sj;			// No. of already pivoted rows & cols
X  register REAL max_elem = -1;		// Abs value of the largest element
X  register REAL * mp;
X
X  for(j=0,sj=0; j<ncols; j++)		// Picking up a not-pivoted column
X    if(index[j] == 0)
X      sj++;				// Skip already pivoted columns
X    else
X      for(i=0,si=0,mp=index[j]; i<nrows; i++)
X	if(row_pivoted[i])
X	  mp++, si++;			// Skip elems in already pivoted rows
X	else
X	{
X	  register REAL v = *mp++;
X	  if( fabs(v) > max_elem )
X	  {
X	    max_elem = fabs(v);
X	    pivot_value = v;
X	    pivot_col = j;
X	    pivot_row = i;
X	    pivot_parity = i+j-si-sj;	// No. of transpositions for the pivot
X	  }
X	}
X
X  assure( max_elem >= 0, 
X	 "All the rows and columns have been already pivoted and eliminated");
X  pivot_parity = (pivot_parity & 1 ? -1 : 1);	// (-1)^pivot_parity
X}
X
X			// Perform pivoting and gaussian elemination,
X			// return the pivot value times pivot_parity
X			// The procedure places zeros to the pivot_row of
X			// all not yet pivoted columns
X			// A[i,j] -= A[i,pivot_col]/pivot*A[pivot_row,j]
Xdouble MatrixPivoting::pivoting_and_elimination(void)
X{
X  is_valid();
X
X  pick_up_pivot();
X  if( pivot_value == 0 )
X    return 0;
X
X  REAL * pvc = index[pivot_col];		// Pivoted column ptr
X  assert( pvc != 0 );
X  register REAL * wp;				// Work pointer
X  register int i,j;
X
X  index[pivot_col] = 0;			// Mark pivot_row & pivot_col
X  row_pivoted[pivot_row] = 1;		// as being pivoted
X
X  for(i=0,wp=pvc; i<nrows; i++)		// Divide the pivoted column by pivot
X    if(row_pivoted[i])
X      wp++;				// Skip already pivoted rows
X    else
X      *wp++ /= pivot_value;
X
X  for(j=0; j<ncols; j++)		// Eliminate all the elements from
X    if(index[j] != 0)			// the pivot_row in all not pivoted
X    {					// columns
X      register REAL * mp = index[j];	// mp = A[i,j]
X      wp = pvc;				// wp = A[i,pivot_col]/pivot_value
X      register double fac = mp[pivot_row]; // fac = A[pivot_row,j]
X      for(i=0; i<nrows; i++)
X	if(row_pivoted[i])
X	  mp++,wp++;			// Skip pivoted rows
X        else
X	  *mp++ -= *wp++ * fac;
X    }
X
X  return pivot_value * pivot_parity;
X}
X
X
X/*
X *------------------------------------------------------------------------
X *				Root module
X */
X
Xdouble Matrix::determinant(void) const
X{
X  is_valid();
X
X  if( nrows != ncols )
X    info(), _error("Can't obtain the determinant of a non_square matrix");
X
X  if( row_lwb != col_lwb )
X    info(), _error("Row and col lower bounds are inconsistent");
X
X  MatrixPivoting mp(*this);
X
X  register double det = 1;
X  register int k;
X
X  for(k=0; k<ncols && det != 0; k++)
X    det *= mp.pivoting_and_elimination();
X
X  return det;
X}
________This_Is_The_END________
if test `wc -l < determinant.cc` -ne 196; then
echo 'shar: determinant.cc was damaged during transit (should have had 196 lines)'
fi


echo 'x - fminbr.cc'
sed 's/^X//' << '________This_Is_The_END________' > fminbr.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *			  Numerical Math Package
X *
X *		    Brent's one-dimensional minimizer 
X *
X *	     finds a local minimum of a single argument function
X *			  over the given range
X *
X * Input
X *	double fminbr(ax,bx,f,tol)
X *	const double ax		        a and b, a < b, specify the interval
X *	const double bx  		the minimum is to be sought in
X *	double (*f)(const double x)	Ptr to the function under investigation
X *	const double tol		Acceptable tolerance for the minimum
X *					location. It is an optional parameter
X *					with default value EPSILON
X *
X * Output
X *	Fminbr returns an estimate to the minimum location with accuracy
X *	3*SQRT_EPSILON*abs(x) + tol.
X *	The procedure always determines a local minimum, which coincides with
X *	the global one if and only if the function under investigation is
X *	unimodular.
X *	If a function being examined possesses no local minimum within
X *	the given range, Fminbr returns either the left or the right end
X *	point of the interval, wherever the function value is smaller.
X *
X * Algorithm
X *	G.Forsythe, M.Malcolm, C.Moler, Computer methods for mathematical
X *	computations. M., Mir, 1980, p.202 of the Russian edition
X *
X * The function makes use of the "gold section" procedure combined with
X * the parabolic interpolation.
X * At every step program operates three abscissae - x,v, and w.
X * 	x - the last and the best approximation to the minimum location,
X *		i.e. f(x) <= f(a) or/and f(x) <= f(b)
X * 	    (if the function f has a local minimum in (a,b), then both
X *  	     conditions are met after one or two steps).
X *	v,w are previous approximations to the minimum location. They may
X *	coincide with a, b, or x (although the algorithm tries to make all
X *	u, v, and w distinct). 
X * Points x, v, and w are used to construct an interpolating parabola,
X * whose minimum is to be regarded as a new approximation to the minimum
X * location if the former falls within [a,b] and reduces the minimum 
X * encompassing interval to a larger extent than the gold section procedure.
X * When f(x) has a second derivative positive at the point of minimum
X * (not coinciding with a or b) the procedure converges superlinearly
X * at a rate of about 1.324
X *
X ************************************************************************
X */
X
X#include "math_num.h"
X
X
Xdouble fminbr(				// An estimate to the min location
X	const double ax,		// Specify the interval the minimum
X	const double bx,		// to be sought in
X	double (*f)(const double x),	// Function under investigation
X	const double tol)		// Acceptable tolerance
X{
X  double a = ax, b = bx;		// Current interval
X  double x,v,w;				// Abscissae, descr. see above
X  double fx;				// f(x)
X  double fv;				// f(v)
X  double fw;				// f(w)
X  const double r = (3-sqrt(5.0))/2;	// Golden section ratio
X
X  assure( tol > 0, "Tolerance must be positive");
X  assure( b > a, 
X	 "Left end point of the interval should be strictly less than the "
X	 "right one" );
X
X  v = a + r*(b-a);  fv = (*f)(v);       // First step - always gold section
X  x = v;  w = v;
X  fx=fv;  fw=fv;
X
X  for(;;)		// Main iteration loop
X  {
X    const double range = b-a;		// Interval over which the minimum
X					// is sought for
X    const double midpoint = (a+b)/2;
X    const double tol_act =		// Actual tolerance
X		SQRT_EPSILON*fabs(x) + tol/3;
X
X       
X
X    if( fabs(x-midpoint) + range/2 <= 2*tol_act )
X      return x;				// Acceptable approximation is found
X
X					// Compute a new step with the gold
X					// section
X    double new_step = r * ( x < midpoint ? b-x : a-x );
X
X
X    			// Decide on the interpolation  
X    if( fabs(x-w) >= tol_act  )		// If x and w are distinct
X    {					// interpolatiom may be tried
X      register double p; 		// Interpolation step is calcula-
X      register double q;              	// ted as p/q; division operation
X                                        // is delayed until last moment
X      register double t;
X
X      t = (x-w) * (fx-fv);
X      q = (x-v) * (fx-fw);
X      p = (x-v)*q - (x-w)*t;
X      q = 2*(q-t);
X
X      if( q > 0 )			// Formulas above computed new_step
X	p = -p;				// = p/q with wrong sign (on purpose).
X      else				// Correct this, but in such a way so
X	q = -q;				// that q would be positive
X
X      if( fabs(p) < fabs(new_step*q) &&	// If x+p/q falls in [a,b] and is not
X	 p > q*(a-x+2*tol_act) &&	// too close to a and b, and isn't
X	 p < q*(b-x-2*tol_act)  )       // too large, it is accepted
X	   new_step = p/q;
X					// If p/q is too large then the
X					// gold section procedure would
X					// reduce [a,b] to larger extent
X    }
X
X    if( fabs(new_step) < tol_act )	// Adjust the step to be not less
X      if( new_step > 0 )		// than tolerance
X	new_step = tol_act;
X      else
X	new_step = -tol_act;
X
X				// Obtain the next approximation to min
X    				// and reduce the encompassing interval
X    register double t = x + new_step;	// Tentative point for the min
X    register double ft = (*f)(t);
X    if( ft <= fx )
X    {                                 	// t is a better approximation
X      if( t < x )			// Reduce the interval so that
X	b = x;                        	// t would fall within it
X      else
X	a = x;
X      
X      v = w;  w = x;  x = t;		// Assign the best approx to x
X      fv=fw;  fw=fx;  fx=ft;
X    }
X    else                              	// x remains the better approx
X    {
X      if( t < x )			// Reduce the interval encompassing x
X	a = t;                   
X      else
X	b = t;
X      
X      if( ft <= fw || w==x )
X      {
X	v = w;  w = t;
X	fv=fw;  fw=ft;
X      }
X      else if( ft<=fv || v==x || v==w )
X	v = t, fv = ft;
X    }
X  }		// ===== End of loop =====
X
X}
________This_Is_The_END________
if test `wc -l < fminbr.cc` -ne 163; then
echo 'shar: fminbr.cc was damaged during transit (should have had 163 lines)'
fi


echo 'x - hjmin.cc'
sed 's/^X//' << '________This_Is_The_END________' > hjmin.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *			  Numerical Math Package
X *		Hook-Jeevse multidimensional minimization
X *
X * Synopsis
X *	double hjmin(b,h,funct)
X *	Vector& b 			should be specified to contain the
X *					initial guess to the point of minimum.
X *					On return, it contains the location
X *					of the minimum the function has found
X *	Vector& h			Initial values for steps along
X *					each direction
X *					On exit contains the final steps
X *					before the termination
X *	double f(const Vector& x)	Procedure to compute a function
X *					value at the specified point
X *
X * The function returns the value of the minimizing function f() at the
X * point of the found minimum.
X *
X * An alternative double hjmin(b,h0,funct) where h0 is a double const
X * uses the same initial steps along each direction. No final steps are
X * reported, though.
X *
X * Algorithm
X *	Hook-Jeevse method of direct search for a function minimum
X *	The method is of the 0. order (i.e. requiring no gradient computation)
X *	See
X *	B.Bondi. Methods of optimization. An Introduction - M.,
X *	"Radio i sviaz", 1988 - 127 p. (in Russian)
X *
X * $Id$
X *
X ************************************************************************
X */
X
X
X#include "LinAlg.h"
X#include "math_num.h"
X#include "std.h"
X
X/*
X *------------------------------------------------------------------------
X *		Class to operate on the points in the space (x,f(x))
X */
X
Xclass FPoint
X{
X  Vector& x;				// Point in the function domain
X  double fval;				// Function value at the point
X  double (*fproc)(const Vector& x);	// Procedure to compute the function
X					// value
X  const bool free_x_on_destructing;	// The flag is needed to free the 
X					// dynamic memory allocated when
X					// x rather than reference to x has
X					// been given to construct FPoint
X
Xpublic:
X  FPoint(Vector& b, double (*f)(const Vector& x));
X  FPoint(const FPoint& fp);
X  ~FPoint();
X
X  FPoint& operator = (const FPoint& fp);
X
X  double f() const			{ return fval; }
X
X  double fiddle_around(const Vector& h);// Examine the function in the
X					// neighborhood of the current point.
X					// h defines the radius of the region
X
X					// Proceed in direction the function
X					// seems decline
X  friend void update_in_direction(FPoint& from, FPoint& to);
X
X					// Decide whether the region embracing
X					// the local min is small enough
X  bool is_step_relatively_small(const Vector& h, const double tau);
X};
X
X				// Constructor FPoint from array b
Xinline FPoint::FPoint(Vector& b, double (*f)(const Vector& x))
X	: x(b), fproc(f), free_x_on_destructing(false)
X{
X  fval = (*fproc)(x);
X}
X
X				// Constructor by example
XFPoint::FPoint(const FPoint& fp)
X	: x(*(new Vector(fp.x))), free_x_on_destructing(true)
X{
X  x = fp.x;
X  fval = fp.fval;
X  fproc = fp.fproc;
X}
X				// Destructor
XFPoint::~FPoint()
X{
X  if( free_x_on_destructing )
X    delete &x;
X}
X
X				// Assignment; fproc is assumed the same and
X				// is not copied
Xinline FPoint& FPoint::operator = (const FPoint& fp)
X{
X  x = fp.x;
X  fval = fp.fval;
X  return *this;
X}
X
X/*
X * Examine the function f in the vicinity of the current point
X * by making tentative steps fro/back along each coordinate.
X * Should function decrease, the point is updated to locate the
X * new local min.
X * Examination() returns the minimal function value found in
X * the region.
X *
X */
Xdouble FPoint::fiddle_around(const Vector& h)
X{
X			// Perform a step along a coordinate
X  for(register int i=x.q_lwb(); i<=x.q_upb(); i++)
X  {
X    const double hi = h(i);
X    register double xi_old = x(i);  	// Old value of x[i]
X    register double fnew;
X
X    if( x(i) = xi_old + hi, fnew = (*fproc)(x), fnew < fval )
X      fval = fnew;			// Step caused f to decrease, OK
X    else if( x(i) = xi_old - hi, fnew = (*fproc)(x), fnew < fval )
X      fval = fnew;
X    else				// No function decline has been
X      x(i) = xi_old;                	// found along this coord, back up
X  }
X  return fval;
X}                                                
X
X				// Proceed in the direction the function
X				// seems to fall
X				// to_new = (to - from) + to
X				// from = to (before modification)
Xvoid update_in_direction(FPoint& from, FPoint& to)
X{
X  register int i;
X  for(i=(from.x).q_lwb(); i<=(from.x).q_upb(); i++)
X  {
X    register double t = (to.x)(i);
X    (to.x)(i)  += (t - (from.x)(i));
X    (from.x)(i) = t;
X  }
X  from.fval = to.fval;
X  to.fval = (*(to.fproc))(to.x);
X}
X
X				// Estimate if the point of minimum has
X				// been located accurately enough
Xbool FPoint::is_step_relatively_small(const Vector& h, const double tau)
X{
X  register bool it_is_small = true;
X  register int i;
X  for(i=h.q_lwb(); it_is_small && i<=h.q_upb(); i++)
X    it_is_small &= ( h(i) /(1 + fabs(x(i))) < tau );
X  return it_is_small;
X}
X
X/*
X *------------------------------------------------------------------------
X *			    Root module
X */
X
Xdouble hjmin(Vector& b, Vector& h, double (*ff)(const Vector& x))
X{
X				// Function Parameters
X  const double tau = 10*EPSILON;        // Termination criterion
X  const double threshold = 1e-8;        // Threshold for the function
X                                        // decay to be treated as
X                                        // significant
X  const double step_reduce_factor = 10;   
X
X  are_compatible(b,h);
X
X  FPoint pmin(b,ff);			// Point of min
X  FPoint pbase(pmin);			// Base point
X
X  for(;;)			// Main iteration loop
X  {                     	// pmin is the approximation to min so far
X    if( pbase.fiddle_around(h) < pmin.f() - threshold )
X    {   			      	// Function value dropped significantly
X      do                              	// from pmin to the point pbase
X	update_in_direction(pmin,pbase);// Keep going in the same direction
X      while( pbase.fiddle_around(h) < pmin.f() - threshold ); // while it works
X      pbase = pmin;			// Save the best approx found
X    }
X    else                               	// Function didn't fall significantly
X      if(                               // upon wandering around pbas
X	 h *= 1/step_reduce_factor,	// Try to reduce the step then
X	 pbase.is_step_relatively_small(h,tau) )
X	return pmin.f();
X  }
X}
X
X	    		// The same as above with the only difference
X	    		// initial steps are given to be the same
X	    		// along every direction. The final steps
X	    		// aren't reported back though
Xdouble hjmin(Vector& b,	const double h0, double (*f)(const Vector& x))
X{
X  Vector h(b.q_lwb(),b.q_upb()); h = h0;
X  return hjmin(b,h,f);
X}
________This_Is_The_END________
if test `wc -l < hjmin.cc` -ne 214; then
echo 'shar: hjmin.cc was damaged during transit (should have had 214 lines)'
fi


echo 'x - matrix1.cc'
sed 's/^X//' << '________This_Is_The_END________' > matrix1.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *			Linear Algebra Package
X *
X *		Basic linear algebra operations, level 1
X *		      Element-wise operations
X *
X * $Id: matrix1.cc,v 3.0 1995/01/07 19:06:12 oleg Exp $
X *
X ************************************************************************
X */
X
X#pragma implementation "LinAlg.h"
X
X#include "LinAlg.h"
X#include <math.h>
X
X
X/*
X *------------------------------------------------------------------------
X *			Constructors and destructors
X */
X
Xvoid Matrix::allocate(
X	const int no_rows,		// No. of rows
X	const int no_cols,		// No. of cols
X	const int row_lwb,		// Row index lower bound
X	const int col_lwb		// Col index lower bound
X)
X{
X  valid_code = MATRIX_val_code;
X
X  assure((nrows=no_rows) > 0, "No. of matrix cols has got to be positive");
X  assure((ncols=no_cols) > 0, "No. of matrix rows has got to be positive");
X
X  Matrix::row_lwb = row_lwb;
X  Matrix::col_lwb = col_lwb;
X
X  name = "";
X
X  nelems = nrows * ncols;
X
X  assert( (elements = (REAL *)calloc(nelems,sizeof(REAL))) != 0 );
X
X  if( ncols == 1 )		// Only one col - index is dummy actually
X  {
X    index = &elements;
X    return;
X  }
X  
X  assert( (index  = (REAL **)calloc(ncols,sizeof(REAL *))) != 0 );
X  register int i;
X  register REAL * col_p;
X  for(i=0,col_p=&elements[0]; i<ncols; i++,col_p += nrows)
X    index[i] = col_p;
X}
X
X
XMatrix::~Matrix(void)		// Dispose the Matrix struct
X{
X  is_valid();
X  if( ncols != 1 )
X    free(index);
X  free(elements);
X  if( name[0] != '\0' )
X    delete name;
X  valid_code = 0;
X}
X
X				// Set a new Matrix name
Xvoid Matrix::set_name(const char * new_name)
X{
X  if( name != 0 && name[0] != '\0' )	// Dispose of the previous matrix name
X    delete name;
X
X  if( new_name == 0 || new_name[0] == '\0' )
X    name = "";				// Matrix is anonymous now
X  else
X    name = new char[strlen(new_name)+1], strcpy(name,new_name);
X}
X
X				// Erase the old matrix and create a
X				// new one according to new boundaries
X				// with indexation starting at 1
Xvoid Matrix::resize_to(const int nrows, const int ncols)
X{
X  is_valid();
X  if( nrows == Matrix::nrows && ncols == Matrix::ncols )
X    return;
X
X  if( ncols != 1 )
X    free(index);
X  free(elements);
X
X  char * old_name = name;
X  allocate(nrows,ncols);
X  name = old_name;
X}
X				// Erase the old matrix and create a
X				// new one according to new boundaries
Xvoid Matrix::resize_to(const int row_lwb, const int row_upb,
X		       const int col_lwb, const int col_upb)
X{
X  is_valid();
X  const int new_nrows = row_upb-row_lwb+1;
X  const int new_ncols = col_upb-col_lwb+1;
X  Matrix::row_lwb = row_lwb;
X  Matrix::col_lwb = col_lwb;
X  if( new_nrows == Matrix::nrows && new_ncols == Matrix::ncols )
X    return;
X
X  if( ncols != 1 )
X    free(index);
X  free(elements);
X
X  char * old_name = name;
X  allocate(new_nrows,new_ncols,row_lwb,col_lwb);
X  name = old_name;
X}
X
X					// Routing constructor module
XMatrix::Matrix(const MATRIX_CREATORS_1op op, const Matrix& prototype)
X{
X  prototype.is_valid();
X  switch(op)
X  {
X    case Zero:
X         allocate(prototype.nrows,prototype.ncols,
X		  prototype.row_lwb,prototype.col_lwb);
X	 break;
X
X    case Unit:
X         allocate(prototype.nrows,prototype.ncols,
X		  prototype.row_lwb,prototype.col_lwb);
X	 unit_matrix();
X	 break;
X
X    case Transposed:
X	 _transpose(prototype);
X	 break;
X
X    case Inverted:
X	 _invert(prototype);
X	 break;
X
X    default:
X	 _error("Operation %d is not yet implemented",op);
X  }
X}
X
X					// Routing constructor module
XMatrix::Matrix(const Matrix& A, const MATRIX_CREATORS_2op op, const Matrix& B)
X{
X  A.is_valid();
X  B.is_valid();
X  switch(op)
X  {
X    case Mult:
X         _AmultB(A,B);
X	 break;
X
X    case TransposeMult:
X	 _AtmultB(A,B);
X	 break;
X
X    default:
X	 _error("Operation %d is not yet implemented",op);
X  }
X}
X
X/*
X *------------------------------------------------------------------------
X * 		    Making a matrix of a special kind	
X */
X
X				// Make a unit matrix
X				// (Matrix needn't be a square one)
X				// The matrix is traversed in the
X				// natural (that is, col by col) order
XMatrix& Matrix::unit_matrix(void)
X{
X  is_valid();
X  register REAL *ep = elements;
X  register int i,j;
X
X  for(j=0; j < ncols; j++)
X    for(i=0; i < nrows; i++)
X        *ep++ = ( i==j ? 1.0 : 0.0 );
X
X  return *this;
X}
X
X				// Make a Hilbert matrix
X				// Hilb[i,j] = 1/(i+j-1), i,j=1...max, OR
X				// Hilb[i,j] = 1/(i+j+1), i,j=0...max-1
X				// (Matrix needn't be a square one)
X				// The matrix is traversed in the
X				// natural (that is, col by col) order
XMatrix& Matrix::hilbert_matrix(void)
X{
X  is_valid();
X  register REAL *ep = elements;
X  register int i,j;
X
X  for(j=0; j < ncols; j++)
X    for(i=0; i < nrows; i++)
X        *ep++ = 1./(i+j+1);
X
X  return *this;
X}
X
X			// Create an orthonormal (2^n)*(no_cols) Haar
X			// (sub)matrix, whose columns are Haar functions
X			// If no_cols is 0, create the complete matrix
X			// with 2^n columns
X			// E.g., the complete Haar matrix of the second order
X			// is
X			// column 1: [ 1  1  1  1]/2
X			// column 2: [ 1  1 -1 -1]/2
X			// column 3: [ 1 -1  0  0]/sqrt(2)
X			// column 4: [ 0  0  1 -1]/sqrt(2)
X			// Matrix m is assumed to be zero originally
Xvoid _make_haar_matrix(Matrix& m)
X{
X  m.is_valid();
X  assert( m.ncols <= m.nrows && m.ncols > 0 );
X  register REAL * cp = m.elements;
X     const REAL * m_end = m.elements + m.nelems;
X  register int i;
X
X  double norm_factor = 1/sqrt((double)m.nrows);
X
X  for(i=0; i<m.nrows; i++)	// First column is always 1 (up to normali- 
X    *cp++ = norm_factor;	// zation)
X
X				// The other functions are kind of steps:
X				// stretch of 1 followed by the equally
X				// long stretch of -1
X				// The functions can be grouped in families
X				// according to their order (step size),
X				// differing only in the location of the step
X  int step_length = m.nrows/2;
X  while( cp < m_end && step_length > 0 )
X  {
X    for(register int step_position=0; cp < m_end && step_position < m.nrows;
X	step_position += 2*step_length, cp += m.nrows)
X    {
X      register REAL * ccp = cp + step_position;
X      for(i=0; i<step_length; i++)
X	*ccp++ = norm_factor;
X      for(i=0; i<step_length; i++)
X	*ccp++ = -norm_factor;
X    }
X    step_length /= 2;
X    norm_factor *= sqrt(2.0);
X  }
X  assert( step_length != 0 || cp == m_end );
X  assert( m.nrows != m.ncols || step_length == 0 );
X}
X
Xhaar_matrix::haar_matrix(const int order, const int no_cols)
X    : LazyMatrix(1<<order,no_cols == 0 ? 1<<order : no_cols)
X{
X  assert(order > 0 && no_cols >= 0);
X}
X
X/*
X *------------------------------------------------------------------------
X * 			Matrix-scalar arithmetics
X * 	     Modify every element according to the operation
X */
X
X				// For every element, do `elem OP value`
X#define COMPUTED_VAL_ASSIGNMENT(OP,VALTYPE)				\
X									\
XMatrix& Matrix::operator OP (const VALTYPE val)				\
X{									\
X  is_valid();								\
X  register REAL * ep = elements;					\
X  while( ep < elements+nelems )						\
X    *ep++ OP val;							\
X									\
X  return *this;								\
X}									\
X
XCOMPUTED_VAL_ASSIGNMENT(=,REAL)
XCOMPUTED_VAL_ASSIGNMENT(+=,double)
XCOMPUTED_VAL_ASSIGNMENT(-=,double)
XCOMPUTED_VAL_ASSIGNMENT(*=,double)
X
X#undef COMPUTED_VAL_ASSIGNMENT
X
X
X				// is "element OP val" true for all
X				// matrix elements?
X
X#define COMPARISON_WITH_SCALAR(OP)					\
X									\
Xbool Matrix::operator OP (const REAL val) const				\
X{									\
X  is_valid();								\
X  register REAL * ep = elements;					\
X  while( ep < elements + nelems )					\
X    if( !(*ep++ OP val) )						\
X      return false;							\
X									\
X  return true;								\
X}									\
X
X
XCOMPARISON_WITH_SCALAR(==)
XCOMPARISON_WITH_SCALAR(!=)
XCOMPARISON_WITH_SCALAR(<)
XCOMPARISON_WITH_SCALAR(<=)
XCOMPARISON_WITH_SCALAR(>)
XCOMPARISON_WITH_SCALAR(>=)
X
X#undef COMPARISON_WITH_SCALAR
X
X/*
X *------------------------------------------------------------------------
X *		Apply algebraic functions to all the matrix elements
X */
X
X				// Take an absolute value of a matrix
XMatrix& Matrix::abs(void)
X{
X  is_valid();
X  register REAL * ep;
X  for(ep=elements; ep < elements+nelems; ep++)
X    *ep = ::abs(*ep);
X
X  return *this;
X}
X
X				// Square each element
XMatrix& Matrix::sqr(void)
X{
X  is_valid();
X  register REAL * ep;
X  for(ep=elements; ep < elements+nelems; ep++)
X    *ep = *ep * *ep;
X
X  return *this;
X}
X
X				// Take a square root of all the elements
XMatrix& Matrix::sqrt(void)
X{
X  is_valid();
X  register REAL * ep;
X  for(ep=elements; ep < elements+nelems; ep++)
X    if( *ep >= 0 )
X      *ep = ::sqrt(*ep);
X    else
X      info(),
X      _error("(%d,%d)-th element, %g, is negative. Can't take the square root",
X	     (ep-elements) % nrows + row_lwb,
X	     (ep-elements) / nrows + col_lwb, *ep );
X
X  return *this;
X}
X
X				// Apply a user-defined action to each matrix
X				// element. The matrix is traversed in the
X				// natural (that is, col by col) order
XMatrix& Matrix::apply(ElementAction& action)
X{
X  is_valid();
X  register REAL * ep = elements;
X  for(action.j=col_lwb; action.j<col_lwb+ncols; action.j++)
X    for(action.i=row_lwb; action.i<row_lwb+nrows; action.i++)
X      action.operation(*ep++);
X  assert( ep == elements+nelems );
X
X  return *this;
X}
X
X/*
X *------------------------------------------------------------------------
X * 		   Matrix-Matrix element-wise operations
X */
X
X				// Check to see if two matrices are identical
Xbool operator == (const Matrix& im1, const Matrix& im2)
X{
X  are_compatible(im1,im2);
X  return (memcmp(im1.elements,im2.elements,im1.nelems*sizeof(REAL)) == 0);
X}
X
X				// Add the source to the target
XMatrix& operator += (Matrix& target, const Matrix& source)
X{
X  are_compatible(target,source);
X
X  register REAL * sp = source.elements;
X  register REAL * tp = target.elements;
X  for(; tp < target.elements+target.nelems;)
X    *tp++ += *sp++;
X  
X  return target;
X}
X  
X				// Subtract the source from the target
XMatrix& operator -= (Matrix& target, const Matrix& source)
X{
X  are_compatible(target,source);
X  register REAL * sp = source.elements;
X  register REAL * tp = target.elements;
X  for(; tp < target.elements+target.nelems;)
X    *tp++ -= *sp++;
X  
X  return target;
X}
X
X				// Modified addition
X				//	Target += scalar*Source
XMatrix& add(Matrix& target, const double scalar,const Matrix& source)
X{
X  are_compatible(target,source);
X
X  register REAL * sp = source.elements;
X  register REAL * tp = target.elements;
X  for(; tp < target.elements+target.nelems;)
X    *tp++ += scalar * *sp++;
X  
X  return target;
X}
X
X				// Multiply target by the source
X				// element-by-element
XMatrix& element_mult(Matrix& target, const Matrix& source)
X{
X  are_compatible(target,source);
X  register REAL * sp = source.elements;
X  register REAL * tp = target.elements;
X  for(; tp < target.elements+target.nelems;)
X    *tp++ *= *sp++;
X  
X  return target;
X}
X
X				// Divide target by the source
X				// element-by-element
XMatrix& element_div(Matrix& target, const Matrix& source)
X{
X  are_compatible(target,source);
X  register REAL * sp = source.elements;
X  register REAL * tp = target.elements;
X  for(; tp < target.elements+target.nelems;)
X    *tp++ /= *sp++;
X  
X  return target;
X}
X
X/*
X *------------------------------------------------------------------------
X *			Compute matrix norms
X */
X
X				// Row matrix norm
X				// MAX{ SUM{ |M(i,j)|, over j}, over i}
X				// The norm is induced by the infinity
X				// vector norm
Xdouble Matrix::row_norm(void) const
X{
X  is_valid();
X  register REAL * ep = elements;
X  register double norm = 0;
X
X  while(ep < elements+nrows)		// Scan the matrix row-after-row
X  {
X    register int j;
X    register double sum = 0;
X    for(j=0; j<ncols; j++,ep+=nrows)	// Scan a row to compute the sum
X      sum += ::abs(*ep);
X    ep -= nelems - 1;			// Point ep to the beg of the next row
X    norm = ::max(norm,sum);
X  }
X  assert( ep == elements + nrows );
X
X  return norm;
X}
X
X				// Column matrix norm
X				// MAX{ SUM{ |M(i,j)|, over i}, over j}
X				// The norm is induced by the 1.
X				// vector norm
Xdouble Matrix::col_norm(void) const
X{
X  is_valid();
X  register REAL * ep = elements;
X  register double norm = 0;
X
X  while(ep < elements+nelems)		// Scan the matrix col-after-col
X  {					// (i.e. in the natural order of elems)
X    register int i;
X    register double sum = 0;
X    for(i=0; i<nrows; i++)		// Scan a col to compute the sum
X      sum += ::abs(*ep++);
X    norm = ::max(norm,sum);
X  }
X  assert( ep == elements + nelems );
X
X  return norm;
X}
X
X
X				// Square of the Euclidian norm
X				// SUM{ m(i,j)^2 }
Xdouble Matrix::e2_norm(void) const
X{
X  is_valid();
X  register REAL * ep;
X  register double sum = 0;
X  for(ep=elements; ep < elements+nelems;)
X    sum += ::sqr(*ep++);
X
X  return sum;
X}
X
X				// Square of the Euclidian norm of the
X				// difference between two matrices
Xdouble e2_norm(const Matrix& m1, const Matrix& m2)
X{
X  are_compatible(m1,m2);
X  register REAL * mp1 = m1.elements;
X  register REAL * mp2 = m2.elements;
X  register double sum = 0;
X  for(; mp1 < m1.elements+m1.nelems;)
X    sum += sqr(*mp1++ - *mp2++);
X
X  return sum;
X}
X
X/*
X *------------------------------------------------------------------------
X * 			Some service operations
X */
X
Xvoid Matrix::info(void) const	// Print some information about the matrix
X{
X  is_valid();
X  message("\nMatrix %d:%dx%d:%d '%s'",row_lwb,nrows+row_lwb-1,
X	  col_lwb,ncols+col_lwb-1,name);
X}
X
X				// Print the Matrix as a table of elements
X				// (zeros are printed as dots)
Xvoid Matrix::print(const char * title) const
X{
X  is_valid();
X  message("\nMatrix %dx%d '%s' is as follows",nrows,ncols,title);
X
X  const int cols_per_sheet = 6;
X  register int sheet_counter;
X  
X  for(sheet_counter=1; sheet_counter<=ncols; sheet_counter +=cols_per_sheet)
X  {
X    message("\n\n     |");
X    register int i,j;
X    for(j=sheet_counter; j<sheet_counter+cols_per_sheet && j<=ncols; j++)
X      message("   %6d  |",j+col_lwb-1);
X    message("\n%s\n",_Minuses);
X    for(i=1; i<=nrows; i++)
X    {
X      message("%4d |",i+row_lwb-1);
X      for(j=sheet_counter; j<sheet_counter+cols_per_sheet && j<=ncols; j++)
X	message("%11.4g  ",(*this)(i+row_lwb-1,j+col_lwb-1));
X      message("\n");
X    }
X  }
X  message("Done\n");
X}
X
X//#include <builtin.h>
Xvoid compare(			// Compare the two Matrixs
X	const Matrix& matrix1,	// and print out the result of comparison
X	const Matrix& matrix2,
X	const char * title )
X{
X  register int i,j;
X
X  are_compatible(matrix1,matrix2);
X
X  message("\n\nComparison of two Matrices:\n\t%s",title);
X  matrix1.info();
X  matrix2.info();
X
X  double norm1 = 0, norm2 = 0;		// Norm of the Matrixs
X  double ndiff = 0;			// Norm of the difference
X  int imax=0,jmax=0;			// For the elements that differ most
X  REAL difmax = -1;
X  register REAL *mp1 = matrix1.elements; // Matrix element pointers
X  register REAL *mp2 = matrix2.elements;
X
X  for(j=0; j < matrix1.ncols; j++)	// Due to the column-wise arrangement,
X    for(i=0; i < matrix1.nrows; i++)	// the row index changes first
X    {
X      REAL mv1 = *mp1++;
X      REAL mv2 = *mp2++;
X      REAL diff = abs(mv1-mv2);
X
X      if( diff > difmax )
X      {
X	difmax = diff;
X	imax = i;
X	jmax = j;
X      }
X      norm1 += abs(mv1);
X      norm2 += abs(mv2);
X      ndiff += abs(diff);
X    }
X
X  imax += matrix1.row_lwb, jmax += matrix1.col_lwb;
X  message("\nMaximal discrepancy    \t\t%g",difmax);
X  message("\n   occured at the point\t\t(%d,%d)",imax,jmax);
X  const REAL mv1 = matrix1(imax,jmax);
X  const REAL mv2 = matrix2(imax,jmax);
X  message("\n Matrix 1 element is    \t\t%g",mv1);
X  message("\n Matrix 2 element is    \t\t%g",mv2);
X  message("\n Absolute error v2[i]-v1[i]\t\t%g",mv2-mv1);
X  message("\n Relative error\t\t\t\t%g\n",
X	 (mv2-mv1)/max(abs(mv2+mv1)/2,1e-7) );
X
X  message("\n||Matrix 1||   \t\t\t%g",norm1);
X  message("\n||Matrix 2||   \t\t\t%g",norm2);
X  message("\n||Matrix1-Matrix2||\t\t\t\t%g",ndiff);
X  message("\n||Matrix1-Matrix2||/sqrt(||Matrix1|| ||Matrix2||)\t%g\n\n",
X	  ndiff/max( sqrt(norm1*norm2), 1e-7 )         );
X
X}
X
X/*
X *------------------------------------------------------------------------
X *			Service validation functions
X */
X
Xvoid verify_element_value(const Matrix& m,const REAL val)
X{
X  register imax = 0, jmax = 0;
X  register double max_dev = 0;
X  register int i,j;
X  for(i=m.q_row_lwb(); i<=m.q_row_upb(); i++)
X    for(j=m.q_col_lwb(); j<=m.q_col_upb(); j++)
X    {
X      register double dev = abs(m(i,j)-val);
X      if( dev >= max_dev )
X	imax = i, jmax = j, max_dev = dev;
X    }
X
X  if( max_dev == 0 )
X    return;
X  else if( max_dev < 1e-5 )
X    message("Element (%d,%d) with value %g differs the most from what\n"
X	    "was expected, %g, though the deviation %g is small\n",
X	    imax,jmax,m(imax,jmax),val,max_dev);
X  else
X    _error("A significant difference from the expected value %g\n"
X	   "encountered for element (%d,%d) with value %g",
X	   val,imax,jmax,m(imax,jmax));
X}
X
Xvoid verify_matrix_identity(const Matrix& m1, const Matrix& m2)
X{
X  register imax = 0, jmax = 0;
X  register double max_dev = 0;
X  register int i,j;
X  are_compatible(m1,m2);
X  for(i=m1.q_row_lwb(); i<=m1.q_row_upb(); i++)
X    for(j=m1.q_col_lwb(); j<=m1.q_col_upb(); j++)
X    {
X      register double dev = abs(m1(i,j)-m2(i,j));
X      if( dev >= max_dev )
X	imax = i, jmax = j, max_dev = dev;
X    }
X
X  if( max_dev == 0 )
X    return;
X  if( max_dev < 1e-5 )
X    message("Two (%d,%d) elements of matrices with values %g and %g\n"
X	    "differ the most, though the deviation %g is small\n",
X	    imax,jmax,m1(imax,jmax),m2(imax,jmax),max_dev);
X  else
X    _error("A significant difference between the matrices encountered\n"
X	   "at (%d,%d) element, with values %g and %g",
X	   imax,jmax,m1(imax,jmax),m2(imax,jmax));
X}
________This_Is_The_END________
if test `wc -l < matrix1.cc` -ne 690; then
echo 'shar: matrix1.cc was damaged during transit (should have had 690 lines)'
fi


echo 'x - matrix2.cc'
sed 's/^X//' << '________This_Is_The_END________' > matrix2.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *			Linear Algebra Package
X *
X *		Basic linear algebra operations, level 2
X *	       Matrix transformations and multiplications
X *			   of various types
X *
X * $Id: matrix2.cc,v 3.0 1995/01/01 22:29:04 oleg Exp $
X *
X ************************************************************************
X */
X
X#include "LinAlg.h"
X#include <math.h>
X#include <alloca.h>
X
X/*
X *------------------------------------------------------------------------
X *				Transpositions
X */
X				// Transpose a matrix
Xvoid Matrix::_transpose(const Matrix& prototype)
X{
X  prototype.is_valid();
X  allocate(prototype.ncols,prototype.nrows,
X	   prototype.col_lwb,prototype.row_lwb);
X
X  register REAL * rsp = prototype.elements;	// Row source pointer
X  register REAL * tp = elements;
X
X				// (This: target) matrix is traversed in the
X				// natural, column-wise way, whilst the source
X				// (prototype) matrix is scanned row-by-row
X  while( tp < elements + nelems )
X  {
X    register REAL * sp = rsp++;		// sp = @ms[j,i] for i=0
X					// Move tp to the next elem in the col,
X    while( sp < prototype.elements + prototype.nelems )
X       *tp++ = *sp, sp += prototype.nrows; // sp to the next el in the curr row
X  }
X  assert( tp == elements + nelems && 
X	  rsp == prototype.elements + prototype.nrows );
X
X}
X
X/*
X *------------------------------------------------------------------------
X *			General matrix multiplications
X */
X
X			// Compute target = target * source inplace.
X			// Strictly speaking, it can't be done inplace,
X			// though only the row of the target matrix needs
X			// to be saved.
X			// "Inplace" multiplication is only possible
X			// when the 'source' matrix is square
XMatrix& Matrix::operator *= (const Matrix& source)
X{
X  is_valid();
X  source.is_valid();
X
X  if( row_lwb != source.col_lwb || ncols != source.nrows ||
X      col_lwb != source.col_lwb || ncols != source.ncols )
X    info(), source.info(),
X    _error("matrices above are unsuitable for the inplace multiplication");
X
X  					// One row of the old_target matrix
X  REAL * const one_row = (REAL *)alloca(ncols*sizeof(REAL));
X  const REAL * one_row_end = &one_row[ncols];
X
X  register REAL * trp = elements;	// Pointer to the i-th row
X  for(; trp < &elements[nrows]; trp++)	// Go row-by-row in the target
X  {
X    register REAL *wrp, *orp;		   	// work row pointers
X    for(wrp=trp,orp=one_row; orp < one_row_end;)
X      *orp++ = *wrp, wrp += nrows;		// Copy a row of old_target
X
X    register REAL *scp=source.elements;		// source column pointer
X    for(wrp=trp; wrp < elements+nelems; wrp += nrows)
X    {
X      register double sum = 0;			// Multiply a row of old_target
X      for(orp=one_row; orp < one_row_end;)	// by each col of source
X	sum += *orp++ * *scp++;			// to get a row of new_target
X      *wrp = sum;
X    }
X  }
X
X  return *this;
X}
X
X			// General matrix multiplication
X			// Create a matrix C such that C = A * B
X			// Note, matrix C needs to be allocated
Xvoid Matrix::_AmultB(const Matrix& A, const Matrix& B)
X{
X  A.is_valid();
X  B.is_valid();
X
X  if( A.ncols != B.nrows || A.col_lwb != B.row_lwb )
X    A.info(), B.info(),
X    _error("matrices above cannot be multiplied");
X
X  allocate(A.nrows,B.ncols,A.row_lwb,B.col_lwb);
X
X  register REAL * arp;			// Pointer to the i-th row of A
X           REAL * bcp = B.elements;	// Pointer to the j-th col of B
X  register REAL * cp = elements;	// C is to be traversed in the natural
X  while( cp < elements + nelems )	// order, col-after-col
X  {
X    for(arp = A.elements; arp < A.elements + A.nrows; )
X    {
X      register double cij = 0;
X      register REAL * bccp = bcp;		// To scan the jth col of B
X      while( arp < A.elements + A.nelems )	// Scan the i-th row of A and
X	cij += *bccp++ * *arp, arp += A.nrows;	// the j-th col of B
X      *cp++ = cij;
X      arp -= A.nelems - 1;			// arp points to (i+1)-th row
X    }
X    bcp += B.nrows;			// We're done with j-th col of both
X  }					// B and C. Set bcp to the (j+1)-th col
X
X  assert( cp == elements + nelems && bcp == B.elements + B.nelems );
X}
X
X			// Compute C = A*B
X			// The same is above, only matrix C is already
X			// allocated, and it is *this
Xvoid Matrix::mult(const Matrix& A, const Matrix& B)
X{
X  A.is_valid();
X  B.is_valid();
X  is_valid();
X  
X  if( A.ncols != B.nrows || A.col_lwb != B.row_lwb )
X    A.info(), B.info(),
X    _error("matrices above cannot be multiplied");
X  if( nrows != A.nrows || ncols != B.ncols ||
X      row_lwb != A.row_lwb || col_lwb != B.col_lwb )
X    A.info(),B.info(),info(),
X    _error("product A*B is incompatible with the given matrix");
X
X  register REAL * arp;			// Pointer to the i-th row of A
X           REAL * bcp = B.elements;	// Pointer to the j-th col of B
X  register REAL * cp = elements;	// C is to be traversed in the natural
X  while( cp < elements + nelems )	// order, col-after-col
X  {
X    for(arp = A.elements; arp < A.elements + A.nrows; )
X    {
X      register double cij = 0;
X      register REAL * bccp = bcp;		// To scan the jth col of B
X      while( arp < A.elements + A.nelems )	// Scan the i-th row of A and
X	cij += *bccp++ * *arp, arp += A.nrows;	// the j-th col of B
X      *cp++ = cij;
X      arp -= A.nelems - 1;			// arp points to (i+1)-th row
X    }
X    bcp += B.nrows;			// We're done with j-th col of both
X  }					// B and C. Set bcp to the (j+1)-th col
X
X  assert( cp == elements + nelems && bcp == B.elements + B.nelems );
X}
X
X			// Create a matrix C such that C = A' * B
X			// In other words,
X			// c[i,j] = SUM{ a[k,i] * b[k,j] }
X			// Note, matrix C needs to be allocated
Xvoid Matrix::_AtmultB(const Matrix& A, const Matrix& B)
X{
X  A.is_valid();
X  B.is_valid();
X
X  if( A.nrows != B.nrows || A.row_lwb != B.row_lwb )
X    A.info(), B.info(),
X    _error("matrices above are unsuitable for A'B multiplication");
X
X  allocate(A.ncols,B.ncols,A.col_lwb,B.col_lwb);
X
X  register REAL * acp;			// Pointer to the i-th col of A
X           REAL * bcp = B.elements;	// Pointer to the j-th col of B
X  register REAL * cp = elements;	// C is to be traversed in the natural
X  while( cp < elements + nelems )	// order, col-after-col
X  {
X    for(acp = A.elements; acp<A.elements + A.nelems;)
X    {					// Scan all cols of A
X      register double cij = 0;			
X      register REAL * bccp = bcp;		// To scan the jth col of B
X      for(register int i=0; i<A.nrows; i++)	// Scan the i-th row of A and
X	cij += *bccp++ * *acp++;			// the j-th col of B
X      *cp++ = cij;
X    }
X    bcp += B.nrows;			// We're done with j-th col of both
X  }					// B and C. Set bcp to the (j+1)-th col
X
X  assert( cp == elements + nelems && bcp == B.elements + B.nelems );
X}
________This_Is_The_END________
if test `wc -l < matrix2.cc` -ne 197; then
echo 'shar: matrix2.cc was damaged during transit (should have had 197 lines)'
fi


echo 'x - matrix_inv.cc'
sed 's/^X//' << '________This_Is_The_END________' > matrix_inv.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *			Linear Algebra Package
X *
X *			Find the matrix inverse
X *		for matrices of general and special forms
X *
X * $Id: matrix_inv.cc,v 3.1 1995/01/31 17:17:41 oleg Exp oleg $
X *
X ************************************************************************
X */
X
X#include "LinAlg.h"
X#include <math.h>
X#include <alloca.h>
X
X/*
X *------------------------------------------------------------------------
X *
X *		The most general (Gauss-Jordan) matrix inverse
X *
X * This method works for any matrix (which of course must be square and
X * non-singular). Use this method only if none of specialized algorithms
X * (for symmetric, tridiagonal, etc) matrices isn't applicable/available.
X * Also, the matrix to invert has to be _well_ conditioned:
X * Gauss-Jordan eliminations (even with pivoting) perform poorly for
X * near-singular matrices (e.g., Hilbert matrices).
X *
X * The method inverts matrix inplace and returns the determinant if
X * determ_ptr was specified as not nil. determinant will be exactly zero
X * if the matrix turns out to be (numerically) singular. If determ_ptr is
X * nil and matrix happens to be singular, throw up.
X *
X * The algorithm perform inplace Gauss-Jordan eliminations with
X * full pivoting. It was adapted from my Algol-68 "translation" (ca 1986)
X * of the FORTRAN code described in
X * Johnson, K. Jeffrey, "Numerical methods in chemistry", New York,
X * N.Y.: Dekker, c1980, 503 pp, p.221
X *
X * Note, since it's much more efficient to perform operations on matrix
X * columns rather than matrix rows (due to the layout of elements in the
X * matrix), the present method implements a "transposed" algorithm.
X *
X */
X
XMatrix& Matrix::invert(double * determ_ptr)
X{
X  is_valid();
X  if( nrows != ncols )
X    info(),
X    _error("Matrix to invert must be square");
X
X  double determinant = 1;
X  const double singularity_tolerance = 1e-35;
X
X				// Locations of pivots (indices start with 0)
X  struct Pivot { int row, col; } * const pivots = 
X  			(Pivot*)alloca(ncols*sizeof(Pivot));
X  bool * const was_pivoted = (bool*)alloca(nrows*sizeof(bool)); 
X  memset(was_pivoted,false,nrows*sizeof(bool));
X  register Pivot * pivotp;
X
X  for(pivotp = &pivots[0]; pivotp < &pivots[ncols]; pivotp++)
X  {
X    int prow = 0, pcol = 0;		// Location of a pivot to be
X    {					// Look through all non-pivoted cols
X      REAL max_value = 0;		// (and rows) for a pivot (max elem)
X      for(register int j=0; j<ncols; j++)
X	if( !was_pivoted[j] )
X	{
X	  register REAL * cp;
X	  register int k;
X	  REAL curr_value = 0;
X	  for(k=0,cp=index[j]; k<nrows; k++,cp++)
X	    if( !was_pivoted[k] && (curr_value = fabs(*cp)) > max_value )
X	      max_value = curr_value, prow = k, pcol = j;
X	}
X      if( max_value < singularity_tolerance )
X	if( determ_ptr )
X	{
X	  *determ_ptr = 0;
X	  return *this;
X	}
X        else
X	  _error("Matrix turns out to be singular: can't invert");
X      pivotp->row = prow;
X      pivotp->col = pcol;
X    }
X
X    if( prow != pcol )			// Swap prow-th and pcol-th columns to
X    {					// bring the pivot to the diagonal
X      register REAL * cr = index[prow];
X      register REAL * cc = index[pcol];
X      for(register int k=0; k<nrows; k++)
X      {
X	REAL temp = *cr; *cr++ = *cc; *cc++ = temp;
X      }
X    }
X    was_pivoted[prow] = true;
X
X    {					// Normalize the pivot column and
X      register REAL * pivot_cp = index[prow];
X      double pivot_val = pivot_cp[prow];	// pivot is at the diagonal
X      determinant *= pivot_val;		// correct the determinant
X      pivot_cp[prow] = true;
X      for(register int k=0; k<nrows; k++)
X	*pivot_cp++ /= pivot_val;
X    }
X
X    {					// Perform eliminations
X      register REAL * pivot_rp = elements + prow;	// pivot row
X      for(register int k=0; k<nrows; k++, pivot_rp += nrows)
X	if( k != prow )
X	{
X	  double temp = *pivot_rp;
X	  *pivot_rp = 0;
X	  register REAL * pivot_cp = index[prow];	// pivot column
X	  register REAL * elim_cp  = index[k];		// elimination column
X	  for(register int l=0; l<nrows; l++)
X	    *elim_cp++ -= temp * *pivot_cp++;
X	}
X    }
X  }
X
X  int no_swaps = 0;		// Swap exchanged *rows* back in place
X  for(pivotp = &pivots[ncols-1]; pivotp >= &pivots[0]; pivotp--)
X    if( pivotp->row != pivotp->col )
X    {
X      no_swaps++;
X      register REAL * rp = elements + pivotp->row;
X      register REAL * cp = elements + pivotp->col;
X      for(register int k=0; k<ncols; k++, rp += nrows, cp += nrows)
X      {
X	REAL temp = *rp; *rp = *cp; *cp = temp;
X      }
X    }
X
X  if( determ_ptr )
X    *determ_ptr = ( no_swaps & 1 ? -determinant : determinant );
X
X  return *this;
X}
X
X
X				// Allocate new matrix and set it to inv(m)
Xvoid Matrix::_invert(const Matrix& m)
X{
X  m.is_valid();
X  allocate(m.nrows,m.ncols,m.row_lwb,m.col_lwb);
X  *this = m;
X  invert(0);
X}
X  
________This_Is_The_END________
if test `wc -l < matrix_inv.cc` -ne 155; then
echo 'shar: matrix_inv.cc was damaged during transit (should have had 155 lines)'
fi


echo 'x - matrix_sub.cc'
sed 's/^X//' << '________This_Is_The_END________' > matrix_sub.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *			Linear Algebra Package
X *
X *		Basic linear algebra operations, levels 1 & 2
X *	    Operations on a single row, column, or the diagonal
X *			   	of a matrix
X *
X * $Id: matrix_sub.cc,v 3.1 1995/01/31 17:27:47 oleg Exp oleg $
X *
X ************************************************************************
X */
X
X#include "LinAlg.h"
X#include <math.h>
X
X
X/*
X *------------------------------------------------------------------------
X *		    Messing with a single column of a matrix
X */
X
X 				// For every element, do `elem OP value`
X#define COMPUTED_VAL_ASSIGNMENT(OP,VALTYPE)				\
X									\
Xvoid MatrixColumn::operator OP (const VALTYPE val)			\
X{									\
X  matrix.is_valid();							\
X									\
X  register REAL * cp = ptr;		/* Column ptr */		\
X  while( cp < ptr + matrix.nrows )					\
X    *cp++ OP val;							\
X}									\
X
XCOMPUTED_VAL_ASSIGNMENT(=,REAL)
XCOMPUTED_VAL_ASSIGNMENT(+=,double)
XCOMPUTED_VAL_ASSIGNMENT(*=,double)
X
X#undef COMPUTED_VAL_ASSIGNMENT
X
X
X				// Assign a vector to a matrix col
Xvoid MatrixColumn::operator = (const Vector & vec)
X{
X  matrix.is_valid();
X  vec.is_valid();
X
X  if( matrix.row_lwb != vec.row_lwb || matrix.nrows != vec.nrows )
X    matrix.info(), vec.info(),
X   _error("Vector cannot be assigned to a column of the mentioned matrix");
X
X  register REAL * cp = ptr;		// Column ptr
X  register REAL * vp = vec.elements;	// Vector ptr
X  while( cp < ptr + matrix.nrows )
X    *cp++ = *vp++;
X
X  assert( vp == vec.elements + vec.nrows );
X}
X
X				// Assign a matrix column to a vector
XVector& Vector::operator = (const MatrixColumn & mc)
X{
X  is_valid();
X  mc.matrix.is_valid();
X
X  if( mc.matrix.q_row_lwb() != row_lwb || mc.matrix.q_nrows() != nrows )
X    mc.matrix.info(), info(),
X   _error("Can't assign a column of the matrix above to the vector");
X
X  register REAL * cp = mc.ptr;		// Column ptr
X  register REAL * vp = elements;	// Vector ptr
X  while( vp < elements + nrows )
X    *vp++ = *cp++;
X
X  assert( cp == mc.ptr + mc.matrix.q_nrows() );
X
X  return *this;
X}
X
X
X/*
X *------------------------------------------------------------------------
X *		     Messing with a single row of a matrix
X *  Keep in mind the matrix elements are arranged in columns!
X */
X
X
X 				// For every element, do `elem OP value`
X#define COMPUTED_VAL_ASSIGNMENT(OP,VALTYPE)				\
X									\
Xvoid MatrixRow::operator OP (const VALTYPE val)				\
X{									\
X  matrix.is_valid();							\
X									\
X  register REAL * rp = ptr;		/* Row ptr */			\
X  for(; rp < ptr + matrix.nelems; rp += inc)				\
X    *rp OP val;								\
X}									\
X
XCOMPUTED_VAL_ASSIGNMENT(=,REAL)
XCOMPUTED_VAL_ASSIGNMENT(+=,double)
XCOMPUTED_VAL_ASSIGNMENT(*=,double)
X
X#undef COMPUTED_VAL_ASSIGNMENT
X
X
X				// Assign a vector to a matrix row
X				// The vector is considered row-vector
X				// to allow the assignment in the strict
X				// sense
Xvoid MatrixRow::operator = (const Vector & vec)
X{
X  matrix.is_valid();
X  vec.is_valid();
X
X  if( matrix.col_lwb != vec.row_lwb || matrix.ncols != vec.nrows )
X    matrix.info(), vec.info(),
X   _error("Transposed vector cannot be assigned to a row of the matrix");
X
X  register REAL * rp = ptr;		// Row ptr
X  register REAL * vp = vec.elements;	// Vector ptr
X  for(; rp < ptr + matrix.nelems; rp += inc)
X    *rp = *vp++;
X
X  assert( vp == vec.elements + vec.nrows );
X}
X
X				// Assign a matrix row to a vector
X				// The matrix row is implicitly transposed
X				// to allow the assignment in the strict
X				// sense
XVector& Vector::operator = (const MatrixRow & mr)
X{
X  is_valid();
X  mr.matrix.is_valid();
X
X  if( mr.matrix.col_lwb != row_lwb || mr.matrix.ncols != nrows )
X    mr.matrix.info(), info(),
X   _error("Can't assign the transposed row of the matrix to the vector");
X
X  register REAL * rp = mr.ptr;		// Row ptr
X  register REAL * vp = elements;	// Vector ptr
X  for(; vp < elements + nrows; rp += mr.inc)
X    *vp++ = *rp;
X
X  assert( rp == mr.ptr + mr.matrix.nelems );
X
X  return *this;
X}
X
X/*
X *------------------------------------------------------------------------
X *			Messing with the matrix diagonal
X */
X
X 				// For every element, do `elem OP value`
X#define COMPUTED_VAL_ASSIGNMENT(OP,VALTYPE)				\
X									\
Xvoid MatrixDiag::operator OP (const VALTYPE val)			\
X{									\
X  matrix.is_valid();							\
X									\
X  register REAL * dp = ptr;		/* Diag ptr */			\
X  register int i;							\
X  for(i=0; i < ndiag; i++, dp += inc)					\
X    *dp OP val;								\
X}									\
X
XCOMPUTED_VAL_ASSIGNMENT(=,REAL)
XCOMPUTED_VAL_ASSIGNMENT(+=,double)
XCOMPUTED_VAL_ASSIGNMENT(*=,double)
X
X#undef COMPUTED_VAL_ASSIGNMENT
X
X
X				// Assign a vector to the matrix diagonal
Xvoid MatrixDiag::operator = (const Vector & vec)
X{
X  matrix.is_valid();
X  vec.is_valid();
X
X  if( ndiag != vec.nrows )
X    matrix.info(), vec.info(),
X   _error("Vector cannot be assigned to the matrix diagonal");
X
X  register REAL * dp = ptr;		// Diag ptr
X  register REAL * vp = vec.elements;	// Vector ptr
X  for(; vp < vec.elements + vec.nrows; dp += inc)
X    *dp = *vp++;
X
X  assert( dp < ptr + matrix.nelems + inc );
X}
X
X
X				// Assign the matrix diagonal to a vector
XVector& Vector::operator = (const MatrixDiag & md)
X{
X  is_valid();
X  md.matrix.is_valid();
X
X  if( md.ndiag != nrows )
X    md.matrix.info(), info(),
X   _error("Can't assign the diagonal of the matrix to the vector");
X
X  register REAL * dp = md.ptr;		// Diag ptr
X  register REAL * vp = elements;	// Vector ptr
X  for(; vp < elements + nrows; dp += md.inc)
X    *vp++ = *dp;
X
X  assert( dp < md.ptr + md.matrix.nelems + md.inc );
X
X  return *this;
X}
X
X/*
X *------------------------------------------------------------------------
X *		   Multiplications with the diagonal matrix
X */
X
X				// Multiply a matrix by the diagonal
X				// of another matrix
X				// matrix(i,j) *= diag(j)
XMatrix& Matrix::operator *= (const MatrixDiag& diag)
X{
X  is_valid();
X  diag.matrix.is_valid();
X
X  if( ncols != diag.ndiag )
X    info(), diag.matrix.info(),
X   _error("Matrix cannot be multiplied by the diagonal of the other matrix");
X
X  register REAL * dp = diag.ptr;	// Diag ptr
X  register REAL * mp = elements;	// Matrix ptr
X  register int i;
X  for(; mp < elements + nelems; dp += diag.inc)
X    for(i=0; i<nrows; i++)
X      *mp++ *= *dp;
X
X  assert( dp < diag.ptr + diag.matrix.nelems + diag.inc );
X
X  return *this;
X}
________This_Is_The_END________
if test `wc -l < matrix_sub.cc` -ne 244; then
echo 'shar: matrix_sub.cc was damaged during transit (should have had 244 lines)'
fi


echo 'x - myenv.cc'
sed 's/^X//' << '________This_Is_The_END________' > myenv.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *			Service C++ functions 
X *	     that support the standard environment for me
X *
X * $Id: myenv.cc,v 1.4 1995/06/05 16:17:52 oleg Exp oleg $
X */
X
X#ifdef __GNUC__
X#pragma implementation
X#endif
X
X#include "myenv.h"
X#include <stdio.h>
X#include <stdlib.h>
X#include <string.h>
X#include <stdarg.h>
X
X/*
X *-----------------------------------------------------------------------
X *		Some global constant pertaining to input/output
X */
X
Xconst char _Minuses [] = "\
X-------------------------------------------------------------------------------";
X
Xconst char _Asteriscs [] = "\
X*******************************************************************************";
X
Xconst char _Equals [] = "\
X===============================================================================";
X
X
X/*
X *------------------------------------------------------------------------
X *	        Print an error message at stderr and abort
X * Synopsis
X *	volatile void _error(const char * message,... );
X *	Message may contain format control sequences %x. Items to print 
X *	with the control sequences are to be passed as additional arguments to
X *	the function call.
X */
X
Xvolatile void _error(const char * message,...)
X{
X  va_list args;
X  va_start(args,message);		/* Init 'args' to the beginning of */
X					/* the variable length list of args*/
X  fprintf(stderr,"\n_error:\n"); 	
X  vfprintf(stderr,message,args);
X  fputs("\n",stderr);
X#ifdef __MWERKS__
X  exit(4);
X#else  
X  abort();
X#endif
X}
X
X
X/*
X *------------------------------------------------------------------------
X *	       		 Print a message at stderr
X * Synopsis
X *	void message(const char * text,... );
X *	Message may contain format control sequences %x. Items to print 
X *	with the control sequences are to be passed as additional arguments to
X *	the function call.
X */
X
Xvoid message(const char * text,...)
X{
X  va_list args;
X  va_start(args,text);		/* Init 'args' to the beginning of */
X					/* the variable length list of args*/
X  vfprintf(stderr,text,args);
X}
X
X//------------------------------------------------------------------------
X//		    Patches to the standard environment
X
X                                // Like strncpy(), but ALWAYS terminates
X                                // the destination string
Xchar * xstrncpy(char * dest, const char * src, const int len)
X{
X  strncpy(dest,src,len);
X  dest[len] = '\0';
X  return dest;
X}
X
X#ifndef __GNUC__
X#include <time.h>
X
X				// libg++ nifty timing functions
X				// Very rough and dirty implementation for
X				// platforms w/o libg++
Xstatic time_t time_set;
X
Xdouble start_timer(void)
X{
X  return time_set = time(0);
X}
X				// return_elapsed_time(last_time) returns
X				// process time (in secs) since Last_Time
X				// If Last_time == 0.0, return time since
X				// the last call to start_timer()
Xdouble return_elapsed_time(const double last_time)
X{
X  time_t new_time = time(0);
X  if( time_set == 0 )
X    return -1;				// timer wasn't started
X  return new_time - (last_time == 0.0 ? time_set : last_time);
X}
X
X#endif
________This_Is_The_END________
if test `wc -l < myenv.cc` -ne 115; then
echo 'shar: myenv.cc was damaged during transit (should have had 115 lines)'
fi


echo 'x - sample_adv.cc'
sed 's/^X//' << '________This_Is_The_END________' > sample_adv.cc
X//	       Sample code showing off a few advanced features
X//	  and comparing them (time-wise) with traditional ones
X//
X// Simple example: downsampling a matrix, that is, creating a matrix
X// that is 4 times (twice in each dimension) smaller than the original
X// matrix, by picking every other sample of the latter.
X//
X// $Id: sample_adv.cc,v 3.1 1995/02/07 14:40:37 oleg Exp oleg $
X
X#include "LinAlg.h"
X#include <std.h>
X#include <iostream.h>
X
X				// Downsample matrix - new style
Xclass downsample_matrix : public LazyMatrix
X{
X  const Matrix& orig_matrix;
X  void fill_in(Matrix& m) const;
Xpublic:
X  downsample_matrix(const Matrix& orig_matrix);
X};
X
X				// Just figure out the dimensions of the
X				// downsampled (lazy) matrix
Xdownsample_matrix::downsample_matrix(const Matrix& _orig_matrix)
X	: LazyMatrix(_orig_matrix.q_row_lwb(),
X		     (_orig_matrix.q_nrows()+1)/2 + _orig_matrix.q_row_lwb()-1,
X		     _orig_matrix.q_col_lwb(),
X		     (_orig_matrix.q_ncols()+1)/2 +_orig_matrix.q_col_lwb()-1),
X		     orig_matrix(_orig_matrix)
X{
X}
X
X				// "construct" the new matrix (when the lazy
X				// matrix is being "rolled out")
Xvoid downsample_matrix::fill_in(Matrix& m) const
X{
X  class do_downsample : public ElementAction
X  {
X    const Matrix& orig_matrix;
X    const int row_lwb, col_lwb;
X    void operation(REAL& element)
X	{ element = orig_matrix((i-row_lwb)*2+row_lwb,(j-col_lwb)*2+col_lwb); }
X    public: do_downsample(const Matrix& _orig_matrix)
X      : orig_matrix(_orig_matrix),
X	row_lwb(orig_matrix.q_row_lwb()),
X	col_lwb(orig_matrix.q_col_lwb()) {}
X  };
X  m.apply(do_downsample(orig_matrix));
X}
X
X				// Downsample in the traditional style
Xstatic Matrix traditional_downsampling(const Matrix& orig_matrix)
X{
X  Matrix smaller_m(orig_matrix.q_row_lwb(),
X		   (orig_matrix.q_nrows()+1)/2 + orig_matrix.q_row_lwb()-1,
X		   orig_matrix.q_col_lwb(),
X		   (orig_matrix.q_ncols()+1)/2 + orig_matrix.q_col_lwb()-1);
X
X  for(register int i=0; i<smaller_m.q_nrows(); i++)
X    for(register int j=0; j<smaller_m.q_ncols(); j++)
X      smaller_m(i+smaller_m.q_row_lwb(),j+smaller_m.q_col_lwb()) =
X	orig_matrix(2*i+smaller_m.q_row_lwb(),2*j+smaller_m.q_col_lwb());
X  return smaller_m;
X}
X
Xmain(void)
X{
X  cout << "\nDonsample matrices using traditional and non-traditional methods"
X    << endl;
X
X  {
X    cout << "\nMake sure that both methods give the same results" << endl;
X    Matrix orig_m = haar_matrix(9,201);	// which is a pretty big matrix
X    Matrix small1 = traditional_downsampling(orig_m);
X    Matrix small2 = downsample_matrix(orig_m);
X    assert( small1 == small2 );
X  }
X
X  {
X    cout << "\nClock the traditional downsampling" << endl;
X    start_timer();
X    for(int order=1; order<=10; order++)
X    {
X      Matrix orig_m = haar_matrix(order);	// may be pretty big, btw
X      for(int count=0; count < (1<<(12-order)); count++)
X      {
X	Matrix small = traditional_downsampling(orig_m);
X	small(1,1) = 1;				// just to use the matrix
X      }
X    }
X    cout << "\tIt took " << return_elapsed_time(0) 
X         << " sec to complete the test" << endl;
X  }
X
X  {
X    cout << "\nClock the 'new style' downsampling (with lazy matrices)"<< endl;
X    start_timer();
X    for(int order=1; order<=10; order++)
X    {
X      Matrix orig_m = haar_matrix(order);	// may be pretty big, btw
X      for(int count=0; count < (1<<(12-order)); count++)
X      {
X	Matrix small = downsample_matrix(orig_m);
X	small(1,1) = 1;				// just to use the matrix
X      }
X    }
X    cout << "\tIt took " << return_elapsed_time(0) 
X         << " sec to complete the test" << endl;
X  }
X}	
________This_Is_The_END________
if test `wc -l < sample_adv.cc` -ne 111; then
echo 'shar: sample_adv.cc was damaged during transit (should have had 111 lines)'
fi


echo 'x - svd.cc'
sed 's/^X//' << '________This_Is_The_END________' > svd.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *			  Numerical Math Package
X *	Singular Value Decomposition of a rectangular matrix
X *			     A = U * Sig * V'
X *
X * where matrices U and V are orthogonal and Sig is a digonal matrix.
X *
X * The singular value decomposition is performed by constructing an SVD
X * object from an M*N matrix A with M>=N (that is, at least as many rows
X * as columns). Note, in case M > N, matrix Sig has to be a M*N diagonal
X * matrix. However, it has only N diag elements, which we store in a 1:N
X * Vector sig.
X *
X * Algorithm
X *	Bidiagonalization with Hausholder reflections followed by a
X * modification of a QR-algorithm. For more details, see
X *   G.E. Forsythe, M.A. Malcolm, C.B. Moler
X *   Computer methods for mathematical computations. - Prentice-Hall, 1977
X * However, in the persent implementation, matrices U and V are computed
X * right away rather than delayed until after all Hausholder reflections.
X *
X * This code is based for the most part on a Algol68 code I wrote
X * ca. 1987
X *
X * $Id$
X *
X ************************************************************************
X */
X
X#ifdef __GNUC__
X#pragma implementation
X#endif
X
X#include <math.h>
X#include "svd.h"
X#include <float.h>
X
X/*
X *------------------------------------------------------------------------
X *				Bidiagonalization
X */
X
X /*
X *			Left Hausholder Transformations
X *
X * Zero out an entire subdiagonal of the i-th column of A and compute the
X * modified A[i,i] by multiplication (UP' * A) with a matrix UP'
X *   (1)  UP' = E - UPi * UPi' / beta
X *
X * where a column-vector UPi is as follows
X *   (2)  UPi = [ (i-1) zeros, A[i,i] + Norm, vector A[i+1:M,i] ]
X * where beta = UPi' * A[,i] and Norm is the norm of a vector A[i:M,i]
X * (sub-diag part of the i-th column of A). Note we assign the Norm the
X * same sign as that of A[i,i].
X * By construction, (1) does not affect the first (i-1) rows of A. Since
X * A[*,1:i-1] is bidiagonal (the result of the i-1 previous steps of
X * the bidiag algorithm), transform (1) doesn't affect these i-1 columns
X * either as one can easily verify.
X * The i-th column of A is transformed as
X *   (3)  UP' * A[*,i] = A[*,i] - UPi
X * (since UPi'*A[*,i]/beta = 1 by construction of UPi and beta)
X * This means effectively zeroing out A[i+1:M,i] (the entire subdiagonal
X * of the i-th column of A) and replacing A[i,i] with the -Norm. Thus
X * modified A[i,i] is returned by the present function.
X * The other (i+1:N) columns of A are transformed as
X *    (4)  UP' * A[,j] = A[,j] - UPi * ( UPi' * A[,j] / beta )
X * Note, due to (2), only elements of rows i+1:M actually  participate
X * in above transforms; the upper i-1 rows of A are not affected.
X * As was mentioned earlier,
X * (5)  beta = UPi' * A[,i] = (A[i,i] + Norm)*A[i,i] + A[i+1:M,i]*A[i+1:M,i]
X *	= ||A[i:M,i]||^2 + Norm*A[i,i] = Norm^2 + Norm*A[i,i]
X * (note the sign of the Norm is the same as A[i,i])
X * For extra precision, vector UPi (and so is Norm and beta) are scaled,
X * which would not affect (4) as easy to see.
X *
X * To satisfy the definition
X *   (6)  .SIG = U' A V
X * the result of consecutive transformations (1) over matrix A is accumulated
X * in matrix U' (which is initialized to be a unit matrix). At each step,
X * U' is left-multiplied by UP' = UP (UP is symmetric by construction,
X * see (1)). That is, U is right-multiplied by UP, that is, rows of U are
X * transformed similarly to columns of A, see eq. (4). We also keep in mind
X * that multiplication by UP at the i-th step does not affect the first i-1
X * columns of U.
X * Note that the vector UPi doesn't have to be allocated explicitly: its
X * first i-1 components are zeros (which we can always imply in computations),
X * and the rest of the components (but the UPi[i]) are the same as those
X * of A[i:M,i], the subdiagonal of A[,i]. This column, A[,i] is affected only
X * trivially as explained above, that is, we don't need to carry this
X * transformation explicitly (only A[i,i] is going to be non-trivially
X * affected, that is, replaced by -Norm, but we will use sig[i] to store
X * the result).
X *
X */
X 
X inline double SVD::left_hausholder(Matrix& A, const int i)
X {
X   MatrixColumn UPi(A,i);		// Note that only UPi[i:M] matter
X   register int j,k;
X   REAL scale = 0;			// Compute the scaling factor
X   for(k=i; k<=M; k++)
X     scale += abs(UPi(k));
X   if( scale == 0 )			// If A[,i] is a null vector, no
X     return 0;				// transform is required
X   double Norm_sqr = 0;			// Scale UPi (that is, A[,i])
X   for(k=i; k<=M; k++)			// and compute its norm, Norm^2
X     Norm_sqr += sqr(UPi(k) /= scale);
X   double new_Aii = sqrt(Norm_sqr);	// new_Aii = -Norm, Norm has the
X   if( UPi(i) > 0 ) new_Aii = -new_Aii;	// same sign as Aii (that is, UPi[i])
X   const float beta = - UPi(i)*new_Aii + Norm_sqr;
X   UPi(i) -= new_Aii;			// UPi[i] = A[i,i] - (-Norm)
X   
X   for(j=i+1; j<=N; j++)		// Transform i+1:N columns of A
X   {
X     MatrixColumn Aj(A,j);
X     REAL factor = 0;
X     for(k=i; k<=M; k++)
X       factor += UPi(k) * Aj(k);	// Compute UPi' * A[,j]
X     factor /= beta;
X     for(k=i; k<=M; k++)
X       Aj(k) -= UPi(k) * factor;
X   }
X
X   for(j=1; j<=M; j++)			// Accumulate the transform in U
X   {
X     MatrixRow Uj(U,j);
X     REAL factor = 0;
X     for(k=i; k<=M; k++)
X       factor += UPi(k) * Uj(k);	// Compute  U[j,] * UPi
X     factor /= beta;
X     for(k=i; k<=M; k++)
X        Uj(k) -= UPi(k) * factor;
X   }
X   return new_Aii * scale;		// Scale new Aii back (our new Sig[i])
X }
X 
X/*
X *			Right Hausholder Transformations
X *
X * Zero out i+2:N elements of a row A[i,] of matrix A by right
X * multiplication (A * VP) with a matrix VP
X *   (1)  VP = E - VPi * VPi' / beta
X *
X * where a vector-column .VPi is as follows
X *   (2)  VPi = [ i zeros, A[i,i+1] + Norm, vector A[i,i+2:N] ]
X * where beta = A[i,] * VPi and Norm is the norm of a vector A[i,i+1:N]
X * (right-diag part of the i-th row of A). Note we assign the Norm the
X * same sign as that of A[i,i+1].
X * By construction, (1) does not affect the first i columns of A. Since
X * A[1:i-1,] is bidiagonal (the result of the previous steps of
X * the bidiag algorithm), transform (1) doesn't affect these i-1 rows
X * either as one can easily verify.
X * The i-th row of A is transformed as
X *  (3)  A[i,*] * VP = A[i,*] - VPi'
X * (since A[i,*]*VPi/beta = 1 by construction of VPi and beta)
X * This means effectively zeroing out A[i,i+2:N] (the entire right super-
X * diagonal of the i-th row of A, but ONE superdiag element) and replacing
X * A[i,i+1] with - Norm. Thus modified A[i,i+1] is returned as the result of
X * the present function.
X * The other (i+1:M) rows of A are transformed as
X *    (4)  A[j,] * VP = A[j,] - VPi' * ( A[j,] * VPi / beta )
X * Note, due to (2), only elements of columns i+1:N actually  participate
X * in above transforms; the left i columns of A are not affected.
X * As was mentioned earlier,
X * (5)  beta = A[i,] * VPi = (A[i,i+1] + Norm)*A[i,i+1]
X *			   + A[i,i+2:N]*A[i,i+2:N]
X *	= ||A[i,i+1:N]||^2 + Norm*A[i,i+1] = Norm^2 + Norm*A[i,i+1]
X * (note the sign of the Norm is the same as A[i,i+1])
X * For extra precision, vector VPi (and so is Norm and beta) are scaled,
X * which would not affect (4) as easy to see.
X *
X * The result of consecutive transformations (1) over matrix A is accumulated
X * in matrix V (which is initialized to be a unit matrix). At each step,
X * V is right-multiplied by VP. That is, rows of V are transformed similarly
X * to rows of A, see eq. (4). We also keep in mind that multiplication by
X * VP at the i-th step does not affect the first i rows of V.
X * Note that vector VPi doesn't have to be allocated explicitly: its
X * first i components are zeros (which we can always imply in computations),
X * and the rest of the components (but the VPi[i+1]) are the same as those
X * of A[i,i+1:N], the superdiagonal of A[i,]. This row, A[i,] is affected
X * only trivially as explained above, that is, we don't need to carry this
X * transformation explicitly (only A[i,i+1] is going to be non-trivially
X * affected, that is, replaced by -Norm, but we will use super_diag[i+1] to
X * store the result).
X *
X */
X 
Xinline double SVD::right_hausholder(Matrix& A, const int i)
X{
X   MatrixRow VPi(A,i);			// Note only VPi[i+1:N] matter
X   register int j,k;
X   REAL scale = 0;			// Compute the scaling factor
X   for(k=i+1; k<=N; k++)
X     scale += abs(VPi(k));
X   if( scale == 0 )			// If A[i,] is a null vector, no
X     return 0;				// transform is required
X
X   double Norm_sqr = 0;			// Scale VPi (that is, A[i,])
X   for(k=i+1; k<=N; k++)		// and compute its norm, Norm^2
X     Norm_sqr += sqr(VPi(k) /= scale);
X   double new_Aii1 = sqrt(Norm_sqr);	// new_Aii1 = -Norm, Norm has the
X   if( VPi(i+1) > 0 )			// same sign as
X     new_Aii1 = -new_Aii1; 		// Aii1 (that is, VPi[i+1])
X   const float beta = - VPi(i+1)*new_Aii1 + Norm_sqr;
X   VPi(i+1) -= new_Aii1;		// VPi[i+1] = A[i,i+1] - (-Norm)
X   
X   for(j=i+1; j<=M; j++)		// Transform i+1:M rows of A
X   {
X     MatrixRow Aj(A,j);
X     REAL factor = 0;
X     for(k=i+1; k<=N; k++)
X       factor += VPi(k) * Aj(k);	// Compute A[j,] * VPi
X     factor /= beta;
X     for(k=i+1; k<=N; k++)
X       Aj(k) -= VPi(k) * factor;
X   }
X
X   for(j=1; j<=N; j++)			// Accumulate the transform in V
X   {
X     MatrixRow Vj(V,j);
X     REAL factor = 0;
X     for(k=i+1; k<=N; k++)
X       factor += VPi(k) * Vj(k);	// Compute  V[j,] * VPi
X     factor /= beta;
X     for(k=i+1; k<=N; k++)
X       Vj(k) -= VPi(k) * factor;
X   }
X   return new_Aii1 * scale;		// Scale new Aii1 back
X}
X
X/*
X *------------------------------------------------------------------------
X *			  Bidiagonalization
X * This nethod turns matrix A into a bidiagonal one. Its N diagonal elements
X * are stored in a vector sig, while N-1 superdiagonal elements are stored
X * in a vector super_diag(2:N) (with super_diag(1) being always 0).
X * Matrices U and V store the record of orthogonal Hausholder
X * reflections that were used to convert A to this form. The method
X * returns the norm of the resulting bidiagonal matrix, that is, the
X * maximal column sum.
X */
X
Xdouble SVD::bidiagonalize(Vector& super_diag, const Matrix& _A)
X{
X  double norm_acc = 0;
X  super_diag(1) = 0;			// No superdiag elem above A(1,1)
X  Matrix A = _A;			// A being transformed
X  A.resize_to(_A.q_nrows(),_A.q_ncols()); // Indexing from 1
X  for(register int i=1; i<=N; i++)
X  {
X    const REAL& diagi = sig(i) = left_hausholder(A,i);
X    if( i < N )
X      super_diag(i+1) = right_hausholder(A,i);
X    norm_acc = max(norm_acc,abs(diagi)+abs(super_diag(i)));
X  }
X  return norm_acc;
X}
X
X/*
X *------------------------------------------------------------------------
X *		QR-diagonalization of a bidiagonal matrix
X *
X * After bidiagonalization we get a bidiagonal matrix J:
X *    (1)  J = U' * A * V
X * The present method turns J into a matrix JJ by applying a set of
X * orthogonal transforms
X *    (2)  JJ = S' * J * T
X * Orthogonal matrices S and T are chosen so that JJ were also a
X * bidiagonal matrix, but with superdiag elements smaller than those of J.
X * We repeat (2) until non-diag elements of JJ become smaller than EPS
X * and can be disregarded.
X * Matrices S and T are constructed as
X *    (3)  S = S1 * S2 * S3 ... Sn, and similarly T
X * where Sk and Tk are matrices of simple rotations
X *    (4)  Sk[i,j] = i==j ? 1 : 0 for all i>k or i<k-1
X *         Sk[k-1,k-1] = cos(Phk),  Sk[k-1,k] = -sin(Phk),
X *         SK[k,k-1] = sin(Phk),    Sk[k,k] = cos(Phk), k=2..N
X * Matrix Tk is constructed similarly, only with angle Thk rather than Phk.
X *
X * Thus left multiplication of J by SK' can be spelled out as
X *    (5)  (Sk' * J)[i,j] = J[i,j] when i>k or i<k-1,
X *                  [k-1,j] = cos(Phk)*J[k-1,j] + sin(Phk)*J[k,j]
X *                  [k,j] =  -sin(Phk)*J[k-1,j] + cos(Phk)*J[k,j]
X * That is, k-1 and k rows of J are replaced by their linear combinations;
X * the rest of J is unaffected. Right multiplication of J by Tk similarly
X * changes only k-1 and k columns of J.
X * Matrix T2 is chosen the way that T2'J'JT2 were a QR-transform with a
X * shift. Note that multiplying J by T2 gives rise to a J[2,1] element of
X * the product J (which is below the main diagonal). Angle Ph2 is then
X * chosen so that multiplication by S2' (which combines 1 and 2 rows of J)
X * gets rid of that elemnent. But this will create a [1,3] non-zero element.
X * T3 is made to make it disappear, but this leads to [3,2], etc.
X * In the end, Sn removes a [N,N-1] element of J and matrix S'JT becomes
X * bidiagonal again. However, because of a special choice
X * of T2 (QR-algorithm), its non-diag elements are smaller than those of J.
X *
X * All this process in more detail is described in
X *    J.H. Wilkinson, C. Reinsch. Linear algebra - Springer-Verlag, 1971
X *
X * If during transforms (1), JJ[N-1,N] turns 0, then JJ[N,N] is a singular
X * number (possibly with a wrong (that is, negative) sign). This is a
X * consequence of Frantsis' Theorem, see the book above. In that case, we can
X * eliminate the N-th row and column of JJ and carry out further transforms
X * with a smaller matrix. If any other superdiag element of JJ turns 0,
X * then JJ effectively falls into two independent matrices. We will process
X * them independently (the bottom one first).
X *
X * Since matrix J is a bidiagonal, it can be stored efficiently. As a matter
X * of fact, its N diagonal elements are in array Sig, and superdiag elements
X * are stored in array super_diag.
X */
X 
X				// Carry out U * S with a rotation matrix
X				// S (which combines i-th and j-th columns
X				// of U, i>j)
Xinline void SVD::rotate(Matrix& U, const int i, const int j,
X		   const double cos_ph, const double sin_ph)
X{
X  MatrixColumn Ui(U,i), Uj(U,j);
X  for(register int l=1; l<=U.q_row_upb(); l++)
X  {
X    REAL& Uil = Ui(l); REAL& Ujl = Uj(l);
X    const REAL Ujl_was = Ujl;
X    Ujl =  cos_ph*Ujl_was + sin_ph*Uil;
X    Uil = -sin_ph*Ujl_was + cos_ph*Uil;
X  }
X}
X
X/*
X * A diagonal element J[l-1,l-1] turns out 0 at the k-th step of the
X * algorithm. That means that one of the original matrix' singular numbers
X * shall be zero. In that case, we multiply J by specially selected
X * matrices S' of simple rotations to eliminate a superdiag element J[l-1,l].
X * After that, matrix J falls into two pieces, which can be dealt with
X * in a regular way (the bottom piece first).
X * 
X * These special S transformations are accumulated into matrix U: since J
X * is left-multiplied by S', U would be right-multiplied by S. Transform
X * formulas for doing these rotations are similar to (5) above. See the
X * book cited above for more details.
X */
Xinline void SVD::rip_through(
X	Vector& super_diag, const int k, const int l, const double eps)
X{
X  double cos_ph = 0, sin_ph = 1;	// Accumulate cos,sin of Ph
X  				// The first step of the loop below
X  				// (when i==l) would eliminate J[l-1,l],
X  				// which is stored in super_diag(l)
X  				// However, it gives rise to J[l-1,l+1]
X  				// and J[l,l+2]
X  				// The following steps eliminate these
X  				// until they fall below
X  				// significance
X  for(register int i=l; i<=k; i++)
X  {
X    const double f = sin_ph * super_diag(i);
X    super_diag(i) *= cos_ph;
X    if( f <= eps )
X      break;			// Current J[l-1,l] became unsignificant
X    cos_ph = sig(i); sin_ph = -f;	// unnormalized sin/cos
X    const double norm = (sig(i) = hypot(cos_ph,sin_ph)); // sqrt(sin^2+cos^2)
X    cos_ph /= norm, sin_ph /= norm;	// Normalize sin/cos
X    rotate(U,i,l-1,cos_ph,sin_ph);
X  }
X}
X
X			// We're about to proceed doing QR-transforms
X			// on a (bidiag) matrix J[1:k,1:k]. It may happen
X			// though that the matrix splits (or can be
X			// split) into two independent pieces. This function
X			// checks for splitting and returns the lowerbound
X			// index l of the bottom piece, J[l:k,l:k]
Xinline int SVD::get_submatrix_to_work_on(
X	Vector& super_diag, const int k, const double eps)
X{
X  for(register int l=k; l>1; l--)
X    if( abs(super_diag(l)) <= eps )
X      return l;				// The breaking point: zero J[l-1,l]
X    else if( abs(sig(l-1)) <= eps )	// Diagonal J[l,l] turns out 0
X    {					// meaning J[l-1,l] _can_ be made
X      rip_through(super_diag,k,l,eps);	// zero after some rotations
X      return l;
X    }
X  return 1;			// Deal with J[1:k,1:k] as a whole
X}
X
X		// Diagonalize root module
Xvoid SVD::diagonalize(Vector& super_diag, const double eps)
X{
X  for(register int k=N; k>=1; k--)	// QR-iterate upon J[l:k,l:k]
X  {
X    register int l;
X    while(l=get_submatrix_to_work_on(super_diag,k,eps),
X    	  abs(super_diag(k)) > eps)	// until superdiag J[k-1,k] becomes 0
X    {
X      double shift;			// Compute a QR-shift from a bottom
X      {					// corner minor of J[l:k,l:k] order 2
X      	REAL Jk2k1 = super_diag(k-1),	// J[k-2,k-1]
X      	     Jk1k  = super_diag(k),
X      	     Jk1k1 = sig(k-1),		// J[k-1,k-1]
X      	     Jkk   = sig(k),
X      	     Jll   = sig(l);		// J[l,l]
X      	shift = (Jk1k1-Jkk)*(Jk1k1+Jkk) + (Jk2k1-Jk1k)*(Jk2k1+Jk1k);
X      	shift /= 2*Jk1k*Jk1k1;
X      	shift += (shift < 0 ? -1 : 1) * sqrt(shift*shift+1);
X      	shift = ( (Jll-Jkk)*(Jll+Jkk) + Jk1k*(Jk1k1/shift-Jk1k) )/Jll;
X      }
X      				// Carry on multiplications by T2, S2, T3...
X      double cos_th = 1, sin_th = 1;
X      REAL Ji1i1 = sig(l);	// J[i-1,i-1] at i=l+1...k
X      for(register int i=l+1; i<=k; i++)
X      {
X      	REAL Ji1i = super_diag(i), Jii = sig(i);  // J[i-1,i] and J[i,i]
X      	sin_th *= Ji1i; Ji1i *= cos_th; cos_th = shift;
X      	double norm_f = (super_diag(i-1) = hypot(cos_th,sin_th));
X      	cos_th /= norm_f, sin_th /= norm_f;
X      					// Rotate J[i-1:i,i-1:i] by Ti
X      	shift = cos_th*Ji1i1 + sin_th*Ji1i;	// new J[i-1,i-1]
X      	Ji1i = -sin_th*Ji1i1 + cos_th*Ji1i;	// J[i-1,i] after rotation
X      	const double Jii1 = Jii*sin_th;		// Emerged J[i,i-1]
X      	Jii *= cos_th;				// new J[i,i]
X        rotate(V,i,i-1,cos_th,sin_th); // Accumulate T rotations in V
X        
X        double cos_ph = shift, sin_ph = Jii1;// Make Si to get rid of J[i,i-1]
X        sig(i-1) = (norm_f = hypot(cos_ph,sin_ph));	// New J[i-1,i-1]
X        if( norm_f == 0 )		// If norm =0, rotation angle
X          cos_ph = cos_th, sin_ph = sin_th; // can be anything now
X        else
X          cos_ph /= norm_f, sin_ph /= norm_f;
X      					// Rotate J[i-1:i,i-1:i] by Si
X        shift = cos_ph * Ji1i + sin_ph*Jii;	// New J[i-1,i]
X        Ji1i1 = -sin_ph*Ji1i + cos_ph*Jii;	// New Jii, would carry over
X        					// as J[i-1,i-1] for next i
X        rotate(U,i,i-1,cos_ph,sin_ph);  // Accumulate S rotations in U
X        				// Jii1 disappears, sin_th would
X        cos_th = cos_ph, sin_th = sin_ph; // carry over a (scaled) J[i-1,i+1]
X        				// to eliminate on the next i, cos_th
X        				// would carry over a scaled J[i,i+1]
X      }
X      super_diag(l) = 0;		// Supposed to be eliminated by now
X      super_diag(k) = shift;
X      sig(k) = Ji1i1;
X    }		// --- end-of-QR-iterations
X    if( sig(k) < 0 )		// Correct the sign of the sing number
X    {
X      sig(k) = -sig(k);
X      MatrixColumn Vk(V,k);
X      for(register int j=1; j<=V.q_row_upb(); j++)
X        Vk(j) = -Vk(j);
X    }
X  }
X    
X} 
X
X
X/*
X *------------------------------------------------------------------------
X *				The root Module
X */
X
XSVD::SVD(const Matrix& A)
X   : M(A.q_nrows()), N(A.q_ncols()),
X     U(A.q_nrows(),A.q_nrows()),
X     V(A.q_ncols(),A.q_ncols()),
X     sig(A.q_ncols())
X{
X  if( M < N )
X    A.info(),
X    _error("Matrix A should have at least as many rows as it has columns");
X     
X  U.unit_matrix(); V.unit_matrix();
X
X  Vector super_diag(N);
X  const double bidiag_norm = bidiagonalize(super_diag,A);
X  const double eps = FLT_EPSILON * bidiag_norm;	// Significance threshold
X  diagonalize(super_diag,eps);
X}
X
X/*
X *------------------------------------------------------------------------
X *		Print some info about the SVD that has been built
X */
X
X				// Print the info about the SVD
Xvoid SVD::info(void) const
X{
X  U.is_valid();
X  message("\nSVD of an %dx%d matrix",M,N);
X}
X
X				// Return min and max singular values
XSVD::operator MinMax(void) const
X{
X  REAL max_sig, min_sig;
X  max_sig = min_sig = sig(1);
X  for(register int i=2; i<=sig.q_no_elems(); i++)
X    if( sig(i) > max_sig )
X      max_sig = sig(i);
X    else if( sig(i) < min_sig )
X      min_sig = sig(i);
X  return MinMax(min_sig,max_sig);
X}
X
X					// sig_max/sig_min
Xdouble SVD::q_cond_number(void) const
X{
X  return ((MinMax)(*this)).ratio();
X}
X
X/*
X *------------------------------------------------------------------------
X * 			class SVD_inv_mult
X * 	Solving an (overspecified) set of linear equations A*X=B
X * 		using a least squares method via SVD
X *
X * Matrix A is a rectangular M*N matrix with M>=N, B is a M*K matrix
X * with K either =1 (that is, B is merely a column-vector) or K>1.
X * If B is a unit matrix of the size that of A, the present LazyMatrix is
X * a regularized (pseudo)inverse of A.
X *
X * Algorithm
X *   Matrix A is decomposed first using SVD:
X *	(1) A = U*Sig*V'
X * where matrices U and V are orthogonal and Sig is diagonal.
X * The set of simultaneous linear equations AX=B can be written then as
X *	(2) Sig*V'*X = U'*B
X * (where we have used the fact that U'=inv(U)), or
X *	(3) Sig*Vx = Ub
X * where we introduced
X *	(4) Vx = V'*X and Ub = U'*b
X * Since Sig is a diag matrix, eq. (3) is solved trivially:
X * 	(5) Vx[i] = Ub[i]/sig[i], if sig[i] > tau
X *		  = 0	otherwise
X * In the latter case matrix Sig has an incomplete rank, or close to that.
X * That is, one or more singular values are _too_ small. This means that
X * there is linear dependence among the equations of the set. In that case,
X * we will print the corresponding "null coefficients", the corresponding
X * columns of V. Adding them to the solution X won't change A*X.
X *
X * Having computed Vx, X is simply recovered as
X *	(6) X = V*Vx
X * since V*V' = E.
X *
X * Threshold tau in (5) is chosen as N*FLT_EPSILON*max(Sig[i,i]) unless
X * specified otherwise by the user.
X */
X
XSVD_inv_mult::SVD_inv_mult
X	(const SVD& _svd, const Matrix& _B,const double _tau)
X	: LazyMatrix(_svd.q_V().q_ncols(),_B.q_ncols()),
X	  svd(_svd), B(_B), tau(_tau)
X{
X  if( svd.q_U().q_nrows() != B.q_nrows() )
X    svd.info(), B.info(),
X    _error("Unsuitable matrices for SVD*X=B set");
X  MinMax sig_minmax = (MinMax)svd;
X  if( tau == 0 )
X   tau = svd.q_V().q_nrows() * sig_minmax.max() * FLT_EPSILON;
X  are_zero_coeff = sig_minmax.min() < tau;
X}
X
X#if 0
X				// Computing X in a special case where
X				// B (and X) is a vector
Xinline void SVD_inv_mult::fill_in_vector(Matrix& X) const
X{
X  X.clear();
X  bool x_is_vector = x.q_ncols() == 1;
X  if( are_zero_coeff )
X    message("\nSVD solver of AX=B detected a linear dependency among X"
X    	    "\n  #  \tsingular value\tnull coefficients\n");
X  for(register int i=1; i<=svd.q_V().q_nrows(); i++)
X  {
X     MatrixCol Ui(U,i);
X     const double sigi = svd.q_sig()(i);
X     if( sigi > tau )
X       if( x_is_vector )
X         X(i) = (Ui * B)/sigi;
X       else
X         X(i) =0, print null coeffs...
X  }
X  X *= V;			// ???
X}
X#endif
X				// Computing X in a general case where
X				// B (and X) is a rectangular matrix
Xvoid SVD_inv_mult::fill_in(Matrix& X) const
X{
X  if( are_zero_coeff )
X    message("\nSVD solver of AX=B detected a linear dependency among X"
X    	    "\n  #  singular value\tnull coefficients\n");
X  Matrix Vx(Matrix::Zero,X);
X  Vector Ui(svd.q_U().q_nrows());			// i-th col of U
X  Vector Bj(B.q_nrows());				// j-th col of B
X  Vector Vxi(X.q_ncols());				// i-th row of VX
X  const Matrix& V = svd.q_V();
X  const Matrix& U = svd.q_U();
X
X  for(register int i=1; i<=V.q_ncols(); i++)
X  {
X    const double sigi = svd.q_sig()(i);
X    if( sigi > tau )
X    {
X      Ui = MatrixColumn(U,i);
X      for(register int j=1; j<=X.q_ncols(); j++)
X        Bj = MatrixColumn(B,j), Vxi(j) = Ui * Bj/sigi;
X     }
X     else
X     {
X      Vxi = 0;
X      message(" %d %12.2g \t(",i,sigi);
X      for(register int j=1; j<=V.q_nrows(); j++)
X        message("%10g ",V(j,i));
X      message(")\n");
X    }
X    MatrixRow(Vx,i) = Vxi;
X  }
X  X.mult(V,Vx);				// that is, set X to be V*Vx
X}
X
________This_Is_The_END________
if test `wc -l < svd.cc` -ne 623; then
echo 'shar: svd.cc was damaged during transit (should have had 623 lines)'
fi


echo 'x - vali.cc'
sed 's/^X//' << '________This_Is_The_END________' > vali.cc
X// This may look like C code, but it is really -*- C++ -*-
X//
X//		Verification of the Aitken-Lagrange Interpolation
X//
X
X#include "LinAlg.h"
X#include "math_num.h"
X#include <iostream.h>
X
X/*
X *------------------------------------------------------------------------
X *		Set of the test functions to interpolate
X */
X
Xstatic double (*F)(const double x);
X
Xstatic double f_exp(const double x)
X{
X  return exp(-x);
X}
X
Xstatic double f_sinexp(const double x)
X{
X  return sin(x) * exp(-x/10);
X}
X
X/*
X *------------------------------------------------------------------------
X *	Set of tests for the interpolation over the uniform grid
X */
X
X			// Verify that interpolation exactly at a node
X			// really gives the function value at the node
Xstatic void test_u_exact(const double s, const int ia, const int ib)
X{
X  cout << "\nCheck to see that interpolation at a node gives an exact"
X          " result\n";
X  cout << "\nUniform grid [" << s*ia << ':' << s*ib << "] with the step " << s << endl;
X
X  Vector y(ia,ib);
X  Vector y_int(ia,ib);
X
X  register int i;
X  for(i=y.q_lwb(); i<=y.q_upb(); i++)
X    y(i) = (*F)(s*i);
X
X  for(i=y_int.q_lwb(); i<=y_int.q_upb(); i++)
X    y_int(i) = ali(s*i,s*ia,s,y);
X
X  assert(y == y_int);
X
X  cout << "\nDone\n";
X}
X
X			// Check the precision for interpolation
X			// at arbitrary points
Xstatic void test_u(const double s, const int ia, const int ib)
X{
X  cout << "\nCheck the precision of the interpolation at arbitrary points\n";
X  cout << "\nUniform grid [" << s*ia << ':' << s*ib << "] with the step " << s
X       << endl;
X
X  Vector y(ia,ib);
X  register int i;
X  for(i=y.q_lwb(); i<=y.q_upb(); i++)
X    y(i) = (*F)(s*i);
X
X  cout << "\nPoint	Exact function value     Interpolated    Error\n";
X  register double q;
X  for(q=(ia-1)*s; q < (ib+2)*s; q += 1.1*s)
X  {
X    double yexact = (*F)(q);
X    double yint = ali(q,ia*s,s,y);
X    printf("%4.2g\t%12.6g\t\t%12.6g  %12.6g\n",q,yexact,yint,
X		 abs(yexact-yint));
X  }
X
X  cout << "\nDone\n";
X}
X
X/*
X *------------------------------------------------------------------------
X *	Set of tests for the interpolation over the non-uniform grid
X */
X
X			// Verify that interpolation exactly at a node
X			// really gives the function value at the node
Xstatic void test_n_exact(const Vector& x)
X{
X  cout << "\nCheck to see that interpolation at a node gives an exact"
X          " result\n";
X
X  Vector y(x);
X  Vector y_int(x);
X
X  register int i;
X  for(i=y.q_lwb(); i<=y.q_upb(); i++)
X    y(i) = (*F)(x(i));
X
X  for(i=y_int.q_lwb(); i<=y_int.q_upb(); i++)
X    y_int(i) = ali(x(i),x,y);
X
X  assert(y == y_int);
X
X  cout << "\nDone\n";
X}
X
X			// Check the precision for interpolation
X			// at arbitrary points
Xstatic void test_n(const Vector& x,const double s, const int ia, const int ib)
X{
X  cout << "\nCheck the precision of the interpolation at arbitrary points\n";
X
X  Vector y(x);
X  register int i;
X  for(i=y.q_lwb(); i<=y.q_upb(); i++)
X    y(i) = (*F)(x(i));
X
X  cout << "\nPoint	Exact function value     Interpolated    Error\n";
X  register double q;
X  for(q=ia*s; q < ib*s; q += s)
X  {
X    double yexact = (*F)(q);
X    double yint = ali(q,x,y);
X    printf("%4.2g\t%12.6g\t\t%12.6g  %12.6g\n",q,yexact,yint,
X		 abs(yexact-yint));
X  }
X
X  cout << "\nDone\n";
X}
X
X			// Check the precision for interpolation
X			// on example in the book
Xstatic void test_n_book(void)
X{
X  cout << "\nCheck the precision of the interpolation at arbitrary points\n";
X  cout << "\nExample from Fig. 4.11 of the book"
X          "\n\tNumerical Methods and Software,"
X	  "\n\tby D.Kahaner, C.Moler, and S.Nash - Prentice Hall, 1989\n";
X
X  REAL xy[2][11] =
X  { {0,  2,  3,  5,  6,  8,  9,    11, 12, 14, 15},	// abscissae
X    {10, 10, 10, 10, 10, 10, 10.5, 15, 50, 60, 85}	// ordinates
X  };
X
X  Vector x(0,sizeof(xy[0])/sizeof(xy[0][0])-1);
X  Vector y(x);
X  register int i;
X
X  for(i=0; i<sizeof(xy[0])/sizeof(xy[0][0]); i++)
X    x(i) = xy[0][i], y(i) = xy[1][i];
X
X  cout << "\n\t\tInterpolation nots";
X  cout << "\nx ";
X  for(i=x.q_lwb(); i<=x.q_upb(); i++)
X    printf("%6.2g ",x(i));
X  cout << "\ny ";
X  for(i=y.q_lwb(); i<=y.q_upb(); i++)
X    printf("%6.2g ",y(i));
X
X  cout << "\n\nPoint	Interpolated value\n";
X  register double q;
X  for(q=0; q <= 16; q += 16/50.)
X    printf("%7.4g   %12.6g\n",q,ali(q,x,y));
X
X  cout << "\nDone\n";
X}
X
X/*
X *------------------------------------------------------------------------
X *				Root module
X */
X
Xmain()
X{
X  cout << "\n\n\t\tVerification of the Aitken-Lagrange interpolation\n";
X
X  cout << "\n------------- Interpolation over the table with uniform grid";
X
X  cout << "\nFunction to interpolate: exp(-x)\n";
X  F = f_exp;
X
X  const double s = 0.1;
X  test_u_exact(s,1,10);
X  test_u(s,1,10);
X
X  printf("\n------------- Interpolation over the table with non-uniform grid");
X
X  printf("\nFunction to interpolate: sin(x) * exp(-x/10)\n");
X  F = f_sinexp;
X
X  register int i;
X  Vector nodes(2,51);
X  for(i=nodes.q_lwb(); i<=11; i++)
X    nodes(i) = (i-1.)/10;
X  for(i=12; i<=nodes.q_upb(); i++)
X    nodes(i) = (i-6.)/5;
X  cout << "\nGrids 0.1 .. 1 have the mesh 0.1, and 1..9 have the mesh 0.2\n";
X
X  test_n_exact(nodes);
X  test_n(nodes,0.27,0,15);
X  test_n_book();
X}
________This_Is_The_END________
if test `wc -l < vali.cc` -ne 203; then
echo 'shar: vali.cc was damaged during transit (should have had 203 lines)'
fi


echo 'x - vector.cc'
sed 's/^X//' << '________This_Is_The_END________' > vector.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *			Linear Algebra Package
X *
X *		Basic Linear Algebra operations, level 1 & 2
X *		     concerning specifically vectors
X *
X * The present file is concerned with the operations which either
X *	- specifically defined for vectors, such as norms
X * 	- some BLAS 1 & 2 operations that can be implemented more 
X *	  efficiently than generic operations on n*1 matrices
X *
X * $Id: vector.cc,v 3.0 1995/01/04 15:49:34 oleg Exp $
X *
X ************************************************************************
X */
X
X#include "LinAlg.h"
X#include <math.h>
X#include "builtin.h"
X
X/*
X *------------------------------------------------------------------------
X *		       Specific vector constructors
X */
X
X#include <stdarg.h>
X			// Make a vector and assign initial values
X			// Argument list should contain DOUBLE values
X			// to assign to vector elements. The list must
X			// be terminated by the string "END"
X			// Example: Vector foo(1,3,0.0,1.0,1.5,"END");
XVector::Vector(const int lwb, const int upb, double iv1, ... )
X  : Matrix(lwb,upb,1,1)
X{
X  va_list args;
X  va_start(args,iv1);			// Init 'args' to the beginning of
X					// the variable length list of args
X  register int i;
X  (*this)(lwb) = iv1;
X  for(i=lwb+1; i<=upb; i++)
X    (*this)(i) = (double)va_arg(args,double);
X
X  assure( strcmp((char *)va_arg(args,char *),"END") == 0,
X	 "Vector: argument list must be terminated by \"END\" ");
X}
X
X				// Resize the vector for a specified number
X				// of elements, trying to keep intact as many
X				// elements of the old vector as possible.
X				// If the vector is expanded, the new elements
X				// will be zeroes
Xvoid Vector::resize_to(const int lwb, const int upb)
X{
X  is_valid();
X  const int old_nrows = nrows;
X  assure( (nrows = upb-lwb+1) > 0,
X	 "can't resize vector to a non-positive number of elems" );
X
X  row_lwb = lwb;
X  if( old_nrows == nrows )
X    return;					// The same number of elems
X
X  nelems = nrows;
X
X				// If the vector is to grow, reallocate
X				// and clear the newly added elements
X  if( nrows > old_nrows )
X    elements = (REAL *)realloc(elements,nelems*sizeof(REAL)),
X    memset(elements+old_nrows,0,(nrows-old_nrows)*sizeof(REAL));
X
X				// Vector is to shrink a lot (more than
X				// 7/8 of the original size), reallocate
X  else if( old_nrows - nrows > (old_nrows>>3) )
X    elements = (REAL *)realloc(elements,nelems*sizeof(REAL));
X
X				// If the vector shrinks only a little, don't
X				// bother reallocate
X  assert( elements != 0 );
X}
X
X/*
X *------------------------------------------------------------------------
X *			Computing Vector norms
X */
X
X				// Compute the 1-norm of the vector
X				// SUM{ |v[i]| }
Xdouble Vector::norm_1(void) const
X{
X  is_valid();
X
X  register double norm = 0;
X  register REAL * vp;
X
X  for(vp = elements; vp < elements + nelems; )
X    norm += ::abs(*vp++);
X
X  return norm;
X}
X
X				// Compute the square of the 2-norm
X				// SUM{ v[i]^2 }
Xdouble Vector::norm_2_sqr(void) const
X{
X  is_valid();
X
X  register double norm = 0;
X  register REAL * vp;
X
X  for(vp = elements; vp < elements + nelems; )
X    norm += ::sqr(*vp++);
X
X  return norm;
X}
X				// Compute the infinity-norm of the vector
X				// MAX{ |v[i]| }
Xdouble Vector::norm_inf(void) const
X{
X  is_valid();
X
X  register double norm = 0;
X  register REAL * vp;
X
X  for(vp = elements; vp < elements + nelems; )
X    norm = ::max(norm,::abs(*vp++));
X
X  return norm;
X}
X
X/*
X *------------------------------------------------------------------------
X *		Multiplications specifically defined for vectors
X */
X
X				// Compute the scalar product
Xdouble operator * (const Vector& v1, const Vector& v2)
X{
X  are_compatible(v1,v2);
X  register REAL * v1p = v1.elements;
X  register REAL * v2p = v2.elements;
X  register double sum = 0;
X
X  while( v1p < v1.elements + v1.nelems )
X    sum += *v1p++ * *v2p++;
X
X  return sum;
X}
X
X					// "Inplace" multiplication
X					// target = A*target
X					// A needn't be a square one (the
X					// target will be resized to fit)
XVector& Vector::operator *= (const Matrix& A)
X{
X  A.is_valid();
X  is_valid();
X
X  if( A.ncols != nrows || A.col_lwb != row_lwb )
X    A.info(), info(),
X    _error("matrices and vector above cannot be multiplied");
X
X  const int old_nrows = nrows;
X  const REAL * old_vector = elements;	// Save the old vector elem
X  row_lwb = A.row_lwb;
X  assert( (nrows = A.nrows) > 0 );
X
X  nelems = nrows;			// Allocate new vector elements
X  assert( (elements = (REAL *)malloc(nelems*sizeof(REAL))) != 0 );
X
X  register REAL * tp = elements;	// Target vector ptr
X  register REAL * mp = A.elements;	// Matrix row ptr
X  while( tp < elements + nelems )
X  {
X    register double sum = 0;
X    for( register const REAL * sp = old_vector; sp < old_vector + old_nrows; )
X      sum += *sp++ * *mp, mp += A.nrows;
X    *tp++ = sum;
X    mp -= A.nelems -1;			// mp points to the beg of the next row
X  }
X  assert( mp == A.elements + A.nrows );
X
X  free((REAL *)old_vector);
X  return *this;
X}
X
________This_Is_The_END________
if test `wc -l < vector.cc` -ne 188; then
echo 'shar: vector.cc was damaged during transit (should have had 188 lines)'
fi


echo 'x - vfminbr.cc'
sed 's/^X//' << '________This_Is_The_END________' > vfminbr.cc
X// This may look like C code, but it is really -*- C++ -*-
X//
X//			Verify FMINBR routine
X
X
X#include "math_num.h"
X#include <iostream.h>
X
Xstatic int counter;			// Iteration counter
X
X			// Run a test
Xstatic void test
X  (const double a, const double b, double (*f)(const double x), const char *msg)
X{
X  double minloc;
X  counter = 0;
X  printf("\nFor function %s\nthe minimum over [%g,%g] is found"
X	       " to be at\t%.9e\n",msg,a,b,
X	       (minloc=fminbr(a,b,f)) );
X  printf("Min function value found\t%.4e\nNo. of iterations\t\t%d\n",
X	       (*f)(minloc), counter);
X}
X
Xstatic double f1(const double x)		// Test from the Forsythe book
X{
X  counter++;
X  return (sqr(x)-2)*x - 5;
X}
X
Xstatic double f2(const double x)		// Modified test 1
X{
X  counter++;
X  return sqr( (sqr(x)-2)*x - 5 );
X}
X
Xstatic double f3(const double x)
X{
X  counter++;
X  return sqr( cos(x) - x ) - 2;
X}
X
Xstatic double f4(const double x)
X{
X  counter++;
X  return sqr( sin(x) - x ) + 1;
X}
X
X
Xmain(void)
X{
X  cout << "\n\n" << _Minuses <<
X          "\n\t\tTesting the Brent's one-dimensional minimizer\n\n";
X
X  test(0.0,1.0,f1,"x^3 - 2*x - 5");
X  cout << "Exact min is at\t\t0.81650\n";
X
X  test(2.0,3.0,f2,"(x^3 - 2*x - 5)^2");
X  cout << "Exact root is \t\t2.0945514815\n";
X
X  test(2.0,3.0,f3,"(cos(x)-x)^2 - 2");
X  test(-1.0,3.0,f3,"(cos(x)-x)^2 - 2");
X  test(-1.0,3.0,f4,"(sin(x)-x)^2 + 1");
X}
X
________This_Is_The_END________
if test `wc -l < vfminbr.cc` -ne 64; then
echo 'shar: vfminbr.cc was damaged during transit (should have had 64 lines)'
fi


echo 'x - vhjmin.cc'
sed 's/^X//' << '________This_Is_The_END________' > vhjmin.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *		   Verify the Hook-Jeevse minimization
X *
X ************************************************************************
X */
X
X#include "LinAlg.h"
X#include "math_num.h"
X#include "builtin.h"
X#include <iostream.h>
X
X
Xstatic int iter_count;
X
X/*
X *-----------------------------------------------------------------------
X * 			Simplified vector print
X */
X
Xstatic void pr_vector(Vector& v)
X{
X  register int i;
X  for(i=v.q_lwb(); i<=v.q_upb(); i++)
X     printf("%9.3g  ",v(i));
X}
X
X
X/*
X *------------------------------------------------------------------------
X *			  Rosenbroke function
X */
X
Xstatic double f1(const Vector& v)
X{
X  register double x1 = v(1);
X  register double x2 = v(2);
X  iter_count++;
X  return 100*sqr(x2 - x1*x1) + sqr(1 - x1);
X}
X 
Xstatic void test1()
X{
X  const int n = 2;
X  Vector b0(1,n,-1.2,1.,"END");			// Initial guess
X  Vector b = b0;				// Min location found
X  Vector bm(1,n,1.0,1.0,"END");			// Exact min location
X  Vector h(1,n,10.,10.,"END");			// Initial step
X
X  iter_count = 0;
X  cout << "\n\n\tRosenbroke function\n";
X  cout << "\n\n\tf = 100*(x2-x1^2)^2 + (1-x1)^2\n\n";
X  cout << "\nInitial guess         b0 = "; pr_vector(b0);
X  cout << "\nFunction value at it  f0 = " << f1(b0);
X  cout << "\nInitial steps         h0 = "; pr_vector(h);
X  cout << "\n";
X  cout << "\nMinimum f value found f  = " << hjmin(b,h,f1);
X  cout << "\n                  at  b  = "; pr_vector(b);
X  cout << "\nFinal steps           h = "; pr_vector(h);
X  cout << "\nExact min location    bm = "; pr_vector(bm);
X  cout << "\nNo. of iterations     ni = " << iter_count << "\n";
X
X}
X
X
X
X/*
X *------------------------------------------------------------------------
X *			     Bocks function
X */
X
Xstatic double f2(const Vector& v)
X{
X  register double x1 = v(1);
X  register double x2 = v(2);
X  iter_count++;
X  return sqr( exp(-1./10) - exp(-x1/10) + exp(-10./10) - exp(-x2/10) );
X}
X 
Xstatic void test2()
X{
X  const int n = 2;
X  Vector b0(1,n,0.,0.,"END");			// Initial guess
X  Vector b =b0;					// Min location found
X  Vector bm(1,n,10.0,1.0,"END");		// Exact min location
X  double h0=10;					// Initial step
X
X  iter_count = 0;
X  cout << "\n\n\tBocks function\n";
X  cout << "\n\n\t"
X	  "f = [ exp(-1/10) - exp(-x1/10) + exp(-10/10) -exp(-x2/10) ]^2\n\n";
X  cout << "\nInitial guess         b0 = "; pr_vector(b0);
X  cout << "\nFunction value at it  f0 = " << f2(b0);
X  cout << "\nInitial steps         h0 = " << h0;
X  cout << "\n";
X  cout << "\nMinimum f value found f  = " << hjmin(b,h0,f2);
X  cout << "\n                  at  b  = "; pr_vector(b);
X  cout << "\nExact min location    bm = "; pr_vector(bm);
X  cout << "\nNo. of iterations     ni = " << iter_count << "\n";
X
X}
X
X
X
X/*
X *------------------------------------------------------------------------
X *			Mile & Cuntrell function
X */
X
Xstatic double f3(const Vector& v)
X{
X  register double x1 = v(1);
X  register double x2 = v(2);
X  register double x3 = v(3);
X  register double x4 = v(4);
X  iter_count++;
X  return pow( exp(x1)-x2, 4L) + 100*pow(x2-x3,6L) + pow(atan(x3-x4),4L) +
X	 pow(x1,8L);
X}
X 
Xstatic void test3()
X{
X  const int n = 4;
X  Vector b0(1,n,1.,2.,2.,2.,"END");		// Initial guess
X  Vector b = b0;					// Min location found
X  Vector bm(1,n,0.,1.,1.,1.,"END");		// Exact min location
X  double h0 = 10;				// Initial step
X
X  iter_count = 0;
X  cout << "\n\n\tMile & Cuntrell function\n";
X  cout << "\n\n\t"
X	  "f = [ exp(x1)-x2 ]^4 +100(x2-x3)^6 + atan(x3-x4)^4 + x1^8\n\n";
X  cout << "\nInitial guess         b0 = "; pr_vector(b0);
X  cout << "\nFunction value at it  f0 = " << f3(b0);
X  cout << "\nInitial steps         h0 = " << h0;
X  cout << "\n";
X  cout << "\nMinimum f value found f  = " << hjmin(b,h0,f3);
X  cout << "\n                  at  b  = "; pr_vector(b);
X  cout << "\nExact min location    bm = "; pr_vector(bm);
X  cout << "\nNo. of iterations     ni = " << iter_count << "\n";
X
X}
X
X/*
X *------------------------------------------------------------------------
X *			  Powell function
X */
X
Xstatic double f4(const Vector& v)
X{
X  register double x1 = v(1);
X  register double x2 = v(2);
X  register double x3 = v(3);
X  register double x4 = v(4);
X  iter_count++;
X  return sqr(x1+10*x2) + 5*sqr(x3-x4) + pow(x2-2*x3,4L) + 10*pow(x1-x4,4L);
X}
X 
Xstatic void test4()
X{
X  const int n = 4;
X  Vector b0(1,n,3.,-1.,0.,1.,"END");		// Initial guess
X  Vector b = b0;				// Min location found
X  Vector bm(1,n,0.,0.,0.,0.,"END");		// Exact min location
X  Vector h0(1,n,10.,10.,10.,10.,"END");		// Initial step
X
X  iter_count = 0;
X  cout << "\n\n\tPowell function\n";
X  cout << "\n\n\t" 
X	  "f = (x1+10*x2)^2 + 5(x3-x4)^2 + (x2-2x3)^4 + 10(x1-x4)^4\n\n";
X  cout << "\nInitial guess         b0 = "; pr_vector(b0);
X  cout << "\nFunction value at it  f0 = " << f4(b0);
X  cout << "\nInitial steps         h0 = "; pr_vector(h0);
X  cout << "\n";
X  cout << "\nMinimum f value found f  = " << hjmin(b,h0,f4);
X  cout << "\n                  at  b  = "; pr_vector(b);
X  cout << "\nExact min location    bm = "; pr_vector(bm);
X  cout << "\nNo. of iterations     ni = " << iter_count << "\n";
X
X}
X
X
X/*
X *------------------------------------------------------------------------
X *				Root module
X */
X
Xmain()
X{
X  cout << "\n\n\n\t\tVerify HJMIN multidimensional minimizer\n";
X  test1();
X  test2();
X  test3();
X  test4();
X}
X
________This_Is_The_END________
if test `wc -l < vhjmin.cc` -ne 198; then
echo 'shar: vhjmin.cc was damaged during transit (should have had 198 lines)'
fi


echo 'x - vmatrix.cc'
sed 's/^X//' << '________This_Is_The_END________' > vmatrix.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *		  Verify Primitive Operations on Matrices
X *	(creation, special cases and element-by-element operations)
X *
X *
X * $Id: vmatrix.cc,v 3.1 1995/02/03 15:24:27 oleg Exp oleg $
X *
X ************************************************************************
X */
X
X#include "LinAlg.h"
X#include "builtin.h"
X#include <math.h>
X#include <iostream.h>
X#include <float.h>
X
X/*
X *------------------------------------------------------------------------
X *	   Test allocation functions and compatibility check
X */
X
Xstatic void test_allocation(void)
X{
X
X  cout << "\n\n---> Test allocation and compatibility check\n";
X
X  Matrix m1(4,20);	m1.set_name("Matrix m1");
X  Matrix m2(1,4,1,20);	m2.set_name("Matrix m2");
X  Matrix m3(1,4,0,19);	m3.set_name("Matrix m3");
X  Matrix m4(m1);	m4.set_name("Matrix m4");
X  cout << "The following matrices have been allocated\n";
X  m1.info(), m2.info(), m3.info(), m4.info();
X
X  cout << "\nStatus information reported for matrix m3:\n";
X  cout << "  Row lower bound ... " << m3.q_row_lwb() << "\n";
X  cout << "  Row upper bound ... " << m3.q_row_upb() << "\n";
X  cout << "  Col lower bound ... " << m3.q_col_lwb() << "\n";
X  cout << "  Col upper bound ... " << m3.q_col_upb() << "\n";
X  cout << "  No. rows ..........." << m3.q_nrows() << "\n";
X  cout << "  No. cols ..........." << m3.q_ncols() << "\n";
X  cout << "  No. of elements ...." << m3.q_no_elems() << "\n";
X  cout << "  Name " << m3.q_name() << "\n";
X
X  cout << "\nCheck matrices 1 & 2 for compatibility\n";
X  are_compatible(m1,m2);
X
X  cout << "Check matrices 1 & 4 for compatibility\n";
X  are_compatible(m1,m4);
X
X#if 0
X  cout << "Check matrices 1 & 3 for compatibility\n";
X  are_compatible(m1,m3);
X#endif
X
X  cout << "m2 has to be compatible with m3 after resizing to m3\n";
X  m2.resize_to(m3);
X  are_compatible(m2,m3);
X
X  Matrix m5(m1.q_nrows()+1,m1.q_ncols()+5); m5.set_name("Matrix m5");
X  cout << "m1 has to be compatible with m5 after resizing to m5\n";
X  m5.info();
X  m1.resize_to(m5.q_nrows(),m5.q_ncols());
X  are_compatible(m1,m5);
X
X}
X
X/*
X *------------------------------------------------------------------------
X *		     Test uniform element operations
X */
X
Xstatic void test_element_op(const int rsize, const int csize)
X{
X  const double pattern = 8.625;
X  register int i,j;
X
X  cout << "\n\n---> Test operations that treat each element uniformly\n";
X
X  Matrix m(-1,rsize-2,1,csize);
X
X  cout << "Writing zeros to m...\n";
X  for(i=m.q_row_lwb(); i<=m.q_row_upb(); i++)
X    for(j=m.q_col_lwb(); j<=m.q_col_upb(); j++)
X      m(i,j) = 0;
X  verify_element_value(m,0);
X
X  cout << "Creating zero m1 ...\n";
X  Matrix m1(Matrix::Zero,m);
X  verify_element_value(m1,0);
X
X  cout << "Comparing m1 with 0 ...\n";
X  assure(m1 == 0, "m1 is not zero!");
X  assure(!(m1 != 0), "m1 is not zero!");
X
X  cout << "Writing a pattern " << pattern << " by assigning to m(i,j)...\n";
X  for(i=m.q_row_lwb(); i<=m.q_row_upb(); i++)
X    for(j=m.q_col_lwb(); j<=m.q_col_upb(); j++)
X      m(i,j) = pattern;
X  verify_element_value(m,pattern);
X
X  cout << "Writing the pattern by assigning to m1 as a whole ...\n";
X  m1 = pattern;
X  verify_element_value(m1,pattern);
X
X  cout << "Comparing m and m1 ...\n";
X  assure(m == m1, "m and m1 are unexpectedly different!");
X  cout << "Comparing (m=0) and m1 ...\n";
X  assert(!(m.clear() == m1));
X
X  cout << "Clearing m1 ...\n";
X  m1.clear();
X  verify_element_value(m1,0);
X
X  cout << "\nClear m and add the pattern\n";
X  m.clear();
X  m += pattern;
X  verify_element_value(m,pattern);
X  cout << "   add the doubled pattern with the negative sign\n";
X  m += -2*pattern;
X  verify_element_value(m,-pattern);
X  cout << "   subtract the trippled pattern with the negative sign\n";
X  m -= -3*pattern;
X  verify_element_value(m,2*pattern);
X
X  cout << "\nVerify comparison operations when all elems are the same\n";
X  m = pattern;
X  assert( m == pattern && !(m != pattern) );
X  assert( m > 0 && m >= pattern && m <= pattern );
X  assert( m > -pattern && m >= -pattern );
X  assert( m <= pattern && !(m < pattern) );
X  m -= 2*pattern;
X  assert( m  < -pattern/2 && m <= -pattern/2 );
X  assert( m  >= -pattern && !(m > -pattern) );
X
X  cout << "\nVerify comparison operations when not all elems are the same\n";
X  m = pattern; m(m.q_row_upb(),m.q_col_upb()) = pattern-1;
X  assert( !(m == pattern) && !(m != pattern) );
X  assert( m != 0 ); 		// none of elements are 0
X  assert( !(m >= pattern) && m <= pattern && !(m<pattern) );
X  assert( !(m <= pattern-1) && m >= pattern-1 && !(m>pattern-1) );
X
X  cout << "\nAssign 2*pattern to m by repeating additions\n";
X  m = 0; m += pattern; m += pattern;
X  cout << "Assign 2*pattern to m1 by multiplying by two \n";
X  m1 = pattern; m1 *= 2;
X  verify_element_value(m1,2*pattern);
X  assert( m == m1 );
X  cout << "Multiply m1 by one half returning it to the 1*pattern\n";
X  m1 *= 1/2.;
X  verify_element_value(m1,pattern);
X
X  cout << "\nAssign -pattern to m and m1\n";
X  m.clear(); m -= pattern; m1 = -pattern;
X  verify_element_value(m,-pattern);
X  assert( m == m1 );
X  cout << "m = sqrt(sqr(m)); m1 = abs(m1); Now m and m1 have to be the same\n";
X  m.sqr();
X  verify_element_value(m,pattern*pattern);
X  m.sqrt();
X  verify_element_value(m,pattern);
X  m1.abs();
X  verify_element_value(m1,pattern);
X  assert( m == m1 );
X
X  cout << "\nCheck out to see that sin^2(x) + cos^2(x) = 1\n";
X  class FillMatrix : public ElementAction
X  {
X    int no_elems, no_cols;
X    void operation(REAL& element)
X		{ element = 4*M_PI/no_elems * (i*no_cols+j); }
X    public: FillMatrix(const Matrix& m) :
X			no_elems(m.q_no_elems()), no_cols(m.q_ncols()) {}
X  };
X  m.apply(FillMatrix(m));
X  m1 = m;
X  class ApplyFunction : public ElementPrimAction
X  {
X    double (*func)(const double x);
X    void operation(REAL& element) { element = func(element); }
X    public: ApplyFunction(double (*_func)(const double x)) : func(_func) {}
X  };
X  m.apply(ApplyFunction(sin));
X  m1.apply(ApplyFunction(cos));
X  m.sqr();
X  m1.sqr();
X  m += m1;
X  verify_element_value(m,1);
X
X  cout << "\nDone\n\n";
X}
X
X/*
X *------------------------------------------------------------------------
X *  		Test binary matrix element-by-element operations
X */
X
Xstatic void test_binary_ebe_op(const int rsize, const int csize)
X{
X  const double pattern = 4.25;
X  register int i,j;
X
X  cout << "\n---> Test Binary Matrix element-by-element operations\n";
X
X  Matrix m(2,rsize+1,0,csize-1);
X  Matrix m1(Matrix::Zero,m);
X  Matrix mp(Matrix::Zero,m);
X
X  for(i=mp.q_row_lwb(); i<=mp.q_row_upb(); i++)
X    for(j=mp.q_col_lwb(); j<=mp.q_col_upb(); j++)
X      mp(i,j) = (i-m.q_nrows()/2.)*j*pattern;
X  
X
X  cout << "\nVerify assignment of a matrix to the matrix\n";
X  m = pattern;
X  m1.clear();
X  m1 = m;
X  verify_element_value(m1,pattern);
X  assert( m1 == m );
X
X  cout << "\nAdding the matrix to itself, uniform pattern " << pattern << "\n";
X  m.clear(); m = pattern;
X  m1 = m; m1 += m1;
X  verify_element_value(m1,2*pattern);
X  cout << "  subtracting two matrices ...\n";
X  m1 -= m;
X  verify_element_value(m1,pattern);
X  cout << "  subtracting the matrix from itself\n";
X  m1 -= m1;
X  verify_element_value(m1,0);
X  cout << "  adding two matrices together\n";
X  m1 += m;
X  verify_element_value(m1,pattern);
X
X  cout << "\nArithmetic operations on matrices with not the same elements\n";
X  cout << "   adding mp to the zero matrix...\n";
X  m.clear(); m += mp;
X  verify_matrix_identity(m,mp);
X  m1 = m;
X  cout << "   making m = 3*mp and m1 = 3*mp, via add() and succesive mult\n";
X  add(m,2,mp);
X  m1 += m1; m1 += mp;
X  verify_matrix_identity(m,m1);
X  cout << "   clear both m and m1, by subtracting from itself and via add()\n";
X  m1 -= m1;
X  add(m,-3,mp);
X  verify_matrix_identity(m,m1);
X
X  cout << "\nTesting element-by-element multiplications and divisions\n";
X  cout << "   squaring each element with sqr() and via multiplication\n";
X  m = mp; m1 = mp;
X  m.sqr();
X  element_mult(m1,m1);
X  verify_matrix_identity(m,m1);
X  cout << "   compare (m = pattern^2)/pattern with pattern\n";
X  m = pattern; m1 = pattern;
X  m.sqr();
X  element_div(m,m1);
X  verify_element_value(m,pattern);
X  compare(m1,m,"Original vector and vector after squaring and dividing");
X
X  cout << "\nDone\n";
X}
X
X/*
X *------------------------------------------------------------------------
X *		       Verify matrix transposition
X */
X
Xstatic void test_transposition(const int msize)
X{
X  cout << "\n---> Verify matrix transpose\n"
X          "for matrices of a characteristic size " << msize << endl;
X
X  {
X    cout << "\nCheck to see that a square UnitMatrix' stays the same";
X    Matrix m(msize,msize);
X    m.unit_matrix();
X    Matrix mt(Matrix::Transposed,m);
X    assert( m == mt );
X  }
X  
X  {
X    cout << "\nTest a non-square UnitMatrix";
X    Matrix m(msize,msize+1);
X    m.unit_matrix();
X    Matrix mt(Matrix::Transposed,m);
X    assert( m.q_nrows() == mt.q_ncols() && m.q_ncols() == mt.q_nrows() );
X    register int i,j;
X    for(i=m.q_row_lwb(); i<=min(m.q_row_upb(),m.q_col_upb()); i++)
X      for(j=m.q_col_lwb(); j<=min(m.q_row_upb(),m.q_col_upb()); j++)
X	assert( m(i,j) == mt(i,j) );
X  }
X
X  {
X    cout << "\nCheck to see that a symmetric (Hilbert)Matrix' stays the same";
X    Matrix m(msize,msize);
X    m.hilbert_matrix();
X    Matrix mt(Matrix::Transposed,m);
X    assert( m == mt );
X  }
X
X  {
X    cout << "\nCheck transposing a non-symmetric matrix";
X    Matrix m(msize+1,msize);
X    m.hilbert_matrix();
X    m(1,2) = M_PI;
X    Matrix mt(Matrix::Transposed,m);
X    assert( m.q_nrows() == mt.q_ncols() && m.q_ncols() == mt.q_nrows() );
X    assert( mt(2,1) == (REAL)M_PI && mt(1,2) != (REAL)M_PI );
X
X    cout << "\nCheck double transposing a non-symmetric matrix";
X    Matrix mtt(Matrix::Transposed,mt);
X    assert( m == mtt );
X  }
X
X  cout << "\nDone\n";
X}
X
X/*
X *------------------------------------------------------------------------
X *			Test special matrix creation
X */
X
Xstatic void test_special_creation(const int dim)
X{
X  cout << "\n---> Check creating some special matrices of dimension " <<
X    dim << "\n\n";
X
X  {
X    cout << "test creating Hilbert matrices" << endl;
X    Matrix m(dim+1,dim);
X    Matrix m1(Matrix::Zero,m);
X    m.hilbert_matrix();
X    assert( !(m == m1) );
X    assert( m != 0 );
X    class MakeHilbert : public ElementAction
X    {
X      void operation(REAL& element) { element = 1./(i+j-1); }
X      public: MakeHilbert(void) {}
X    };
X    m1.apply(MakeHilbert());
X    assert( m1 != 0 );
X    assert( m == m1 );
X  }
X
X  {
X    cout << "test creating zero matrix and copy constructor" << endl;
X    Matrix m(dim,dim+1);
X    m.hilbert_matrix();
X    assert( m != 0 );
X    Matrix m1(m);			// Applying the copy constructor
X    assert( m1 == m );
X    Matrix m2(Matrix::Zero,m);
X    assert( m2 == 0 );
X    assert( m != 0 );
X  }
X
X  {
X    cout << "test creating unit matrices" << endl;
X    class TestUnit : public ElementAction
X    {
X      int is_unit;
X      void operation(REAL& element)
X      { if( is_unit ) is_unit = i==j ? element == 1.0 : element == 0; }
X      public: TestUnit(void) : is_unit(0==0) {}
X      int is_indeed_unit(void) const 		{ return is_unit; }
X    };
X    Matrix m(dim,dim);
X    {
X      TestUnit test_unit;
X      m.apply(test_unit);
X      assert( !test_unit.is_indeed_unit() );
X    }
X    m.unit_matrix();
X    {
X      TestUnit test_unit;
X      m.apply(test_unit);
X      assert( test_unit.is_indeed_unit() );
X    }
X    m.resize_to(dim-1,dim);
X    Matrix m2(Matrix::Unit,m);
X    {
X      TestUnit test_unit;
X      m2.apply(test_unit);
X      assert( test_unit.is_indeed_unit() );
X    }
X    m.resize_to(dim,dim-2);
X    m.unit_matrix();
X    {
X      TestUnit test_unit;
X      m.apply(test_unit);
X      assert( test_unit.is_indeed_unit() );
X    }
X  }
X
X  {
X    cout << "check to see that Haar matrix has *exactly* orthogonal columns"
X					<< endl;
X    const int order = 5;
X    Matrix haar = haar_matrix(order);
X    assert( haar.q_nrows() == (1<<order) && haar.q_nrows() == haar.q_ncols() );
X    Vector colj(1<<order), coll(1<<order);
X    register int j;
X    for(j=haar.q_col_lwb(); j<=haar.q_col_upb(); j++)
X    {
X      colj = MatrixColumn(haar,j);
X      assert( fabs(abs(colj*colj - 1.0)) <= FLT_EPSILON );
X      for(register int l=j+1; l<=haar.q_col_upb(); l++)
X      {
X	coll = MatrixColumn(haar,l);
X	assert( colj*coll == 0 );
X      }
X    }
X    cout << "make Haar (sub)matrix and test it *is* a submatrix" << endl;
X    const int no_sub_cols = (1<<order) - 3;
X    Matrix haar_sub = haar_matrix(order,no_sub_cols);
X    assert( haar_sub.q_nrows() == (1<<order) && 
X	    haar_sub.q_ncols() == no_sub_cols );
X    for(j=haar_sub.q_col_lwb(); j<=haar_sub.q_col_upb(); j++)
X    {
X      colj = MatrixColumn(haar,j);
X      coll = MatrixColumn(haar_sub,j);
X      verify_matrix_identity(colj,coll);
X    }
X  }
X
X  cout << "\nDone\n";
X}
X
X
Xstatic void test_matrix_promises(const int dim)
X{
X  cout << "\n---> Check making/forcing promises, (lazy)matrices of dimension " <<
X    dim << "\n\n";
X
X  class hilbert_matrix_promise : public LazyMatrix
X  {
X    void fill_in(Matrix& m) const { m.hilbert_matrix(); }
X  public:
X    hilbert_matrix_promise(const int nrows, const int ncols)
X	: LazyMatrix(nrows,ncols) {}
X    hilbert_matrix_promise(const int _row_lwb, const int _row_upb,
X	     const int _col_lwb, const int _col_upb)
X	: LazyMatrix(_row_lwb,_row_upb,_col_lwb,_col_upb) {}
X  };
X  
X  {
X    cout << "make a promise and force it by a constructor" << endl;
X    Matrix m = hilbert_matrix_promise(dim,dim+1);
X    Matrix m1(Matrix::Zero,m);
X    assert( !(m1 == m) && m1 == 0 );
X    m1.hilbert_matrix();
X    verify_matrix_identity(m,m1);
X  }
X  
X  {
X    cout << "make a promise and force it by an assignment" << endl;
X    Matrix m(-1,dim,0,dim);
X    Matrix m1(Matrix::Zero,m);
X    m = hilbert_matrix_promise(-1,dim,0,dim);
X    assert( !(m1 == m) && m1 == 0 );
X    m1.hilbert_matrix();
X    verify_matrix_identity(m,m1);
X  }
X
X  cout << "\nDone\n";
X}
X
X/*
X *------------------------------------------------------------------------
X *			Verify the norm calculation
X */
X
Xstatic void test_norms(const int rsize, const int csize)
X{
X  cout << "\n---> Verify norm calculations\n";
X
X  const double pattern = 10.25;
X
X  if( rsize % 2 == 1 || csize %2 == 1 )
X    _error("Sorry, size of the matrix to test must be even for this test\n");
X
X  Matrix m(rsize,csize);
X
X  cout << "\nAssign " << pattern << " to all the elements and check norms\n";
X  m = pattern;
X  cout << "  1. (col) norm should be pattern*nrows\n";
X  assert( m.norm_1() == pattern*m.q_nrows() );
X  assert( m.norm_1() == m.col_norm() );
X  cout << "  Inf (row) norm should be pattern*ncols\n";
X  assert( m.norm_inf() == pattern*m.q_ncols() );
X  assert( m.norm_inf() == m.row_norm() );
X  cout << "  Square of the Eucl norm has got to be pattern^2 * no_elems\n";
X  assert( m.e2_norm() == sqr(pattern)*m.q_no_elems() );
X  Matrix m1(Matrix::Zero,m);
X  assert( m.e2_norm() == e2_norm(m,m1) );
X
X  cout << "\nDone\n";
X}
X
X/*
X *------------------------------------------------------------------------
X *				Root module
X */
X
Xmain()
X{
X  cout << "\n\n" << _Minuses << 
X          "\n\t\tVerify Operations on Matrices\n";
X
X  test_allocation();
X  test_element_op(20,10);
X  test_binary_ebe_op(10,20);
X  test_norms(40,20);
X  test_special_creation(20);
X  test_matrix_promises(20);
X  test_transposition(20);
X}
X
________This_Is_The_END________
if test `wc -l < vmatrix.cc` -ne 522; then
echo 'shar: vmatrix.cc was damaged during transit (should have had 522 lines)'
fi


echo 'x - vmatrix1.cc'
sed 's/^X//' << '________This_Is_The_END________' > vmatrix1.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *		Verify Advanced Operations on Matrices
X *	    (multiplication, inverse, determinant evaluation)
X *
X * $Id: vmatrix1.cc,v 3.1 1995/02/03 15:32:08 oleg Exp oleg $
X *
X ************************************************************************
X */
X
X#include "LinAlg.h"
X#include <math.h>
X#include "builtin.h"
X#include <iostream.h>
X#include <float.h>
X
X/*
X *------------------------------------------------------------------------
X *			Verify the determinant evaluation
X */
X
Xstatic void test_determinant(const int msize)
X{
X  cout << "\n---> Verify determinant evaluation\n"
X          "for a square matrix of size " << msize << "\n";
X
X  Matrix m(msize,msize);
X
X  cout << "\nCheck to see that the determinant of the unit matrix is one";
X  m.unit_matrix();
X  cout << "\n	determinant is " << m.determinant();
X  assert( m.determinant() == 1 );
X
X  const double pattern = 2.5;
X  cout << "\nCheck the determinant for the matrix with " << pattern <<
X          "\n	at the diagonal";
X  register int i,j;
X  for(i=m.q_row_lwb(); i<=m.q_row_upb(); i++)
X    for(j=m.q_col_lwb(); j<=m.q_col_upb(); j++)
X      m(i,j) = ( i==j ? pattern : 0 );
X  cout << "\n	determinant is " << m.determinant();
X  assert( m.determinant() == pow(pattern,(long)m.q_nrows()) );
X
X  cout << "\nCheck the determinant of the transposed matrix";
X  m.unit_matrix();
X  m(1,2) = pattern;
X  Matrix m_tran(Matrix::Transposed,m);
X  assert( !(m == m_tran) );
X  assert( m.determinant() == m_tran.determinant() );
X
X  cout << "\nCheck the determinant for the matrix with " << pattern <<
X          "\n	at the anti-diagonal";
X  for(i=m.q_row_lwb(); i<=m.q_row_upb(); i++)
X    for(j=m.q_col_lwb(); j<=m.q_col_upb(); j++)
X      m(i,j) = ( i==(m.q_col_upb()+m.q_col_lwb()-j) ? pattern : 0 );
X  assert( m.determinant() == pow(pattern,(long)m.q_nrows()) * 
X	 ( m.q_nrows()*(m.q_nrows()-1)/2 & 1 ? -1 : 1 ) );
X
X  cout << "\nCheck the determinant for the singular matrix"
X          "\n	defined as above with zero first row";
X  m.clear();
X  for(i=m.q_row_lwb()+1; i<=m.q_row_upb(); i++)
X    for(j=m.q_col_lwb(); j<=m.q_col_upb(); j++)
X      m(i,j) = ( i==(m.q_col_upb()+m.q_col_lwb()-j) ? pattern : 0 );
X  cout << "\n	determinant is " << m.determinant();
X  assert( m.determinant() == 0 );
X
X  cout << "\nCheck out the determinant of the Hilbert matrix";
X  Matrix H(3,3);
X  H.hilbert_matrix();
X  cout << "\n    3x3 Hilbert matrix: exact determinant 1/2160 ";
X  cout << "\n                              computed    1/"<< 1/H.determinant();
X
X  H.resize_to(4,4);
X  H.hilbert_matrix();
X  cout << "\n    4x4 Hilbert matrix: exact determinant 1/6048000 ";
X  cout << "\n                              computed    1/"<< 1/H.determinant();
X
X  H.resize_to(5,5);
X  H.hilbert_matrix();
X  cout << "\n    5x5 Hilbert matrix: exact determinant 3.749295e-12";
X  cout << "\n                              computed    "<< H.determinant();
X
X  H.resize_to(7,7);
X  H.hilbert_matrix();
X  cout << "\n    7x7 Hilbert matrix: exact determinant 4.8358e-25";
X  cout << "\n                              computed    "<< H.determinant();
X
X  H.resize_to(9,9);
X  H.hilbert_matrix();
X  cout << "\n    9x9 Hilbert matrix: exact determinant 9.72023e-43";
X  cout << "\n                              computed    "<< H.determinant();
X
X  H.resize_to(10,10);
X  H.hilbert_matrix();
X  cout << "\n    10x10 Hilbert matrix: exact determinant 2.16418e-53";
X  cout << "\n                              computed    "<< H.determinant();
X
X  cout << "\nDone\n";
X}
X
X/*
X *------------------------------------------------------------------------
X *			Verify matrix multiplications
X */
X
Xstatic void test_mm_multiplications(const int msize)
X{
X  cout << "\n---> Verify matrix multiplications\n"
X          "for matrices of the characteristic size " << msize << "\n\n";
X
X  {
X    cout << "Test inline multiplications of the UnitMatrix" << endl;
X    Matrix m(-1,msize,-1,msize);
X    Matrix u(Matrix::Unit,m);
X    m.hilbert_matrix(); m(3,1) = M_PI;
X    u *= m;
X    verify_matrix_identity(u,m);
X  }
X
X  {
X    cout << "Test inline multiplications by a DiagMatrix" << endl;
X    Matrix m(msize+3,msize);
X    m.hilbert_matrix(); m(1,3) = M_PI;
X    Vector v(msize);
X    register int i;
X    for(i=v.q_lwb(); i<=v.q_upb(); i++)
X      v(i) = 1+i;
X    Matrix diag(msize,msize);
X    (MatrixDiag)diag = v;
X    Matrix eth = m;
X    for(i=eth.q_row_lwb(); i<=eth.q_row_upb(); i++)
X      for(register int j=eth.q_col_lwb(); j<=eth.q_col_upb(); j++)
X	eth(i,j) *= v(j);
X    m *= diag;
X    verify_matrix_identity(m,eth);
X  }
X
X  {
X    cout << "Test XPP = X where P is a permutation matrix\n";
X    Matrix m(msize-1,msize);
X    m.hilbert_matrix(); m(2,3) = M_PI;
X    Matrix eth = m;
X    Matrix p(msize,msize);
X    for(register int i=p.q_row_lwb(); i<=p.q_row_upb(); i++)
X      p(p.q_row_upb()+p.q_row_lwb()-i,i) = 1;
X    m *= p;
X    m *= p;
X    verify_matrix_identity(m,eth);
X  }
X
X  {
X    cout << "Test general matrix multiplication through inline mult" << endl;
X    Matrix m(msize-2,msize);
X    m.hilbert_matrix(); m(3,3) = M_PI;
X    Matrix mt(Matrix::Transposed,m);
X    Matrix p(msize,msize);
X    p.hilbert_matrix();
X    MatrixDiag(p) += 1;
X    Matrix mp(m,Matrix::Mult,p);
X    Matrix m1 = m;
X    m *= p;
X    verify_matrix_identity(m,mp);
X    Matrix mp1(mt,Matrix::TransposeMult,p);
X    verify_matrix_identity(m,mp1);
X    assert( !(m1 == m) );
X    Matrix mp2(Matrix::Zero,m1);
X    assert( mp2 == 0 );
X    mp2.mult(m1,p);
X    verify_matrix_identity(m,mp2);
X  }
X
X  {
X    cout << "Check to see UU' = U'U = E when U is the Haar matrix" << endl;
X    const int order = 5;
X    const int no_sub_cols = (1<<order) - 5;
X    Matrix haar_sub = haar_matrix(5,no_sub_cols);
X    Matrix haar_sub_t(Matrix::Transposed,haar_sub);
X    Matrix hsths(haar_sub_t,Matrix::Mult,haar_sub);
X    Matrix hsths1(Matrix::Zero,hsths); hsths1.mult(haar_sub_t,haar_sub);
X    Matrix hsths_eth(Matrix::Unit,hsths);
X    assert( hsths.q_nrows() == no_sub_cols && hsths.q_ncols() == no_sub_cols );
X    verify_matrix_identity(hsths,hsths_eth);
X    verify_matrix_identity(hsths1,hsths_eth);
X    
X    Matrix haar = haar_matrix(5);
X    Matrix unit(Matrix::Unit,haar);
X    Matrix haar_t(Matrix::Transposed,haar);
X    Matrix hth(haar,Matrix::TransposeMult,haar);
X    Matrix hht(haar,Matrix::Mult,haar_t);
X    Matrix hht1 = haar; hht1 *= haar_t;
X    Matrix hht2(Matrix::Zero,haar); hht2.mult(haar,haar_t);
X    verify_matrix_identity(unit,hth);
X    verify_matrix_identity(unit,hht);
X    verify_matrix_identity(unit,hht1);
X    verify_matrix_identity(unit,hht2);
X  }
X  cout << "\nDone\n";
X}
X
Xstatic void test_vm_multiplications(const int msize)
X{
X  cout << "\n---> Verify vector-matrix multiplications\n"
X          "for matrices of the characteristic size " << msize << "\n\n";
X  {
X    cout << "Check shrinking a vector by multiplying by a non-sq unit matrix"
X         << endl;
X    Vector vb(-2,msize);
X    for(register int i=vb.q_lwb(); i<=vb.q_upb(); i++)
X      vb(i) = M_PI - i;
X    assert( vb != 0 );
X    Matrix mc(1,msize-2,-2,msize);	// contracting matrix
X    mc.unit_matrix();
X    Vector v1 = vb;
X    Vector v2 = vb;
X    v1 *= mc;
X    v2.resize_to(1,msize-2);
X    verify_matrix_identity(v1,v2);
X  }
X
X  {
X    cout << "Check expanding a vector by multiplying by a non-sq unit matrix"
X         << endl;
X    Vector vb(msize);
X    for(register int i=vb.q_lwb(); i<=vb.q_upb(); i++)
X      vb(i) = M_PI + i;
X    assert( vb != 0 );
X    Matrix me(2,msize+5,1,msize);	// expanding matrix
X    me.unit_matrix();
X    Vector v1 = vb;
X    Vector v2 = vb;
X    v1 *= me;
X    v2.resize_to(v1);
X    verify_matrix_identity(v1,v2);
X  }
X
X  {
X    cout << "Check general matrix-vector multiplication" << endl;
X    Vector vb(msize);
X    for(register int i=vb.q_lwb(); i<=vb.q_upb(); i++)
X      vb(i) = M_PI + i;
X    Matrix vm(msize,1);
X    MatrixColumn(vm,1) = vb;
X    Matrix m(0,msize,1,msize);
X    m.hilbert_matrix();
X    vb *= m;
X    assert( vb.q_lwb() == 0 );
X    Matrix mvm(m,Matrix::Mult,vm);
X    verify_matrix_identity(vb,mvm);
X  }
X
X  cout << "\nDone\n";
X}
X
Xstatic void test_inversion(const int msize)
X{
X  cout << "\n---> Verify matrix inversion for square matrices\n"
X          "of size " << msize << "\n\n";
X  {
X    cout << "Test invesion of a diagonal matrix" << endl;
X    Matrix m(-1,msize,-1,msize);
X    Matrix mi(Matrix::Zero,m);
X    for(register int i=m.q_row_lwb(); i<=m.q_row_upb(); i++)
X      mi(i,i) = 1/(m(i,i) = i-m.q_row_lwb()+1);
X    Matrix mi1(Matrix::Inverted,m);
X    m.invert();
X    verify_matrix_identity(m,mi);
X    verify_matrix_identity(mi1,mi);
X  }
X
X  {
X    cout << "Test invesion of an orthonormal (Haar) matrix" << endl;
X    Matrix m = haar_matrix(3);
X    Matrix morig = m;
X    Matrix mt(Matrix::Transposed,m);
X    double det = -1;		// init to a wrong val to see if it's changed
X    m.invert(&det);
X    assert( (det-1) <= FLT_EPSILON );
X    verify_matrix_identity(m,mt);
X    Matrix mti(Matrix::Inverted,mt);
X    verify_matrix_identity(mti,morig);
X  }
X
X  {
X    cout << "Test invesion of a good matrix with diagonal dominance" << endl;
X    Matrix m(msize,msize);
X    m.hilbert_matrix();
X    MatrixDiag(m) += 1;
X    Matrix morig = m;
X    double det_inv = 0;
X    const double det_comp = m.determinant();
X    m.invert(&det_inv);
X    cout << "\tcomputed determinant             " << det_comp << endl;
X    cout << "\tdeterminant returned by invert() " << det_inv << endl;
X
X    cout << "\tcheck to see M^(-1) * M is E" << endl;
X    Matrix mim(m,Matrix::Mult,morig);
X    Matrix unit(Matrix::Unit,m);
X    verify_matrix_identity(mim,unit);
X
X    cout << "\tcheck to see M * M^(-1) is E" << endl;
X    Matrix mmi = morig; mmi *= m;
X    verify_matrix_identity(mmi,unit);
X  }
X    
X  cout << "\nDone\n";
X}
X
X
X/*
X *------------------------------------------------------------------------
X *				Root module
X */
X
Xmain()
X{
X  cout << "\n\n" << _Minuses << 
X          "\n\t\tVerify Advanced Operations on Matrices\n";
X
X  test_determinant(20);
X  test_mm_multiplications(20);
X  test_vm_multiplications(20);
X
X  test_inversion(20);
X}
X
________This_Is_The_END________
if test `wc -l < vmatrix1.cc` -ne 328; then
echo 'shar: vmatrix1.cc was damaged during transit (should have had 328 lines)'
fi


echo 'x - vslesing.cc'
sed 's/^X//' << '________This_Is_The_END________' > vslesing.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *	Verify application of SVD to solving sets of simultaneous
X *				linear equations
X *
X * $Id$
X *
X ************************************************************************
X */
X
X#include "svd.h"
X#include <iostream.h>
X
X					// Solve Ax=b and test the result
Xstatic void test_sle(const Matrix& A, const Vector& b, const Vector& x_true)
X{
X  SVD svd(A);
X  cout << "\ncondition number " << svd.q_cond_number() << endl;
X  Vector x = SVD_inv_mult(svd,b);
X  Matrix solutions(2,x_true.q_upb());
X  MatrixRow(solutions,1) = x_true;
X  MatrixRow(solutions,2) = x;
X  solutions.print("true vs. computed solution");
X  Vector b_comp = x;
X  b_comp *= A;
X  cout << "\tchecking to see that Ax is indeed b\n";
X  verify_matrix_identity(b_comp,b);
X}
X
Xstatic void test1(const int neqs, const int nvars)
X{
X  cout << "\n\nChecking solution of a set of linear equations\n"
X          "with a Hilb+E of order " << neqs << "x" << nvars << endl;
X  Vector x(nvars);
X  Matrix A(neqs,nvars);
X  A.hilbert_matrix(); (MatrixDiag)A += 1;
X  struct fill : public ElementAction
X  {
X    void operation(REAL& element) { element = i; }
X  };
X  x.apply(fill());
X  Vector b = x;
X  b *= A;
X  test_sle(A,b,x);
X}
X
Xstatic void test2(const int dim)
X{
X  cout << "\n\nChecking solution of a set of linear equations\n"
X          "with a Hilbert matrix of order " << dim << endl;
X  Vector x(dim);
X  Matrix A(dim,dim);
X  A.hilbert_matrix();
X  struct fill : public ElementAction
X  {
X    void operation(REAL& element) { element = i; }
X  };
X  x.apply(fill());
X  Vector b = x;
X  b *= A;
X  test_sle(A,b,x);
X}
X
X
Xmain(void)
X{
X cout << "\n\nVerify application of SVD to solving sets of simultaneous "
X         "equations" << endl;
X test1(10,10);
X test1(20,10);
X test2(10);
X}
________This_Is_The_END________
if test `wc -l < vslesing.cc` -ne 74; then
echo 'shar: vslesing.cc was damaged during transit (should have had 74 lines)'
fi


echo 'x - vsvd.cc'
sed 's/^X//' << '________This_Is_The_END________' > vsvd.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *	Verify Singular Vector Decomposition of a Rectangular Matrix
X *
X * $Id$
X *
X ************************************************************************
X */
X
X#include "svd.h"
X#include <iostream.h>
X
X				// SVD-decompose matrix A and test we can
X				// compose it back
Xstatic void test_svd_expansion(const Matrix& A)
X{
X  cout << "\n\nSVD-decompose matrix A and check if we can compose it back\n"
X       << endl;
X  A.print("original matrix");
X  SVD svd(A);
X  svd.q_U().print("left factor U");
X  svd.q_sig().print("Vector of Singular values");
X  svd.q_V().print("right factor V");
X  
X  {
X    cout << "\tchecking that U is orthogonal indeed, i.e., U'U=E and UU'=E"
X         << endl;
X    Matrix E(Matrix::Unit,svd.q_U());
X    Matrix ut(Matrix::Transposed,svd.q_U());
X    Matrix utu(svd.q_U(),Matrix::TransposeMult,svd.q_U());
X    verify_matrix_identity(utu,E);
X    Matrix uut(svd.q_U(),Matrix::Mult,ut);
X    verify_matrix_identity(uut,E);
X  }
X  
X  {
X    cout << "\tchecking that V is orthogonal indeed, i.e., V'V=E and VV'=E"
X         << endl;
X    Matrix E(Matrix::Unit,svd.q_V());
X    Matrix vtv(svd.q_V(),Matrix::TransposeMult,svd.q_V());
X    verify_matrix_identity(vtv,E);
X    Matrix vt(Matrix::Transposed,svd.q_V());
X    Matrix vvt(svd.q_V(),Matrix::Mult,vt);
X    verify_matrix_identity(vvt,E);
X  }
X  
X  {
X    cout << "\tchecking that U*Sig*V' is indeed A" << endl;
X    Matrix S(Matrix::Zero,A);
X    (MatrixDiag)S = svd.q_sig();
X    Matrix vt(Matrix::Transposed,svd.q_V());
X    S *= vt;
X    Matrix Acomp(svd.q_U(),Matrix::Mult,S);
X    compare(A,Acomp,"Original A and composed USigV'");
X  }
X
X  cout << "\nDone" << endl;
X}
X
X				// Make a matrix from an array
X				// (read it row-by-row)
Xclass MakeMatrix : public LazyMatrix
X{
X  const REAL * array;
X  const int no_elems;
X  void fill_in(Matrix& m) const;
Xpublic:
X  MakeMatrix(const int nrows, const int ncols,
X  	     const REAL * _array, const int _no_elems)
X    : LazyMatrix(nrows,ncols), array(_array), no_elems(_no_elems) {}
X  MakeMatrix(const int row_lwb, const int row_upb,
X  	     const int col_lwb, const int col_upb,
X  	     const REAL * _array, const int _no_elems)
X    : LazyMatrix(row_lwb,row_upb,col_lwb,col_upb),
X      array(_array), no_elems(_no_elems) {}
X};
X
Xvoid MakeMatrix::fill_in(Matrix& m) const
X{
X  assert( m.q_nrows() * m.q_ncols() == no_elems );
X  register const REAL * ap = array;
X  for(register int i=m.q_row_lwb(); i<=m.q_row_upb(); i++)
X    for(register int j=m.q_col_lwb(); j<=m.q_col_upb(); j++)
X       m(i,j) = *ap++;
X}
X
Xstatic void test1(void)
X{
X  cout << "\nRotated by PI/2 Matrix Diag(1,4,9)\n" << endl;
X  
X  REAL array[] = {0,-4,0,  1,0,0,  0,0,9 };
X  test_svd_expansion(MakeMatrix(3,3,array,sizeof(array)/sizeof(array[0])));
X}
X
Xstatic void test2(void)
X{
X  cout << "\nExample from the Forsythe, Malcolm, Moler's book\n" << endl;
X  
X  REAL array[] = 
X       { 1,6,11, 2,7,12, 3,8,13, 4,9,14, 5,10,15};
X  test_svd_expansion(MakeMatrix(5,3,array,sizeof(array)/sizeof(array[0])));
X}
X
Xstatic void test3(void)
X{
X  cout << "\nExample from the Wilkinson, Reinsch's book\n" <<
X          "Singular numbers are 0, 19.5959, 20, 0, 35.3270\n" << endl;
X  
X  REAL array[] = 
X      { 22, 10,  2,   3,  7,    14,  7, 10,  0,  8,
X        -1, 13, -1, -11,  3,    -3, -2, 13, -2,  4,
X         9,  8,  1,  -2,  4,     9,  1, -7,  5, -1,
X         2, -6,  6,   5,  1,     4,  5,  0, -2,  2 };
X  test_svd_expansion(MakeMatrix(8,5,array,sizeof(array)/sizeof(array[0])));
X}
X
Xstatic void test4(void)
X{
X  cout << "\nExample from the Wilkinson, Reinsch's book\n" <<
X          "Ordered singular numbers are Sig[21-k] = sqrt(k*(k-1))\n" << endl;
X  Matrix A(21,20);
X  struct fill_in : public ElementAction
X  {
X    void operation(REAL& element) { element = j>i ? 0 : i==j ? 21-j : -1; }
X  };
X  A.apply(fill_in());
X  test_svd_expansion(A);
X}
X
Xmain(void)
X{
X cout << "\n\nTesting Singular Value Decompositions of rectangular matrices"
X      << endl;
X test1();
X test2();
X test3();
X test4();
X}
________This_Is_The_END________
if test `wc -l < vsvd.cc` -ne 140; then
echo 'shar: vsvd.cc was damaged during transit (should have had 140 lines)'
fi


echo 'x - vvector.cc'
sed 's/^X//' << '________This_Is_The_END________' > vvector.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *			Verify Operations on Vectors
X *
X * $Id: vvector.cc,v 3.1 1995/02/01 16:37:40 oleg Exp oleg $
X *
X ************************************************************************
X */
X
X#include "LinAlg.h"
X#include <math.h>
X#include "builtin.h"
X#include <iostream.h>
X
X/*
X *------------------------------------------------------------------------
X *			Service validation functions
X */
Xstatic void verify_vector_identity(const Vector& v1, const Vector& v2)
X{ verify_matrix_identity(v1,v2); }
X
X/*
X *------------------------------------------------------------------------
X *	   Test allocation functions and compatibility check
X */
X
Xstatic void test_allocation(void)
X{
X
X  cout << "\n\n---> Test allocation and compatibility check\n";
X
X  Vector v1(20);
X  Vector v2(1,20);
X  Vector v3(0,19);
X  Vector v4(v1);
X  cout << "The following vector have been allocated\n";
X  v1.info(), v2.info(), v3.info(), v4.info();
X
X  cout << "\nStatus information reported for vector v3:\n";
X  cout << "  Lower bound ... " << v3.q_lwb() << "\n";
X  cout << "  Upper bound ... " << v3.q_upb() << "\n";
X  cout << "  No. of elements " << v3.q_no_elems() << "\n";
X  cout << "  Name " << v3.q_name() << "\n";
X
X  cout << "\nCheck vectors 1 & 2 for compatibility\n";
X  are_compatible(v1,v2);
X
X  cout << "Check vectors 1 & 4 for compatibility\n";
X  are_compatible(v1,v4);
X
X#if 0
X  cout << "Check vectors 1 & 3 for compatibility\n";
X  are_compatible(v1,v3);
X#endif
X
X  cout << "v2 has to be compatible with v3 after resizing to v3\n";
X  v2.resize_to(v3);
X  are_compatible(v2,v3);
X
X  Vector v5(v1.q_upb()+5); v5.set_name("Vector v5");
X  cout << "v1 has to be compatible with v5 after resizing to v5.upb\n";
X  v5.info(); cout << endl;
X  v1.resize_to(v5.q_no_elems());
X  are_compatible(v1,v5);
X
X  {
X    cout << "Check that shrinking does not change remaining elements" << endl;
X    Vector vb(-1,20);
X    register int i;
X    for(i=vb.q_lwb(); i<=vb.q_upb(); i++)
X      vb(i) = i+M_PI;
X    Vector v = vb;
X    assert( v == vb );
X    assert( v != 0 );
X    v.resize_to(0,10);
X    for(i=v.q_lwb(); i<=v.q_upb(); i++)
X      assert( v(i) == vb(i-v.q_lwb()+vb.q_lwb()) );
X    cout << "Check that expansion expands by zeros" << endl;
X    const int old_nelems = v.q_upb() - v.q_lwb() + 1;
X    v.resize_to(vb);
X    assert( !(v == vb) );
X    for(i=v.q_lwb(); i<v.q_lwb()+old_nelems; i++)
X      assert( v(i) == vb(i) );
X    for(; i<=v.q_upb(); i++)
X      assert( v(i) == 0 );
X  }
X  cout << "\nDone\n";
X}
X
X/*
X *------------------------------------------------------------------------
X *		     Test uniform element operations
X */
X
Xstatic void test_element_op(const int vsize)
X{
X  const double pattern = M_PI;
X  register int i;
X
X  cout << "\n\n---> Test operations that treat each element uniformly\n";
X
X  Vector v(-1,vsize-2);
X  Vector v1(v);
X
X  cout << "Writing zeros to v...\n";
X  for(i=v.q_lwb(); i<=v.q_upb(); i++)
X    v(i) = 0;
X  verify_element_value(v,0);
X
X  cout << "Clearing v1 ...\n";
X  v1.clear();
X  verify_element_value(v1,0);
X
X  cout << "Comparing v1 with 0 ...\n";
X  assure(v1 == 0, "v1 is not zero!");
X
X  cout << "Writing a pattern " << pattern << " by assigning to v(i)...\n";
X  for(i=v.q_lwb(); i<=v.q_upb(); i++)
X    v(i) = pattern;
X  verify_element_value(v,pattern);
X
X  cout << "Writing the pattern by assigning to v1 as a whole ...\n";
X  v1 = pattern;
X  verify_element_value(v1,pattern);
X
X  cout << "Comparing v and v1 ...\n";
X  assure(v == v1, "v and v1 are unexpectedly different!");
X  cout << "Comparing (v=0) and v1 ...\n";
X  assert(!(v.clear() == v1));
X
X  cout << "\nClear v and add the pattern\n";
X  v.clear();
X  v += pattern;
X  verify_element_value(v,pattern);
X  cout << "   add the doubled pattern with the negative sign\n";
X  v += -2*pattern;
X  verify_element_value(v,-pattern);
X  cout << "   subtract the trippled pattern with the negative sign\n";
X  v -= -3*pattern;
X  verify_element_value(v,2*pattern);
X
X  cout << "\nVerify comparison operations\n";
X  v = pattern;
X  assert( v == pattern && !(v != pattern) && v >= pattern && v <= pattern );
X  assert( v > 0 && v >= 0 );
X  assert( v > -pattern && v >= -pattern );
X  assert( v < pattern+1 && v <= pattern+1 );
X  v(v.q_upb()) += 1;
X  assert( !(v==pattern) && !(v != pattern) && v != pattern-1 );
X  assert( v >= pattern && !(v > pattern) && !(v >= pattern+1) );
X  assert( v <= (REAL)pattern+1 && !(v < pattern+1) && !(v <= pattern) );
X
X  cout << "\nAssign 2*pattern to v by repeating additions\n";
X  v = 0; v += pattern; v += pattern;
X  cout << "Assign 2*pattern to v1 by multiplying by two \n";
X  v1 = pattern; v1 *= 2;
X  verify_element_value(v1,2*pattern);
X  assert( v == v1 );
X  cout << "Multiply v1 by one half returning it to the 1*pattern\n";
X  v1 *= 1/2.;
X  verify_element_value(v1,pattern);
X
X  cout << "\nAssign -pattern to v and v1\n";
X  v.clear(); v -= pattern; v1 = -pattern;
X  verify_element_value(v,-pattern);
X  assert( v == v1 );
X  cout << "v = sqrt(sqr(v)); v1 = abs(v1); Now v and v1 have to be the same\n";
X  v.sqr();
X  verify_element_value(v,pattern*pattern);
X  v.sqrt();
X  verify_element_value(v,pattern);
X  v1.abs();
X  verify_element_value(v1,pattern);
X  assert( v == v1 );
X
X  {
X    cout << "\nCheck out to see that sin^2(x) + cos^2(x) = 1\n";
X    for(i=v.q_lwb(); i<=v.q_upb(); i++)
X      v(i) = 2*M_PI/v.q_no_elems() * i;
X    class SinAction : public ElementPrimAction
X    {
X      void operation(REAL& element) { element = sin(element); }
X      public: SinAction(void) {}
X    };
X    v.apply(SinAction());
X    Vector v2 = v;
X    
X    class CosAction : public ElementAction
X    {
X      double factor;
X      void operation(REAL& element) { element = cos(factor*i); }
X      public:
X      CosAction(const int no_elems): factor(2*M_PI/no_elems) {}
X    };
X    v1.apply(CosAction(v.q_no_elems()));
X    Vector v3 = v1;
X    v.sqr();
X    v1.sqr();
X    v += v1;
X    verify_element_value(v,1);
X 
X    cout << "\n\tdo it again through LazyMatrix promise of a vector" << endl;
X    class square_add : public LazyMatrix, public ElementAction
X    {
X      const Vector &v1; Vector &v2;
X      void operation(REAL& element)
X      		{ assert(j==1); element = v1(i)*v1(i) + v2(i)*v2(i); }
X     void fill_in(Matrix& m) const { m.apply(*this); }
X     public: square_add(const Vector& _v1, Vector& _v2) :
X   	LazyMatrix(_v1.q_row_lwb(),_v1.q_row_upb(),1,1),
X   	v1(_v1), v2(_v2) {}
X    };
X    Vector vres = square_add(v2,v3);
X    Vector vres1 = v2; assert( !(vres1 == vres) );
X    verify_element_value(vres,1);
X    vres1 = square_add(v2,v3);
X    verify_element_value(vres1,1);
X  }
X
X  cout << "\nVerify constructor with initialization\n";
X  Vector vi(1,5,0.0,1.0,2.0,3.0,4.0,"END");
X  Vector vit(5);
X  for(i=vit.q_lwb(); i<=vit.q_upb(); i++)
X    vit(i) = i-1;
X  verify_vector_identity(vi,vit);
X  
X  cout << "\nDone\n\n";
X}
X
X/*
X *------------------------------------------------------------------------
X *			Test binary vector operations
X */
X
Xstatic void test_binary_op(const int vsize)
X{
X  const double pattern = M_PI;
X  register int i;
X
X  cout << "\n---> Test Binary Vector operations\n";
X
X  Vector v(2,vsize+1);
X  Vector v1(v);
X  Vector vp(v);
X
X  for(i=v.q_lwb(); i<=v.q_upb(); i++)
X    vp(i) = (i-v.q_no_elems()/2.)*pattern;
X  
X
X  cout << "\nVerify assignment of a vector to the vector\n";
X  v = pattern;
X  v1.clear();
X  v1 = v;
X  verify_element_value(v1,pattern);
X  assert( v1 == v );
X
X  cout << "\nAdding one vector to itself, uniform pattern " << pattern << "\n";
X  v.clear(); v = pattern;
X  v1 = v; v1 += v1;
X  verify_element_value(v1,2*pattern);
X  cout << "  subtracting two vectors ...\n";
X  v1 -= v;
X  verify_element_value(v1,pattern);
X  cout << "  subtracting the vector from itself\n";
X  v1 -= v1;
X  verify_element_value(v1,0);
X  cout << "  adding two vectors together\n";
X  v1 += v;
X  verify_element_value(v1,pattern);
X
X  cout << "\nArithmetic operations on vectors with not the same elements\n";
X  cout << "   adding vp to the zero vector...\n";
X  v.clear(); v += vp;
X//  verify_vector_identity(v,vp);
X  assert( v == vp );
X  v1 = v;
X  cout << "   making v = 3*vp and v1 = 3*vp, via add() and succesive mult\n";
X  add(v,2,vp);
X  v1 += v1; v1 += vp;
X  verify_vector_identity(v,v1);
X  cout << "   clear both v and v1, by subtracting from itself and via add()\n";
X  v1 -= v1;
X  add(v,-3,vp);
X  verify_vector_identity(v,v1);
X
X  cout << "\nTesting element-by-element multiplications and divisions\n";
X  cout << "   squaring each element with sqr() and via multiplication\n";
X  v = vp; v1 = vp;
X  v.sqr();
X  element_mult(v1,v1);
X  verify_vector_identity(v,v1);
X  cout << "   compare (v = pattern^2)/pattern with pattern\n";
X  v = pattern; v1 = pattern;
X  v.sqr();
X  element_div(v,v1);
X  verify_element_value(v,pattern);
X  compare(v1,v,"Original vector and vector after squaring and dividing");
X
X  cout << "\nDone\n";
X}
X
X/*
X *------------------------------------------------------------------------
X *			Verify the norm calculation
X */
X
Xstatic void test_norms(const int vsize)
X{
X  cout << "\n---> Verify norm calculations\n";
X
X  const double pattern = 10.25;
X
X  if( vsize % 2 == 1 )
X    _error("Sorry, size of the vector to test must be even for this test\n");
X
X  Vector v(vsize);
X  Vector v1(v);
X
X  cout << "\nAssign " << pattern << " to all the elements and check norms\n";
X  v = pattern;
X  cout << "  1. norm should be pattern*no_elems\n";
X  assert( v.norm_1() == pattern*v.q_no_elems() );
X  cout << "  Square of the 2. norm has got to be pattern^2 * no_elems\n";
X  assert( v.norm_2_sqr() == sqr(pattern)*v.q_no_elems() );
X  cout << "  Inf norm should be pattern itself\n";
X  assert( v.norm_inf() == pattern );
X  cout << "  Scalar product of vector by itself is the sqr(2. vector norm)\n";
X  assert( v.norm_2_sqr() == v * v );
X
X  double ap_step = 1;
X  double ap_a0   = -pattern;
X  int n = v.q_no_elems();
X  cout << "\nAssign the arithm progression with 1. term " << ap_a0 <<
X          "\nand the difference " << ap_step << "\n";
X  register int i;
X  for(i=v.q_lwb(); i<=v.q_upb(); i++)
X    v(i) = (i-v.q_lwb())*ap_step + ap_a0;
X  int l = min(max((int)ceil(-ap_a0/ap_step),0),n);
X  double norm = (2*ap_a0 + (l+n-1)*ap_step)/2*(n-l) +
X    (-2*ap_a0-(l-1)*ap_step)/2*l;
X  cout << "  1. norm should be " << norm << "\n";
X  assert( v.norm_1() == norm );
X  norm = n*( sqr(ap_a0) + ap_a0*ap_step*(n-1) + sqr(ap_step)*(n-1)*(2*n-1)/6);
X  cout << "  Square of the 2. norm has got to be "
X          "n*[ a0^2 + a0*q*(n-1) + q^2/6*(n-1)*(2n-1) ], or " << norm << "\n";
X  assert( v.norm_2_sqr() == norm );
X  norm = max(abs(v(v.q_lwb())),abs(v(v.q_upb())));
X  cout << "  Inf norm should be max(abs(a0),abs(a0+(n-1)*q)), ie " << norm <<
X          "\n";
X  assert( v.norm_inf() == norm );
X  cout << "  Scalar product of vector by itself is the sqr(2. vector norm)\n";
X  assert( v.norm_2_sqr() == v * v );
X
X  v1.clear();
X  compare(v,v1,"Compare the vector v with a zero vector");
X
X  cout << "\nConstruct v1 to be orthogonal to v as v(n), -v(n-1), v(n-2)...\n";
X  for(i=0; i<v1.q_no_elems(); i++)
X    v1(i+v1.q_lwb()) = v(v.q_upb()-i) * ( i % 2 == 1 ? -1 : 1 );
X  cout << "||v1|| has got to be equal ||v|| regardless of the norm def\n";
X  assert( v1.norm_1() == v.norm_1() );
X  assert( v1.norm_2_sqr() == v.norm_2_sqr() );
X  assert( v1.norm_inf() == v.norm_inf() );
X  cout << "But the scalar product has to be zero\n";
X  assert( v1 * v == 0 );
X
X  cout << "\nDone\n";
X}
X
X/*
X *------------------------------------------------------------------------
X *	    Test operations with vectors and matrix slices
X */
X
Xstatic void test_matrix_slices(const int vsize)
X{
X  const REAL pattern = 8.625;
X  register int i;
X
X  cout << "\n\n---> Test operations with vectors and matrix slices\n";
X
X  Vector vc(0,vsize);
X  Vector vr(0,vsize+1);
X  Matrix m(0,vsize,0,vsize+1);
X
X  cout << "\nCheck modifying the matrix column-by-column\n";
X  m = pattern;
X  assert( m == pattern );
X  for(i=m.q_col_lwb(); i <= m.q_col_upb(); i++)
X  {
X    MatrixColumn(m,i) = pattern-1;
X    assert( !( m == pattern ) && !( m != pattern ) );
X    MatrixColumn(m,i) *= 2;
X    vc = MatrixColumn(m,i);
X    verify_element_value(vc,2*(pattern-1));
X    vc = MatrixColumn(m, i+1 > m.q_col_upb() ? m.q_col_lwb() : i+1);
X    verify_element_value(vc,pattern);
X    MatrixColumn(m,i) *= 0.5;
X    MatrixColumn(m,i) += 1;
X    assert( m == pattern );
X  }
X
X  assert( m == pattern );
X  for(i=m.q_col_lwb(); i <= m.q_col_upb(); i++)
X  {
X    vc = pattern+1;
X    MatrixColumn(m,i) = vc;
X    assert( !( m == pattern ) && !( m != pattern ) );
X    {
X      MatrixColumn mc(m,i);
X      for(register int j=m.q_row_lwb(); j<=m.q_row_upb(); j++)
X        mc(j) *= 4;
X    }
X    vc = MatrixColumn(m,i);
X    verify_element_value(vc,4*(pattern+1));
X    MatrixColumn(m,i) *= 0.25;
X    MatrixColumn(m,i) += -1;
X    vc = MatrixColumn(m,i);
X    verify_element_value(vc,pattern);
X    assert( m == pattern );
X  }
X
X  cout << "\nCheck modifying the matrix row-by-row\n";
X  m = pattern;
X  assert( m == pattern );
X  for(i=m.q_row_lwb(); i <= m.q_row_upb(); i++)
X  {
X    MatrixRow(m,i) = pattern+2;
X    assert( !( m == pattern ) && !( m != pattern ) );
X    vr = MatrixRow(m,i);
X    verify_element_value(vr,pattern+2);
X    vr = MatrixRow(m,i+1 > m.q_row_upb() ? m.q_row_lwb() : i+1);
X    verify_element_value(vr,pattern);
X    MatrixRow(m,i) += -2;
X    assert( m == pattern );
X  }
X
X  assert( m == pattern );
X  for(i=m.q_row_lwb(); i <= m.q_row_upb(); i++)
X  {
X    vr = pattern-2;
X    MatrixRow(m,i) = vr;
X    assert( !( m == pattern ) && !( m != pattern ) );
X    {
X      MatrixRow mr(m,i);
X      for(register int j=m.q_col_lwb(); j<=m.q_col_upb(); j++)
X        mr(j) *= 8;
X    }
X    vr = MatrixRow(m,i);
X    verify_element_value(vr,8*(pattern-2));
X    MatrixRow(m,i) *= 1./8;
X    MatrixRow(m,i) += 2;
X    vr = MatrixRow(m,i);
X    verify_element_value(vr,pattern);
X    assert( m == pattern );
X  }
X
X  cout << "\nCheck modifying the matrix diagonal\n";
X  m = pattern;
X  (MatrixDiag)m = pattern-3;
X  assert( !( m == pattern ) && !( m != pattern ) );
X  vc = MatrixDiag(m);
X  verify_element_value(vc,pattern-3);
X  MatrixDiag(m) += 3;
X  assert( m == pattern );
X  vc = pattern+3;
X  (MatrixDiag)m = vc;
X  assert( !( m == pattern ) && !( m != pattern ) );
X  {
X    MatrixDiag md(m);
X    for(register int j=1; j<=md.q_ndiags(); j++)
X      md(j) /= 1.5;
X  }
X  vc = MatrixDiag(m);
X  verify_element_value(vc,(pattern+3)/1.5);
X  MatrixDiag(m) *= 1.5;
X  MatrixDiag(m) += -3;
X  vc = MatrixDiag(m);
X  verify_element_value(vc,pattern);
X  assert( m == pattern );
X
X  cout << "\nCheck out to see that multiplying by diagonal is column-wise"
X          "\nmatrix multiplication\n";
X  Matrix mm(m);
X  Matrix m1(m.q_row_lwb(),::max(m.q_row_upb(),m.q_col_upb()),
X	    m.q_col_lwb(),::max(m.q_row_upb(),m.q_col_upb()));
X  Vector vc1(vc), vc2(vc);
X  for(i=m.q_row_lwb(); i<m.q_row_upb(); i++)
X    MatrixRow(m,i) = pattern+i;		// Make a multiplicand
X  mm = m;				// Save it
X
X  m1 = pattern+10;
X  for(i=vr.q_lwb(); i<=vr.q_upb(); i++)
X    vr(i) = i+2;
X  (MatrixDiag)m1 = vr;			// Make the other multiplicand
X  assert( !(m1 == pattern+10) );
X
X  m *= MatrixDiag(m1);
X  for(i=m.q_col_lwb(); i<=m.q_col_upb(); i++)
X  {
X    vc1 = MatrixColumn(mm,i);
X    vc1 *= vr(i);			// Do a column-wise multiplication
X    vc2 = MatrixColumn(m,i);
X    verify_vector_identity(vc1, vc2);
X  }
X
X  cout << "\nDone\n";
X}
X
X/*
X *------------------------------------------------------------------------
X *				Root module
X */
X
Xmain()
X{
X  cout << "\n\n" << _Minuses << 
X          "\n\t\tVerify Operations on Vectors\n";
X
X  test_allocation();
X  test_element_op(20);
X  test_binary_op(20);
X  test_norms(20);
X  test_matrix_slices(20);
X}
X
________This_Is_The_END________
if test `wc -l < vvector.cc` -ne 528; then
echo 'shar: vvector.cc was damaged during transit (should have had 528 lines)'
fi


echo 'x - vzeroin.cc'
sed 's/^X//' << '________This_Is_The_END________' > vzeroin.cc
X// This may look like C code, but it is really -*- C++ -*-
X//
X//			Verify ZEROIN routine
X
X#include "math_num.h"
X#include <iostream.h>
X
Xstatic int counter;			// Iteration counter
X
X			// Run a test
Xstatic void test
X  (const double a, const double b, double (*f)(double x), const char *msg)
X{
X  double root;
X  counter = 0;
X  printf("\nFor function %s,\nthe root over [%g,%g] is\t%.9e\n",msg,a,b,
X	 (root=zeroin(a,b,f)) );
X  printf("Function value at the root found\t%.4e\n"
X	       "No. of iterations\t\t%d\n",
X	       (*f)(root), counter);
X}
X
Xstatic double f1(const double x)		// Test from the Forsythe book
X{
X  counter++;
X  return (sqr(x)-2)*x - 5;
X}
X
Xstatic double f2(const double x)
X{
X  counter++;
X  return cos(x) - x;
X}
X
Xstatic double f3(const double x)
X{
X  counter++;
X  return sin(x) - x;
X}
X
X
Xmain(void)
X{
X  cout << "\n\n" << _Minuses <<
X          "\n\t\tTesting the Brent's root finder\n\n";
X
X  test(2.0,3.0,f1,"x^3 - 2*x - 5");
X  cout << "Exact root is \t\t2.0945514815\n";
X
X  test(2.0,3.0,f2,"cos(x)-x");
X  test(-1.0,3.0,f2,"cos(x)-x");
X  test(-1.0,3.0,f3,"sin(x)-x");
X}
________This_Is_The_END________
if test `wc -l < vzeroin.cc` -ne 53; then
echo 'shar: vzeroin.cc was damaged during transit (should have had 53 lines)'
fi


echo 'x - zeroin.cc'
sed 's/^X//' << '________This_Is_The_END________' > zeroin.cc
X// This may look like C code, but it is really -*- C++ -*-
X/*
X ************************************************************************
X *
X *			  Numerical Math Package
X *
X *			    Brent's root finder
X *	       obtains a zero of a function of one variable
X *
X * Synopsis
X *	double zeroin(ax,bx,f,tol=EPSILON)
X *	const double ax 		The root is to be sought within
X *	const double bx  		the interval [ax,bx]
X *	double (*f)(const double x)	Ptr to the function under 
X *					consideration    
X *	const double tol		Acceptable tolerance for the root
X *					position. It is an optional parameter
X *					with default value EPSILON
X *
X *	Zeroin returns an approximate location for the root with accuracy
X *	4*EPSILON*abs(x) + tol
X *
X * Algorithm
X *	G.Forsythe, M.Malcolm, C.Moler, Computer methods for mathematical
X *	computations. M., Mir, 1980, p.180 of the Russian edition
X *
X * The function makes use of the bissection procedure combined with
X * the linear or quadratic inverse interpolation.
X * At every step program operates three abscissae - a, b, and c.
X *	b - the last and the best approximation to the root
X *	a - the last but one approximation
X *	c - the last but one or even earlier approximation such that
X *		1) |f(b)| <= |f(c)|
X *		2) f(b) and f(c) have opposite signs, i.e. b and c encompass
X *		   the root
X * At every step Zeroin computes two new approximations, one by the 
X * bissection procedure and the other one from interpolation (if a,b, and c
X * are all different the quadratic interpolation is used, linear otherwise).
X * If the latter (i.e. obtained by the interpolation) point looks
X * reasonable (i.e. falls within the current interval [b,c] not close
X * to the end points of the interval), the point is accepted as a new
X * approximation to the root. Otherwise, the bissection result is used.
X * Therefore, the range of uncertainty is guaranteed to be reduced at 
X * least by the factor of 1.6
X *
X ************************************************************************
X */
X
X#pragma implementation "math_num.h"
X#include "math_num.h"
X
X
Xdouble zeroin(				// An estimate to the root
X	const double ax,		// Specify the interval the root
X	const double bx,		// to be sought in
X	double (*f)(const double x),	// Function under investigation
X	const double tol)		// Acceptable tolerance
X{
X  double a = ax, b = bx, c;		// Abscissae, see above
X  double fa;				// f(a)
X  double fb;				// f(b)
X  double fc;				// f(c)
X
X  assure( tol > 0, "Tolerance must be positive");
X  assure( b > a, 
X	 "Left end point of the interval should be strictly less than the "
X	 "right one" );
X
X  fa = (*f)(a);  fb = (*f)(b);
X  c = a;   fc = fa;
X
X  for(;;)		// Main iteration loop
X  {
X    double prev_step = b-a;		// Step from the previous iteration
X   
X    if( fabs(fc) < fabs(fb) )
X    {                         		// Swap data so that b would be the
X      a = b;  b = c;  c = a;          	// best approximation found so far
X      fa=fb;  fb=fc;  fc=fa;
X    }
X					// Estimate the effective tolerance
X    const double tol_act = 2*EPSILON*fabs(b) + tol/2;
X    double new_step = (c-b)/2;		// Bissection step for this iteration
X
X    if( fabs(new_step) <= tol_act || fb == 0 )
X      return b;				// Acceptable approximation is found
X
X    			// Figuring out if the interpolation can be tried
X    if( fabs(prev_step) >= tol_act	// If prev_step was large enough
X	&& fabs(fa) > fabs(fb) )	// and was in true direction,
X    {					// Interpolatiom may be tried
X
X      double p;      			// Interpolation step is calcu-
X      double q;      			// lated in the form p/q; divi-
X  					// sion operations is delayed
X 					// until the last moment
X      const double cb = c-b;
X
X      if( a==c )			// If we've got only two distinct
X      {					// points linear interpolation
X	register double t1 = fb/fa;	// can only be applied
X	p = cb*t1;
X	q = 1.0 - t1;
X      }
X      else				// Quadratic inverse interpolation
X      {
X	register double t1, t2;
X	q = fa/fc;  t1 = fb/fc;  t2 = fb/fa;
X	p = t2 * ( cb*q*(q-t1) - (b-a)*(t1-1.0) );
X	q = (q-1.0) * (t1-1.0) * (t2-1.0);
X      }
X
X      if( p > 0 )			// Formulas above computed new_step
X	q = -q;				// = p/q with wrong sign (on purpose).
X      else				// Correct this, but in such a way so
X	p = -p;				// that p would be positive
X      
X      if( p < (0.75*cb*q-fabs(tol_act*q)/2)	// If b+p/q falls in [b,c]
X	 && p < fabs(prev_step*q/2) )	// and isn't too large
X	new_step = p/q;			// it is accepted
X					// If p/q is too large then the
X					// bissection procedure can
X					// reduce [b,c] to a larger
X					// extent
X    }
X
X    if( fabs(new_step) < tol_act )	// Adjust the step to be not less
X      if( new_step > 0 )		// than the tolerance
X	new_step = tol_act;
X      else
X	new_step = -tol_act;
X
X    a = b;  fa = fb;			// Save the previous approximation
X    b += new_step;  fb = (*f)(b);	// Do step to a new approximation
X    if( (fb > 0 && fc > 0) || (fb < 0 && fc < 0) )
X    {                 			// Adjust c for it to have the sign
X      c = a;  fc = fa;                  // opposite to that of b
X    }
X  }
X
X}
________This_Is_The_END________
if test `wc -l < zeroin.cc` -ne 141; then
echo 'shar: zeroin.cc was damaged during transit (should have had 141 lines)'
fi


echo 'x - sample_adv.dat'
sed 's/^X//' << '________This_Is_The_END________' > sample_adv.dat
X./sample_adv
X
XDonsample matrices using traditional and non-traditional methods
X
XMake sure that both methods give the same results
X
XClock the traditional downsampling
X	It took 4.64 sec to complete the test
X
XClock the 'new style' downsampling (with lazy matrices)
X	It took 2.22 sec to complete the test
X
XCompilation finished at Thu Dec 21 13:20:17
________This_Is_The_END________
if test `wc -l < sample_adv.dat` -ne 13; then
echo 'shar: sample_adv.dat was damaged during transit (should have had 13 lines)'
fi


echo 'x - vali.dat'
sed 's/^X//' << '________This_Is_The_END________' > vali.dat
X./vali
X
X
X		Verification of the Aitken-Lagrange interpolation
X
X------------- Interpolation over the table with uniform grid
XFunction to interpolate: exp(-x)
X
XCheck to see that interpolation at a node gives an exact result
X
XUniform grid [0.1:1] with the step 0.1
X
XDone
X
XCheck the precision of the interpolation at arbitrary points
X
XUniform grid [0.1:1] with the step 0.1
X
XPoint	Exact function value     Interpolated    Error
X   0	           1		    0.999998   1.72853e-06
X0.11	    0.895834		    0.895834   1.26336e-08
X0.22	    0.802519		    0.802519   1.29626e-08
X0.33	    0.718924		    0.718924   1.41076e-08
X0.44	    0.644036		    0.644036   8.84407e-09
X0.55	     0.57695		     0.57695   1.43652e-07
X0.66	    0.516851		    0.516851   3.10746e-08
X0.77	    0.463013		    0.463013   1.53709e-08
X0.88	    0.414783		    0.414783   8.92645e-08
X0.99	    0.371577		    0.371576   4.41423e-07
X 1.1	    0.332871		    0.332871   2.12869e-07
X
XDone
X
X------------- Interpolation over the table with non-uniform grid
XFunction to interpolate: sin(x) * exp(-x/10)
X
XGrids 0.1 .. 1 have the mesh 0.1, and 1..9 have the mesh 0.2
X
XCheck to see that interpolation at a node gives an exact result
X
XDone
X
XCheck the precision of the interpolation at arbitrary points
X
XPoint	Exact function value     Interpolated    Error
X   0	           0		 8.51708e-07   8.51708e-07
X0.27	    0.259626		    0.259626   1.14471e-08
X0.54	    0.487109		    0.487109   3.00486e-08
X0.81	    0.667933		    0.667933   1.61806e-08
X 1.1	     0.79167		     0.79167   6.00246e-08
X 1.4	    0.852505		    0.852481   2.41944e-05
X 1.6	    0.849412		    0.849412    1.1897e-08
X 1.9	    0.785971		    0.785972   1.42046e-07
X 2.2	    0.669875		    0.669875   9.72032e-08
X 2.4	    0.512161		    0.512161   3.90728e-09
X 2.7	    0.326253		    0.326253   1.96635e-08
X   3	    0.126876		    0.126876   2.32042e-08
X 3.2	  -0.0710583		  -0.0710583    2.1131e-08
X 3.5	   -0.253526		   -0.253526   2.44474e-08
X 3.8	   -0.408341		    -0.40834   1.73721e-07
X
XDone
X
XCheck the precision of the interpolation at arbitrary points
X
XExample from Fig. 4.11 of the book
X	Numerical Methods and Software,
X	by D.Kahaner, C.Moler, and S.Nash - Prentice Hall, 1989
X
X		Interpolation nots
Xx      0      2      3      5      6      8      9     11     12     14     15 
Xy     10     10     10     10     10     10     10     15     50     60     85 
X
XPoint	Interpolated value
X      0             10
X   0.32             10
X   0.64             10
X   0.96             10
X   1.28             10
X    1.6             10
X   1.92             10
X   2.24             10
X   2.56             10
X   2.88             10
X    3.2             10
X   3.52             10
X   3.84             10
X   4.16             10
X   4.48             10
X    4.8             10
X   5.12             10
X   5.44             10
X   5.76             10
X   6.08             10
X    6.4             10
X   6.72             10
X   7.04        9.94286
X   7.36        9.93781
X   7.68        9.95318
X      8             10
X   8.32        10.0911
X   8.64        10.2309
X   8.96        10.4641
X   9.28        10.2771
X    9.6          9.232
X   9.92        8.71549
X  10.24        5.79377
X  10.56        9.07021
X  10.88        12.9199
X   11.2        20.6143
X  11.52         29.442
X  11.84        42.5424
X  12.16        57.7971
X  12.48        73.2555
X   12.8        86.0643
X  13.12        62.2166
X  13.44        61.3373
X  13.76        60.1782
X  14.08        60.8715
X   14.4             66
X  14.72        74.3712
X  15.04        86.8043
X  15.36        104.118
X  15.68        127.133
X
XDone
X
XCompilation finished at Thu Dec 21 13:29:48
________This_Is_The_END________
if test `wc -l < vali.dat` -ne 128; then
echo 'shar: vali.dat was damaged during transit (should have had 128 lines)'
fi


echo 'x - vfminbr.dat'
sed 's/^X//' << '________This_Is_The_END________' > vfminbr.dat
X
X
X-------------------------------------------------------------------------------
X		Testing the Brent's one-dimensional minimizer
X
X
XFor function x^3 - 2*x - 5
Xthe minimum over [0,1] is found to be at	8.164965811e-01
XMin function value found	-6.0887e+00
XNo. of iterations		12
XExact min is at		0.81650
X
XFor function (x^3 - 2*x - 5)^2
Xthe minimum over [2,3] is found to be at	2.094551483e+00
XMin function value found	2.7186e-16
XNo. of iterations		15
XExact root is 		2.0945514815
X
XFor function (cos(x)-x)^2 - 2
Xthe minimum over [2,3] is found to be at	2.000000048e+00
XMin function value found	3.8378e+00
XNo. of iterations		36
X
XFor function (cos(x)-x)^2 - 2
Xthe minimum over [-1,3] is found to be at	7.390851269e-01
XMin function value found	-2.0000e+00
XNo. of iterations		18
X
XFor function (sin(x)-x)^2 + 1
Xthe minimum over [-1,3] is found to be at	-3.815499176e-03
XMin function value found	1.0000e+00
XNo. of iterations		60
X
XCompilation finished at Thu Dec 21 13:33:20
________This_Is_The_END________
if test `wc -l < vfminbr.dat` -ne 34; then
echo 'shar: vfminbr.dat was damaged during transit (should have had 34 lines)'
fi


echo 'x - vhjmin.dat'
sed 's/^X//' << '________This_Is_The_END________' > vhjmin.dat
X./vhjmin
X
X
X
X		Verify HJMIN multidimensional minimizer
X
X
X	Rosenbroke function
X
X
X	f = 100*(x2-x1^2)^2 + (1-x1)^2
X
X
XInitial guess         b0 =      -1.2          1  
XFunction value at it  f0 = 24.2
XInitial steps         h0 =        10         10  
X
XMinimum f value found f  = 6.97611e-11
X                  at  b  =         1          1  
XFinal steps           h =     1e-15      1e-15  
XExact min location    bm =         1          1  
XNo. of iterations     ni = 270
X
X
X	Bocks function
X
X
X	f = [ exp(-1/10) - exp(-x1/10) + exp(-10/10) -exp(-x2/10) ]^2
X
X
XInitial guess         b0 =         0          0  
XFunction value at it  f0 = 0.528941
XInitial steps         h0 = 10
X
XMinimum f value found f  = 0
X                  at  b  =        10          1  
XExact min location    bm =        10          1  
XNo. of iterations     ni = 89
X
X
X	Mile & Cuntrell function
X
X
X	f = [ exp(x1)-x2 ]^4 +100(x2-x3)^6 + atan(x3-x4)^4 + x1^8
X
X
XInitial guess         b0 =         1          2          2          2  
XFunction value at it  f0 = 1.26618
XInitial steps         h0 = 10
X
XMinimum f value found f  = 4.1179e-27
X                  at  b  =  1.49e-08          1          1          1  
XExact min location    bm =         0          1          1          1  
XNo. of iterations     ni = 227
X
X
X	Powell function
X
X
X	f = (x1+10*x2)^2 + 5(x3-x4)^2 + (x2-2x3)^4 + 10(x1-x4)^4
X
X
XInitial guess         b0 =         3         -1          0          1  
XFunction value at it  f0 = 215
XInitial steps         h0 =        10         10         10         10  
X
XMinimum f value found f  = 0
X                  at  b  =         0          0          0          0  
XExact min location    bm =         0          0          0          0  
XNo. of iterations     ni = 154
X
XCompilation finished at Thu Dec 21 13:30:46
________This_Is_The_END________
if test `wc -l < vhjmin.dat` -ne 72; then
echo 'shar: vhjmin.dat was damaged during transit (should have had 72 lines)'
fi


echo 'x - vmatrix.dat'
sed 's/^X//' << '________This_Is_The_END________' > vmatrix.dat
X./vmatrix
X
X
X-------------------------------------------------------------------------------
X		Verify Operations on Matrices
X
X
X---> Test allocation and compatibility check
XThe following matrices have been allocated
X
XMatrix 1:4x1:20 'Matrix m1'
XMatrix 1:4x1:20 'Matrix m2'
XMatrix 1:4x0:19 'Matrix m3'
XMatrix 1:4x1:20 'Matrix m4'
XStatus information reported for matrix m3:
X  Row lower bound ... 1
X  Row upper bound ... 4
X  Col lower bound ... 0
X  Col upper bound ... 19
X  No. rows ...........4
X  No. cols ...........20
X  No. of elements ....80
X  Name Matrix m3
X
XCheck matrices 1 & 2 for compatibility
XCheck matrices 1 & 4 for compatibility
Xm2 has to be compatible with m3 after resizing to m3
Xm1 has to be compatible with m5 after resizing to m5
X
XMatrix 1:5x1:25 'Matrix m5'
X
X---> Test operations that treat each element uniformly
XWriting zeros to m...
XCreating zero m1 ...
XComparing m1 with 0 ...
XWriting a pattern 8.625 by assigning to m(i,j)...
XWriting the pattern by assigning to m1 as a whole ...
XComparing m and m1 ...
XComparing (m=0) and m1 ...
XClearing m1 ...
X
XClear m and add the pattern
X   add the doubled pattern with the negative sign
X   subtract the trippled pattern with the negative sign
X
XVerify comparison operations when all elems are the same
X
XVerify comparison operations when not all elems are the same
X
XAssign 2*pattern to m by repeating additions
XAssign 2*pattern to m1 by multiplying by two 
XMultiply m1 by one half returning it to the 1*pattern
X
XAssign -pattern to m and m1
Xm = sqrt(sqr(m)); m1 = abs(m1); Now m and m1 have to be the same
X
XCheck out to see that sin^2(x) + cos^2(x) = 1
XElement (16,8) with value 1 differs the most from what
Xwas expected, 1, though the deviation 1.19209e-07 is small
X
XDone
X
X
X---> Test Binary Matrix element-by-element operations
X
XVerify assignment of a matrix to the matrix
X
XAdding the matrix to itself, uniform pattern 4.25
X  subtracting two matrices ...
X  subtracting the matrix from itself
X  adding two matrices together
X
XArithmetic operations on matrices with not the same elements
X   adding mp to the zero matrix...
X   making m = 3*mp and m1 = 3*mp, via add() and succesive mult
X   clear both m and m1, by subtracting from itself and via add()
X
XTesting element-by-element multiplications and divisions
X   squaring each element with sqr() and via multiplication
X   compare (m = pattern^2)/pattern with pattern
X
X
XComparison of two Matrices:
X	Original vector and vector after squaring and dividing
XMatrix 2:11x0:19 ''
XMatrix 2:11x0:19 ''
XMaximal discrepancy    		0
X   occured at the point		(2,0)
X Matrix 1 element is    		4.25
X Matrix 2 element is    		4.25
X Absolute error v2[i]-v1[i]		0
X Relative error				0
X
X||Matrix 1||   			850
X||Matrix 2||   			850
X||Matrix1-Matrix2||				0
X||Matrix1-Matrix2||/sqrt(||Matrix1|| ||Matrix2||)	0
X
X
XDone
X
X---> Verify norm calculations
X
XAssign 10.25 to all the elements and check norms
X  1. (col) norm should be pattern*nrows
X  Inf (row) norm should be pattern*ncols
X  Square of the Eucl norm has got to be pattern^2 * no_elems
X
XDone
X
X---> Check creating some special matrices of dimension 20
X
Xtest creating Hilbert matrices
Xtest creating zero matrix and copy constructor
Xtest creating unit matrices
Xcheck to see that Haar matrix has *exactly* orthogonal columns
Xmake Haar (sub)matrix and test it *is* a submatrix
X
XDone
X
X---> Check making/forcing promises, (lazy)matrices of dimension 20
X
Xmake a promise and force it by a constructor
Xmake a promise and force it by an assignment
X
XDone
X
X---> Verify matrix transpose
Xfor matrices of a characteristic size 20
X
XCheck to see that a square UnitMatrix' stays the same
XTest a non-square UnitMatrix
XCheck to see that a symmetric (Hilbert)Matrix' stays the same
XCheck transposing a non-symmetric matrix
XCheck double transposing a non-symmetric matrix
XDone
X
XCompilation finished at Thu Dec 21 13:17:01
________This_Is_The_END________
if test `wc -l < vmatrix.dat` -ne 138; then
echo 'shar: vmatrix.dat was damaged during transit (should have had 138 lines)'
fi


echo 'x - vmatrix1.dat'
sed 's/^X//' << '________This_Is_The_END________' > vmatrix1.dat
X./vmatrix1
X
X
X-------------------------------------------------------------------------------
X		Verify Advanced Operations on Matrices
X
X---> Verify determinant evaluation
Xfor a square matrix of size 20
X
XCheck to see that the determinant of the unit matrix is one
X	determinant is 1
XCheck the determinant for the matrix with 2.5
X	at the diagonal
X	determinant is 9.09495e+07
XCheck the determinant of the transposed matrix
XCheck the determinant for the matrix with 2.5
X	at the anti-diagonal
XCheck the determinant for the singular matrix
X	defined as above with zero first row
X	determinant is 0
XCheck out the determinant of the Hilbert matrix
X    3x3 Hilbert matrix: exact determinant 1/2160 
X                              computed    1/2159.99
X    4x4 Hilbert matrix: exact determinant 1/6048000 
X                              computed    1/6.04788e+06
X    5x5 Hilbert matrix: exact determinant 3.749295e-12
X                              computed    3.75127e-12
X    7x7 Hilbert matrix: exact determinant 4.8358e-25
X                              computed    6.54014e-25
X    9x9 Hilbert matrix: exact determinant 9.72023e-43
X                              computed    -1.10127e-39
X    10x10 Hilbert matrix: exact determinant 2.16418e-53
X                              computed    -3.15323e-47
XDone
X
X---> Verify matrix multiplications
Xfor matrices of the characteristic size 20
X
XTest inline multiplications of the UnitMatrix
XTest inline multiplications by a DiagMatrix
XTest XPP = X where P is a permutation matrix
XTest general matrix multiplication through inline mult
XCheck to see UU' = U'U = E when U is the Haar matrix
XTwo (27,27) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 5.96046e-08 is small
XTwo (27,27) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 5.96046e-08 is small
XTwo (32,32) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 5.96046e-08 is small
XTwo (32,32) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 5.96046e-08 is small
XTwo (32,32) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 5.96046e-08 is small
XTwo (32,32) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 5.96046e-08 is small
X
XDone
X
X---> Verify vector-matrix multiplications
Xfor matrices of the characteristic size 20
X
XCheck shrinking a vector by multiplying by a non-sq unit matrix
XCheck expanding a vector by multiplying by a non-sq unit matrix
XCheck general matrix-vector multiplication
X
XDone
X
X---> Verify matrix inversion for square matrices
Xof size 20
X
XTest invesion of a diagonal matrix
XTest invesion of an orthonormal (Haar) matrix
XTwo (5,4) elements of matrices with values 8.97181e-09 and 0
Xdiffer the most, though the deviation 8.97181e-09 is small
XTwo (5,7) elements of matrices with values 0.707107 and 0.707107
Xdiffer the most, though the deviation 5.96046e-08 is small
XTest invesion of a good matrix with diagonal dominance
X	computed determinant             4.69592
X	determinant returned by invert() 4.69592
X	check to see M^(-1) * M is E
XTwo (11,11) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 3.57628e-07 is small
X	check to see M * M^(-1) is E
XTwo (11,11) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 3.57628e-07 is small
X
XDone
X
XCompilation finished at Thu Dec 21 13:18:09
________This_Is_The_END________
if test `wc -l < vmatrix1.dat` -ne 89; then
echo 'shar: vmatrix1.dat was damaged during transit (should have had 89 lines)'
fi


echo 'x - vslesing.dat'
sed 's/^X//' << '________This_Is_The_END________' > vslesing.dat
X./vslesing
X
X
XVerify application of SVD to solving sets of simultaneous equations
X
X
XChecking solution of a set of linear equations
Xwith a Hilb+E of order 10x10
X
Xcondition number 2.75192
X
XMatrix 2x10 'true vs. computed solution' is as follows
X
X     |        1  |        2  |        3  |        4  |        5  |        6  |
X-------------------------------------------------------------------------------
X   1 |          1            2            3            4            5            6  
X   2 |          1            2            3            4            5            6  
X
X
X     |        7  |        8  |        9  |       10  |
X-------------------------------------------------------------------------------
X   1 |          7            8            9           10  
X   2 |          7            8            9           10  
XDone
X	checking to see that Ax is indeed b
XTwo (3,1) elements of matrices with values 9.79358 and 9.79358
Xdiffer the most, though the deviation 3.8147e-06 is small
X
X
XChecking solution of a set of linear equations
Xwith a Hilb+E of order 20x10
X
Xcondition number 2.7952
X
XMatrix 2x10 'true vs. computed solution' is as follows
X
X     |        1  |        2  |        3  |        4  |        5  |        6  |
X-------------------------------------------------------------------------------
X   1 |          1            2            3            4            5            6  
X   2 |          1            2            3            4            5            6  
X
X
X     |        7  |        8  |        9  |       10  |
X-------------------------------------------------------------------------------
X   1 |          7            8            9           10  
X   2 |          7            8            9           10  
XDone
X	checking to see that Ax is indeed b
XTwo (7,1) elements of matrices with values 11.4156 and 11.4156
Xdiffer the most, though the deviation 3.8147e-06 is small
X
X
XChecking solution of a set of linear equations
Xwith a Hilbert matrix of order 10
X
Xcondition number 8.94709e+08
X
XSVD solver of AX=B detected a linear dependency among X
X  #  singular value	null coefficients
X 7      1.2e-07 	(0.00130963 -0.0394396   0.269146  -0.616852   0.308427   0.394039 -0.0290467  -0.351558  -0.257763   0.322839 )
X 8      2.6e-09 	(         0 0.00283669 -0.0518273   0.279691  -0.562661   0.245453   0.411889  -0.123976  -0.511031   0.309951 )
X 9        2e-09 	(        -0 0.000267683 -0.0073021  0.0653878  -0.271881   0.589665   -0.67155    0.34876 -0.0243657 -0.0290013 )
X 10      2.4e-09 	(        -0 -0.000503957  0.0115796 -0.0849961   0.267981  -0.339047 -0.0717925   0.633468  -0.603703   0.187034 )
X
XMatrix 2x10 'true vs. computed solution' is as follows
X
X     |        1  |        2  |        3  |        4  |        5  |        6  |
X-------------------------------------------------------------------------------
X   1 |          1            2            3            4            5            6  
X   2 |     0.9995         2.01        2.955        4.055        5.013        5.971  
X
X
X     |        7  |        8  |        9  |       10  |
X-------------------------------------------------------------------------------
X   1 |          7            8            9           10  
X   2 |      6.975        8.004        9.022        9.996  
XDone
X	checking to see that Ax is indeed b
XTwo (5,1) elements of matrices with values 5.32709 and 5.32708
Xdiffer the most, though the deviation 9.53674e-07 is small
X
XCompilation finished at Thu Dec 21 13:36:13
________This_Is_The_END________
if test `wc -l < vslesing.dat` -ne 82; then
echo 'shar: vslesing.dat was damaged during transit (should have had 82 lines)'
fi


echo 'x - vsvd.dat'
sed 's/^X//' << '________This_Is_The_END________' > vsvd.dat
X./vsvd
X
X
XTesting Singular Value Decompositions of rectangular matrices
X
XRotated by PI/2 Matrix Diag(1,4,9)
X
X
X
XSVD-decompose matrix A and check if we can compose it back
X
X
XMatrix 3x3 'original matrix' is as follows
X
X     |        1  |        2  |        3  |
X-------------------------------------------------------------------------------
X   1 |          0           -4            0  
X   2 |          1            0            0  
X   3 |          0            0            9  
XDone
X
XMatrix 3x3 'left factor U' is as follows
X
X     |        1  |        2  |        3  |
X-------------------------------------------------------------------------------
X   1 |          0           -1            0  
X   2 |          1            0            0  
X   3 |          0            0           -1  
XDone
X
XMatrix 3x1 'Vector of Singular values' is as follows
X
X     |        1  |
X-------------------------------------------------------------------------------
X   1 |          1  
X   2 |          4  
X   3 |          9  
XDone
X
XMatrix 3x3 'right factor V' is as follows
X
X     |        1  |        2  |        3  |
X-------------------------------------------------------------------------------
X   1 |          1            0           -0  
X   2 |          0            1           -0  
X   3 |          0            0           -1  
XDone
X	checking that U is orthogonal indeed, i.e., U'U=E and UU'=E
X	checking that V is orthogonal indeed, i.e., V'V=E and VV'=E
X	checking that U*Sig*V' is indeed A
X
X
XComparison of two Matrices:
X	Original A and composed USigV'
XMatrix 1:3x1:3 ''
XMatrix 1:3x1:3 ''
XMaximal discrepancy    		0
X   occured at the point		(1,1)
X Matrix 1 element is    		0
X Matrix 2 element is    		0
X Absolute error v2[i]-v1[i]		0
X Relative error				0
X
X||Matrix 1||   			14
X||Matrix 2||   			14
X||Matrix1-Matrix2||				0
X||Matrix1-Matrix2||/sqrt(||Matrix1|| ||Matrix2||)	0
X
X
XDone
X
XExample from the Forsythe, Malcolm, Moler's book
X
X
X
XSVD-decompose matrix A and check if we can compose it back
X
X
XMatrix 5x3 'original matrix' is as follows
X
X     |        1  |        2  |        3  |
X-------------------------------------------------------------------------------
X   1 |          1            6           11  
X   2 |          2            7           12  
X   3 |          3            8           13  
X   4 |          4            9           14  
X   5 |          5           10           15  
XDone
X
XMatrix 5x5 'left factor U' is as follows
X
X     |        1  |        2  |        3  |        4  |        5  |
X-------------------------------------------------------------------------------
X   1 |    -0.3546      -0.6887       0.6166       0.1053      0.09335  
X   2 |    -0.3987      -0.3756       -0.719       0.0332       0.4266  
X   3 |    -0.4428     -0.06242      -0.1225      -0.6264      -0.6266  
X   4 |     -0.487       0.2507     -0.06442        0.732         -0.4  
X   5 |    -0.5311       0.5638       0.2893      -0.2441       0.5066  
XDone
X
XMatrix 3x1 'Vector of Singular values' is as follows
X
X     |        1  |
X-------------------------------------------------------------------------------
X   1 |      35.13  
X   2 |      2.465  
X   3 |  9.384e-07  
XDone
X
XMatrix 3x3 'right factor V' is as follows
X
X     |        1  |        2  |        3  |
X-------------------------------------------------------------------------------
X   1 |    -0.2017       0.8903       0.4082  
X   2 |    -0.5168       0.2573      -0.8165  
X   3 |     -0.832      -0.3757       0.4082  
XDone
X	checking that U is orthogonal indeed, i.e., U'U=E and UU'=E
XTwo (3,3) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 3.57628e-07 is small
XTwo (1,1) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 2.98023e-07 is small
X	checking that V is orthogonal indeed, i.e., V'V=E and VV'=E
XTwo (3,3) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 2.38419e-07 is small
XTwo (2,2) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 2.38419e-07 is small
X	checking that U*Sig*V' is indeed A
X
X
XComparison of two Matrices:
X	Original A and composed USigV'
XMatrix 1:5x1:3 ''
XMatrix 1:5x1:3 ''
XMaximal discrepancy    		2.86102e-06
X   occured at the point		(3,3)
X Matrix 1 element is    		13
X Matrix 2 element is    		13
X Absolute error v2[i]-v1[i]		2.86102e-06
X Relative error				2.20079e-07
X
X||Matrix 1||   			120
X||Matrix 2||   			120
X||Matrix1-Matrix2||				1.75238e-05
X||Matrix1-Matrix2||/sqrt(||Matrix1|| ||Matrix2||)	1.46031e-07
X
X
XDone
X
XExample from the Wilkinson, Reinsch's book
XSingular numbers are 0, 19.5959, 20, 0, 35.3270
X
X
X
XSVD-decompose matrix A and check if we can compose it back
X
X
XMatrix 8x5 'original matrix' is as follows
X
X     |        1  |        2  |        3  |        4  |        5  |
X-------------------------------------------------------------------------------
X   1 |         22           10            2            3            7  
X   2 |         14            7           10            0            8  
X   3 |         -1           13           -1          -11            3  
X   4 |         -3           -2           13           -2            4  
X   5 |          9            8            1           -2            4  
X   6 |          9            1           -7            5           -1  
X   7 |          2           -6            6            5            1  
X   8 |          4            5            0           -2            2  
XDone
X
XMatrix 8x8 'left factor U' is as follows
X
X     |        1  |        2  |        3  |        4  |        5  |        6  |
X-------------------------------------------------------------------------------
X   1 |    -0.7071     -0.03946      -0.1581      -0.1768      -0.6103      -0.2525  
X   2 |    -0.5303     -0.06776      -0.1581       0.3536       0.6684      -0.2045  
X   3 |    -0.1768       0.5426       0.7906       0.1768     -0.04694     -0.06163  
X   4 |  1.311e-08      0.01842      -0.1581       0.7071      -0.3594       0.4664  
X   5 |    -0.3536      -0.2384       0.1581   -1.454e-06       0.1153       0.6245  
X   6 |    -0.1768       0.4018      -0.1581      -0.5303       0.1656       0.5169  
X   7 |  1.508e-08       0.6852      -0.4743       0.1768      0.03423     -0.09679  
X   8 |    -0.1768      -0.1064       0.1581   -1.467e-06      0.08647     -0.08057  
X
X
X     |        7  |        8  |
X-------------------------------------------------------------------------------
X   1 |   -0.02099     -0.07445  
X   2 |    -0.2291      -0.1517  
X   3 |   -0.03788      -0.1029  
X   4 |    -0.3412       0.1073  
X   5 |     0.6179     -0.08938  
X   6 |    -0.4479      0.07655  
X   7 |     0.4963       0.1322  
X   8 |    0.02121       0.9581  
XDone
X
XMatrix 5x1 'Vector of Singular values' is as follows
X
X     |        1  |
X-------------------------------------------------------------------------------
X   1 |      35.33  
X   2 |   1.68e-06  
X   3 |         20  
X   4 |       19.6  
X   5 |  9.104e-07  
XDone
X
XMatrix 5x5 'right factor V' is as follows
X
X     |        1  |        2  |        3  |        4  |        5  |
X-------------------------------------------------------------------------------
X   1 |    -0.8006       0.4191      -0.3162      -0.2887           -0  
X   2 |    -0.4804      -0.4405       0.6325   -5.918e-06      -0.4185  
X   3 |    -0.1601        0.052      -0.3162        0.866      -0.3488  
X   4 | -1.965e-08      -0.6761      -0.6325      -0.2887      -0.2442  
X   5 |    -0.3203       -0.413    2.661e-06       0.2887       0.8022  
XDone
X	checking that U is orthogonal indeed, i.e., U'U=E and UU'=E
XTwo (1,1) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 2.38419e-07 is small
XTwo (1,1) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 3.57628e-07 is small
X	checking that V is orthogonal indeed, i.e., V'V=E and VV'=E
XTwo (2,2) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 3.57628e-07 is small
XTwo (4,4) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 2.38419e-07 is small
X	checking that U*Sig*V' is indeed A
X
X
XComparison of two Matrices:
X	Original A and composed USigV'
XMatrix 1:8x1:5 ''
XMatrix 1:8x1:5 ''
XMaximal discrepancy    		0.000183582
X   occured at the point		(7,4)
X Matrix 1 element is    		5
X Matrix 2 element is    		4.99982
X Absolute error v2[i]-v1[i]		-0.000183582
X Relative error				-3.67171e-05
X
X||Matrix 1||   			216
X||Matrix 2||   			216
X||Matrix1-Matrix2||				0.00169549
X||Matrix1-Matrix2||/sqrt(||Matrix1|| ||Matrix2||)	7.84949e-06
X
X
XDone
X
XExample from the Wilkinson, Reinsch's book
XOrdered singular numbers are Sig[21-k] = sqrt(k*(k-1))
X
X
X
XSVD-decompose matrix A and check if we can compose it back
X
X
XMatrix 21x20 'original matrix' is as follows
X
X     |        1  |        2  |        3  |        4  |        5  |        6  |
X-------------------------------------------------------------------------------
X   1 |         20            0            0            0            0            0  
X   2 |         -1           19            0            0            0            0  
X   3 |         -1           -1           18            0            0            0  
X   4 |         -1           -1           -1           17            0            0  
X   5 |         -1           -1           -1           -1           16            0  
X   6 |         -1           -1           -1           -1           -1           15  
X   7 |         -1           -1           -1           -1           -1           -1  
X   8 |         -1           -1           -1           -1           -1           -1  
X   9 |         -1           -1           -1           -1           -1           -1  
X  10 |         -1           -1           -1           -1           -1           -1  
X  11 |         -1           -1           -1           -1           -1           -1  
X  12 |         -1           -1           -1           -1           -1           -1  
X  13 |         -1           -1           -1           -1           -1           -1  
X  14 |         -1           -1           -1           -1           -1           -1  
X  15 |         -1           -1           -1           -1           -1           -1  
X  16 |         -1           -1           -1           -1           -1           -1  
X  17 |         -1           -1           -1           -1           -1           -1  
X  18 |         -1           -1           -1           -1           -1           -1  
X  19 |         -1           -1           -1           -1           -1           -1  
X  20 |         -1           -1           -1           -1           -1           -1  
X  21 |         -1           -1           -1           -1           -1           -1  
X
X
X     |        7  |        8  |        9  |       10  |       11  |       12  |
X-------------------------------------------------------------------------------
X   1 |          0            0            0            0            0            0  
X   2 |          0            0            0            0            0            0  
X   3 |          0            0            0            0            0            0  
X   4 |          0            0            0            0            0            0  
X   5 |          0            0            0            0            0            0  
X   6 |          0            0            0            0            0            0  
X   7 |         14            0            0            0            0            0  
X   8 |         -1           13            0            0            0            0  
X   9 |         -1           -1           12            0            0            0  
X  10 |         -1           -1           -1           11            0            0  
X  11 |         -1           -1           -1           -1           10            0  
X  12 |         -1           -1           -1           -1           -1            9  
X  13 |         -1           -1           -1           -1           -1           -1  
X  14 |         -1           -1           -1           -1           -1           -1  
X  15 |         -1           -1           -1           -1           -1           -1  
X  16 |         -1           -1           -1           -1           -1           -1  
X  17 |         -1           -1           -1           -1           -1           -1  
X  18 |         -1           -1           -1           -1           -1           -1  
X  19 |         -1           -1           -1           -1           -1           -1  
X  20 |         -1           -1           -1           -1           -1           -1  
X  21 |         -1           -1           -1           -1           -1           -1  
X
X
X     |       13  |       14  |       15  |       16  |       17  |       18  |
X-------------------------------------------------------------------------------
X   1 |          0            0            0            0            0            0  
X   2 |          0            0            0            0            0            0  
X   3 |          0            0            0            0            0            0  
X   4 |          0            0            0            0            0            0  
X   5 |          0            0            0            0            0            0  
X   6 |          0            0            0            0            0            0  
X   7 |          0            0            0            0            0            0  
X   8 |          0            0            0            0            0            0  
X   9 |          0            0            0            0            0            0  
X  10 |          0            0            0            0            0            0  
X  11 |          0            0            0            0            0            0  
X  12 |          0            0            0            0            0            0  
X  13 |          8            0            0            0            0            0  
X  14 |         -1            7            0            0            0            0  
X  15 |         -1           -1            6            0            0            0  
X  16 |         -1           -1           -1            5            0            0  
X  17 |         -1           -1           -1           -1            4            0  
X  18 |         -1           -1           -1           -1           -1            3  
X  19 |         -1           -1           -1           -1           -1           -1  
X  20 |         -1           -1           -1           -1           -1           -1  
X  21 |         -1           -1           -1           -1           -1           -1  
X
X
X     |       19  |       20  |
X-------------------------------------------------------------------------------
X   1 |          0            0  
X   2 |          0            0  
X   3 |          0            0  
X   4 |          0            0  
X   5 |          0            0  
X   6 |          0            0  
X   7 |          0            0  
X   8 |          0            0  
X   9 |          0            0  
X  10 |          0            0  
X  11 |          0            0  
X  12 |          0            0  
X  13 |          0            0  
X  14 |          0            0  
X  15 |          0            0  
X  16 |          0            0  
X  17 |          0            0  
X  18 |          0            0  
X  19 |          2            0  
X  20 |         -1            1  
X  21 |         -1           -1  
XDone
X
XMatrix 21x21 'left factor U' is as follows
X
X     |        1  |        2  |        3  |        4  |        5  |        6  |
X-------------------------------------------------------------------------------
X   1 |    -0.9759   -4.095e-08    1.767e-08   -2.713e-08    1.757e-08   -7.124e-09  
X   2 |     0.0488      -0.9747    8.635e-07    3.587e-07    2.681e-07    2.432e-07  
X   3 |     0.0488       0.0513       0.9733    4.814e-06   -1.079e-06    2.803e-07  
X   4 |     0.0488       0.0513     -0.05407      -0.9718     1.46e-06   -7.789e-07  
X   5 |     0.0488       0.0513     -0.05407      0.05717       0.9701   -1.823e-06  
X   6 |     0.0488       0.0513     -0.05407      0.05717     -0.06064      -0.9682  
X   7 |     0.0488       0.0513     -0.05407      0.05717     -0.06063      0.06455  
X   8 |     0.0488       0.0513     -0.05407      0.05717     -0.06063      0.06455  
X   9 |     0.0488       0.0513     -0.05407      0.05717     -0.06063      0.06455  
X  10 |     0.0488       0.0513     -0.05407      0.05717     -0.06063      0.06455  
X  11 |     0.0488       0.0513     -0.05407      0.05717     -0.06063      0.06455  
X  12 |     0.0488       0.0513     -0.05407      0.05717     -0.06063      0.06455  
X  13 |     0.0488       0.0513     -0.05407      0.05717     -0.06063      0.06455  
X  14 |     0.0488       0.0513     -0.05407      0.05717     -0.06063      0.06455  
X  15 |     0.0488       0.0513     -0.05407      0.05717     -0.06063      0.06455  
X  16 |     0.0488       0.0513     -0.05407      0.05717     -0.06063      0.06455  
X  17 |     0.0488       0.0513     -0.05407      0.05717     -0.06063      0.06455  
X  18 |     0.0488       0.0513     -0.05407      0.05717     -0.06063      0.06455  
X  19 |     0.0488       0.0513     -0.05407      0.05717     -0.06063      0.06455  
X  20 |     0.0488       0.0513     -0.05407      0.05717     -0.06063      0.06455  
X  21 |     0.0488       0.0513     -0.05407      0.05717     -0.06063      0.06455  
X
X
X     |        7  |        8  |        9  |       10  |       11  |       12  |
X-------------------------------------------------------------------------------
X   1 |  2.486e-08    6.731e-09   -9.373e-09    9.659e-09   -1.144e-08   -9.359e-09  
X   2 |  6.808e-08   -5.892e-08    7.785e-08   -3.504e-08   -5.099e-08    -1.34e-08  
X   3 |  2.512e-07    9.843e-09   -6.221e-08    7.137e-08   -1.551e-08    2.324e-08  
X   4 |  4.116e-08    2.003e-07   -1.408e-07   -1.039e-08   -4.991e-08   -4.367e-08  
X   5 |  2.638e-07    4.923e-07    2.782e-08    1.616e-07    4.685e-08    3.014e-08  
X   6 |  1.303e-07   -1.072e-06    4.913e-07   -1.197e-07    -2.69e-08   -3.101e-08  
X   7 |     0.9661    2.784e-07   -5.652e-07   -2.362e-07   -1.044e-08   -3.633e-08  
X   8 |   -0.06901      -0.9636    4.532e-08     8.45e-07   -3.746e-08    3.281e-08  
X   9 |   -0.06901      0.07413       0.9608   -3.124e-07   -5.702e-08   -1.639e-07  
X  10 |   -0.06901      0.07412     -0.08006      -0.9574    1.044e-07   -8.008e-08  
X  11 |   -0.06901      0.07412     -0.08006      0.08704   -4.482e-08    1.681e-08  
X  12 |   -0.06901      0.07413     -0.08006      0.08704    1.904e-08   -7.904e-08  
X  13 |   -0.06901      0.07413     -0.08006      0.08704   -1.713e-08   -2.406e-08  
X  14 |   -0.06901      0.07413     -0.08006      0.08704   -7.757e-08   -1.581e-07  
X  15 |   -0.06901      0.07412     -0.08006      0.08704   -4.425e-08    3.589e-07  
X  16 |   -0.06901      0.07412     -0.08006      0.08704     3.33e-08   -6.292e-07  
X  17 |   -0.06901      0.07413     -0.08006      0.08704    7.644e-07       0.8944  
X  18 |   -0.06901      0.07413     -0.08006      0.08704        0.866      -0.2236  
X  19 |   -0.06901      0.07413     -0.08006      0.08704      -0.2887      -0.2236  
X  20 |   -0.06901      0.07413     -0.08006      0.08704      -0.2887      -0.2236  
X  21 |   -0.06901      0.07413     -0.08006      0.08704      -0.2887      -0.2236  
X
X
X     |       13  |       14  |       15  |       16  |       17  |       18  |
X-------------------------------------------------------------------------------
X   1 |  1.391e-08   -9.727e-09    1.067e-08   -2.434e-08   -1.654e-08     2.61e-09  
X   2 |  1.017e-07    3.413e-08   -2.416e-09   -2.995e-08    6.259e-09    -2.96e-08  
X   3 | -4.168e-08    9.599e-09   -3.509e-10   -5.563e-08   -4.289e-08    3.442e-08  
X   4 | -1.997e-08   -2.667e-09    7.045e-08    5.761e-08    9.413e-08   -1.049e-08  
X   5 |  7.251e-08   -7.809e-08    -5.69e-08   -1.432e-07   -2.392e-08    5.154e-08  
X   6 |  1.764e-07   -1.286e-08   -1.926e-08   -7.413e-08   -5.636e-08   -9.843e-08  
X   7 | -1.487e-07   -2.275e-08   -4.862e-09   -1.748e-08    3.387e-09    6.055e-08  
X   8 | -3.698e-07     7.57e-08    1.916e-07    1.688e-07    9.031e-08   -1.862e-07  
X   9 |  1.494e-07    1.141e-07   -4.602e-08   -9.542e-08   -3.133e-09    2.031e-08  
X  10 |  2.566e-07   -1.433e-08    6.778e-08     8.76e-08   -7.368e-10    4.719e-07  
X  11 |     0.9535   -1.111e-07    3.644e-08    -1.64e-07   -2.235e-09    -2.98e-07  
X  12 |   -0.09535    3.256e-08   -7.177e-08    1.446e-07    1.877e-07      -0.9487  
X  13 |   -0.09535    1.626e-07   -1.822e-07    7.215e-10       0.9428       0.1054  
X  14 |   -0.09535   -2.721e-09    5.527e-07       0.9354      -0.1179       0.1054  
X  15 |   -0.09535    4.515e-07      -0.9258      -0.1336      -0.1179       0.1054  
X  16 |   -0.09535      -0.9129       0.1543      -0.1336      -0.1179       0.1054  
X  17 |   -0.09535       0.1826       0.1543      -0.1336      -0.1179       0.1054  
X  18 |   -0.09535       0.1826       0.1543      -0.1336      -0.1179       0.1054  
X  19 |   -0.09535       0.1826       0.1543      -0.1336      -0.1179       0.1054  
X  20 |   -0.09535       0.1826       0.1543      -0.1336      -0.1179       0.1054  
X  21 |   -0.09535       0.1826       0.1543      -0.1336      -0.1179       0.1054  
X
X
X     |       19  |       20  |       21  |
X-------------------------------------------------------------------------------
X   1 |   1.49e-08    -1.49e-08       0.2182  
X   2 |   1.49e-08    -1.49e-08       0.2182  
X   3 |          0    -1.49e-08       0.2182  
X   4 |   1.49e-08    -1.49e-08       0.2182  
X   5 |          0            0       0.2182  
X   6 |          0            0       0.2182  
X   7 |  -1.49e-08            0       0.2182  
X   8 |          0            0       0.2182  
X   9 |   1.49e-08    -1.49e-08       0.2182  
X  10 |          0    -1.49e-08       0.2182  
X  11 |   1.49e-08    -1.49e-08       0.2182  
X  12 |   1.49e-08    -1.49e-08       0.2182  
X  13 |          0            0       0.2182  
X  14 |   1.49e-08    -1.49e-08       0.2182  
X  15 |          0            0       0.2182  
X  16 |  -1.49e-08            0       0.2182  
X  17 |   1.49e-08    -1.49e-08       0.2182  
X  18 |   1.49e-08    -1.49e-08       0.2182  
X  19 |    -0.8165            0       0.2182  
X  20 |     0.4082      -0.7071       0.2182  
X  21 |     0.4082       0.7071       0.2182  
XDone
X
XMatrix 20x1 'Vector of Singular values' is as follows
X
X     |        1  |
X-------------------------------------------------------------------------------
X   1 |      20.49  
X   2 |      19.49  
X   3 |      18.49  
X   4 |      17.49  
X   5 |      16.49  
X   6 |      15.49  
X   7 |      14.49  
X   8 |      13.49  
X   9 |      12.49  
X  10 |      11.49  
X  11 |      3.464  
X  12 |      4.472  
X  13 |      10.49  
X  14 |      5.477  
X  15 |      6.481  
X  16 |      7.483  
X  17 |      8.485  
X  18 |      9.487  
X  19 |      2.449  
X  20 |      1.414  
XDone
X
XMatrix 20x20 'right factor V' is as follows
X
X     |        1  |        2  |        3  |        4  |        5  |        6  |
X-------------------------------------------------------------------------------
X   1 |         -1            0            0            0            0            0  
X   2 |         -0           -1    8.733e-07    3.631e-07    2.226e-07     2.17e-07  
X   3 |         -0    9.606e-07            1    4.574e-06   -9.265e-07    2.435e-07  
X   4 |         -0   -2.576e-07    5.031e-06           -1    1.709e-06   -7.874e-07  
X   5 |         -0    2.822e-07    1.263e-06    1.713e-06            1   -2.022e-06  
X   6 |         -0   -2.161e-07    2.623e-07    7.707e-07   -2.071e-06           -1  
X   7 |         -0    1.253e-07   -9.179e-08    5.592e-09   -3.293e-07    1.787e-07  
X   8 |         -0    6.207e-08    -9.77e-08   -6.128e-08    4.345e-07    1.018e-06  
X   9 |         -0    1.075e-07    1.252e-07   -5.056e-08   -1.534e-07    5.333e-07  
X  10 |         -0   -1.147e-08    9.892e-09   -8.341e-09    8.645e-08    2.383e-07  
X  11 |         -0    1.235e-07    9.021e-08   -1.972e-07   -7.138e-08    2.493e-07  
X  12 |         -0     4.29e-08    3.784e-08     4.01e-09    4.182e-08    1.049e-07  
X  13 |         -0    1.411e-08    6.802e-08    4.786e-08   -4.339e-08   -4.655e-08  
X  14 |         -0    7.549e-09    3.531e-08    7.561e-08    6.757e-08   -5.275e-08  
X  15 |         -0    2.235e-09   -5.335e-09   -1.194e-07    1.168e-08    2.061e-07  
X  16 |         -0   -3.959e-08    -1.39e-09    -1.57e-08   -7.327e-08    5.843e-09  
X  17 |         -0   -7.109e-09   -2.587e-08   -1.794e-08   -3.977e-09    8.712e-08  
X  18 |         -0    4.421e-08    1.081e-07   -1.485e-07   -1.527e-07    1.571e-07  
X  19 |         -0            0            0            0            0            0  
X  20 |         -0            0            0            0            0            0  
X
X
X     |        7  |        8  |        9  |       10  |       11  |       12  |
X-------------------------------------------------------------------------------
X   1 |          0            0            0            0           -0            0  
X   2 |  8.372e-08   -9.309e-08    1.186e-07   -2.382e-08    1.438e-08   -1.895e-08  
X   3 |  2.497e-07    6.421e-09   -1.498e-07   -1.138e-09    -9.71e-08    3.628e-08  
X   4 |  8.699e-08    4.349e-09   -1.606e-09   -6.296e-10   -6.377e-08    4.847e-08  
X   5 |  1.416e-07    4.805e-07    6.316e-08    1.552e-07    2.383e-08   -2.962e-08  
X   6 |  2.541e-07   -9.759e-07    6.023e-07   -2.318e-07    9.485e-08     2.37e-08  
X   7 |          1    5.184e-07   -7.591e-07   -1.321e-07   -4.625e-08   -6.943e-08  
X   8 |   3.69e-07           -1    5.759e-08    9.817e-07   -1.118e-07    6.008e-09  
X   9 |  6.579e-07    7.437e-08            1   -3.081e-07    -6.81e-08   -5.932e-08  
X  10 | -2.191e-07   -9.217e-07   -1.444e-07           -1   -6.705e-08    5.446e-09  
X  11 |  2.392e-07   -4.343e-07   -1.277e-07    2.377e-07   -4.575e-08   -8.325e-08  
X  12 |  4.749e-08    2.203e-07   -3.073e-08   -4.633e-07   -3.498e-08    8.268e-09  
X  13 |  -2.35e-08    8.759e-08   -1.892e-08   -2.106e-07    1.601e-08     7.95e-09  
X  14 |   -3.1e-08    1.872e-07    5.452e-08    4.202e-08   -1.141e-07   -8.244e-08  
X  15 |  6.716e-08   -1.977e-07   -1.687e-08   -4.409e-08   -6.138e-08    2.814e-07  
X  16 |  1.015e-08   -6.073e-09    1.122e-07   -4.952e-08     1.24e-07   -5.649e-07  
X  17 |  1.054e-07   -6.554e-08    7.516e-08   -8.275e-08    9.987e-07            1  
X  18 |  1.382e-07   -3.202e-08    1.087e-07   -1.805e-07            1    -8.85e-07  
X  19 |          0            0            0            0           -0            0  
X  20 |          0            0            0            0           -0            0  
X
X
X     |       13  |       14  |       15  |       16  |       17  |       18  |
X-------------------------------------------------------------------------------
X   1 |          0            0           -0           -0            0            0  
X   2 |  9.101e-08    2.642e-08    1.238e-08    8.276e-09    4.795e-09    -3.74e-08  
X   3 | -7.475e-08    2.302e-08   -9.278e-09   -4.053e-08   -5.093e-08     2.96e-08  
X   4 | -1.164e-07   -1.122e-07    5.952e-08    2.598e-08    1.008e-08    1.171e-08  
X   5 |   6.31e-08    1.399e-08    1.713e-08   -6.629e-08    3.286e-08    1.453e-08  
X   6 |  7.262e-08     2.28e-08   -9.427e-08   -9.596e-09   -2.287e-08   -8.782e-08  
X   7 | -2.033e-07   -5.151e-08    3.428e-08    2.055e-08    6.664e-08    4.036e-08  
X   8 | -3.465e-07   -1.261e-08      2.3e-07    1.227e-07   -5.424e-08   -1.082e-07  
X   9 |  4.946e-08    5.458e-08    -6.14e-08    6.928e-09    9.743e-08   -6.766e-08  
X  10 |   2.56e-07    6.695e-08    3.678e-08     1.97e-08   -1.303e-07     3.79e-07  
X  11 |          1   -4.445e-08   -2.748e-08   -1.376e-07    4.027e-08   -2.889e-07  
X  12 | -4.329e-07    2.456e-09   -3.241e-08   -1.383e-08    3.099e-07           -1  
X  13 | -1.472e-07    2.693e-07   -2.565e-07    1.077e-07            1    9.315e-08  
X  14 |   8.94e-08   -6.006e-08    5.375e-07            1   -1.792e-07    1.449e-07  
X  15 |  1.638e-07    4.652e-07           -1    6.158e-07   -2.732e-07    5.461e-08  
X  16 | -4.486e-09           -1   -5.555e-07   -1.692e-07      2.7e-07     -1.2e-07  
X  17 |  3.161e-08   -8.017e-07     2.84e-07    1.869e-07    1.679e-08    4.861e-08  
X  18 |   7.57e-08    8.651e-08   -1.568e-07    7.022e-09   -5.411e-08     -5.8e-08  
X  19 |          0            0           -0           -0            0            0  
X  20 |          0            0           -0           -0            0            0  
X
X
X     |       19  |       20  |
X-------------------------------------------------------------------------------
X   1 |         -0           -0  
X   2 |         -0           -0  
X   3 |         -0           -0  
X   4 |         -0           -0  
X   5 |         -0           -0  
X   6 |         -0           -0  
X   7 |         -0           -0  
X   8 |         -0           -0  
X   9 |         -0           -0  
X  10 |         -0           -0  
X  11 |         -0           -0  
X  12 |         -0           -0  
X  13 |         -0           -0  
X  14 |         -0           -0  
X  15 |         -0           -0  
X  16 |         -0           -0  
X  17 |         -0           -0  
X  18 |         -0           -0  
X  19 |         -1           -0  
X  20 |         -0           -1  
XDone
X	checking that U is orthogonal indeed, i.e., U'U=E and UU'=E
XTwo (4,4) elements of matrices with values 0.999999 and 1
Xdiffer the most, though the deviation 7.15256e-07 is small
XTwo (4,4) elements of matrices with values 0.999999 and 1
Xdiffer the most, though the deviation 7.7486e-07 is small
X	checking that V is orthogonal indeed, i.e., V'V=E and VV'=E
XTwo (4,4) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 7.15256e-07 is small
XTwo (4,4) elements of matrices with values 1 and 1
Xdiffer the most, though the deviation 7.15256e-07 is small
X	checking that U*Sig*V' is indeed A
X
X
XComparison of two Matrices:
X	Original A and composed USigV'
XMatrix 1:21x1:20 ''
XMatrix 1:21x1:20 ''
XMaximal discrepancy    		1.33514e-05
X   occured at the point		(3,3)
X Matrix 1 element is    		18
X Matrix 2 element is    		18
X Absolute error v2[i]-v1[i]		1.33514e-05
X Relative error				7.41746e-07
X
X||Matrix 1||   			420
X||Matrix 2||   			420
X||Matrix1-Matrix2||				0.00037723
X||Matrix1-Matrix2||/sqrt(||Matrix1|| ||Matrix2||)	8.98168e-07
X
X
XDone
X
XCompilation finished at Thu Dec 21 13:34:29
________This_Is_The_END________
if test `wc -l < vsvd.dat` -ne 618; then
echo 'shar: vsvd.dat was damaged during transit (should have had 618 lines)'
fi


echo 'x - vvector.dat'
sed 's/^X//' << '________This_Is_The_END________' > vvector.dat
X./vvector
X
X
X-------------------------------------------------------------------------------
X		Verify Operations on Vectors
X
X
X---> Test allocation and compatibility check
XThe following vector have been allocated
X
XMatrix 1:20x1:1 ''
XMatrix 1:20x1:1 ''
XMatrix 0:19x1:1 ''
XMatrix 1:20x1:1 ''
XStatus information reported for vector v3:
X  Lower bound ... 0
X  Upper bound ... 19
X  No. of elements 20
X  Name 
X
XCheck vectors 1 & 2 for compatibility
XCheck vectors 1 & 4 for compatibility
Xv2 has to be compatible with v3 after resizing to v3
Xv1 has to be compatible with v5 after resizing to v5.upb
X
XMatrix 1:25x1:1 'Vector v5'
XCheck that shrinking does not change remaining elements
XCheck that expansion expands by zeros
X
XDone
X
X
X---> Test operations that treat each element uniformly
XWriting zeros to v...
XClearing v1 ...
XComparing v1 with 0 ...
XWriting a pattern 3.14159 by assigning to v(i)...
XWriting the pattern by assigning to v1 as a whole ...
XComparing v and v1 ...
XComparing (v=0) and v1 ...
X
XClear v and add the pattern
X   add the doubled pattern with the negative sign
XElement (18,1) with value -3.14159 differs the most from what
Xwas expected, -3.14159, though the deviation 2.38419e-07 is small
X   subtract the trippled pattern with the negative sign
X
XVerify comparison operations
X
XAssign 2*pattern to v by repeating additions
XAssign 2*pattern to v1 by multiplying by two 
XMultiply v1 by one half returning it to the 1*pattern
X
XAssign -pattern to v and v1
Xv = sqrt(sqr(v)); v1 = abs(v1); Now v and v1 have to be the same
XElement (18,1) with value 9.86961 differs the most from what
Xwas expected, 9.8696, though the deviation 9.53674e-07 is small
X
XCheck out to see that sin^2(x) + cos^2(x) = 1
XElement (17,1) with value 1 differs the most from what
Xwas expected, 1, though the deviation 2.38419e-07 is small
X
X	do it again through LazyMatrix promise of a vector
XElement (17,1) with value 1 differs the most from what
Xwas expected, 1, though the deviation 2.38419e-07 is small
XElement (17,1) with value 1 differs the most from what
Xwas expected, 1, though the deviation 2.38419e-07 is small
X
XVerify constructor with initialization
X
XDone
X
X
X---> Test Binary Vector operations
X
XVerify assignment of a vector to the vector
X
XAdding one vector to itself, uniform pattern 3.14159
X  subtracting two vectors ...
X  subtracting the vector from itself
X  adding two vectors together
X
XArithmetic operations on vectors with not the same elements
X   adding vp to the zero vector...
X   making v = 3*vp and v1 = 3*vp, via add() and succesive mult
X   clear both v and v1, by subtracting from itself and via add()
XTwo (19,1) elements of matrices with values -3.8147e-06 and 0
Xdiffer the most, though the deviation 3.8147e-06 is small
X
XTesting element-by-element multiplications and divisions
X   squaring each element with sqr() and via multiplication
X   compare (v = pattern^2)/pattern with pattern
X
X
XComparison of two Matrices:
X	Original vector and vector after squaring and dividing
XMatrix 2:21x1:1 ''
XMatrix 2:21x1:1 ''
XMaximal discrepancy    		0
X   occured at the point		(2,1)
X Matrix 1 element is    		3.14159
X Matrix 2 element is    		3.14159
X Absolute error v2[i]-v1[i]		0
X Relative error				0
X
X||Matrix 1||   			62.8319
X||Matrix 2||   			62.8319
X||Matrix1-Matrix2||				0
X||Matrix1-Matrix2||/sqrt(||Matrix1|| ||Matrix2||)	0
X
X
XDone
X
X---> Verify norm calculations
X
XAssign 10.25 to all the elements and check norms
X  1. norm should be pattern*no_elems
X  Square of the 2. norm has got to be pattern^2 * no_elems
X  Inf norm should be pattern itself
X  Scalar product of vector by itself is the sqr(2. vector norm)
X
XAssign the arithm progression with 1. term -10.25
Xand the difference 1
X  1. norm should be 100.5
X  Square of the 2. norm has got to be n*[ a0^2 + a0*q*(n-1) + q^2/6*(n-1)*(2n-1) ], or 676.25
X  Inf norm should be max(abs(a0),abs(a0+(n-1)*q)), ie 10.25
X  Scalar product of vector by itself is the sqr(2. vector norm)
X
X
XComparison of two Matrices:
X	Compare the vector v with a zero vector
XMatrix 1:20x1:1 ''
XMatrix 1:20x1:1 ''
XMaximal discrepancy    		10.25
X   occured at the point		(1,1)
X Matrix 1 element is    		-10.25
X Matrix 2 element is    		0
X Absolute error v2[i]-v1[i]		10.25
X Relative error				2
X
X||Matrix 1||   			100.5
X||Matrix 2||   			0
X||Matrix1-Matrix2||				100.5
X||Matrix1-Matrix2||/sqrt(||Matrix1|| ||Matrix2||)	1.005e+09
X
X
XConstruct v1 to be orthogonal to v as v(n), -v(n-1), v(n-2)...
X||v1|| has got to be equal ||v|| regardless of the norm def
XBut the scalar product has to be zero
X
XDone
X
X
X---> Test operations with vectors and matrix slices
X
XCheck modifying the matrix column-by-column
X
XCheck modifying the matrix row-by-row
X
XCheck modifying the matrix diagonal
X
XCheck out to see that multiplying by diagonal is column-wise
Xmatrix multiplication
X
XDone
X
XCompilation finished at Thu Dec 21 13:15:11
________This_Is_The_END________
if test `wc -l < vvector.dat` -ne 167; then
echo 'shar: vvector.dat was damaged during transit (should have had 167 lines)'
fi


echo 'x - vzeroin.dat'
sed 's/^X//' << '________This_Is_The_END________' > vzeroin.dat
X
X
X-------------------------------------------------------------------------------
X		Testing the Brent's root finder
X
X
XFor function x^3 - 2*x - 5,
Xthe root over [2,3] is	2.094551482e+00
XFunction value at the root found	-1.7764e-15
XNo. of iterations		11
XExact root is 		2.0945514815
X
XFor function cos(x)-x,
Xthe root over [2,3] is	2.000000000e+00
XFunction value at the root found	-2.4161e+00
XNo. of iterations		52
X
XFor function cos(x)-x,
Xthe root over [-1,3] is	7.390851332e-01
XFunction value at the root found	0.0000e+00
XNo. of iterations		11
X
XFor function sin(x)-x,
Xthe root over [-1,3] is	-1.643737357e-08
XFunction value at the root found	0.0000e+00
XNo. of iterations		58
X
XCompilation finished at Thu Dec 21 13:31:54
________This_Is_The_END________
if test `wc -l < vzeroin.dat` -ne 28; then
echo 'shar: vzeroin.dat was damaged during transit (should have had 28 lines)'
fi
