%{
// first-order logic language tokenizer
//
// language consists of the following symbols:
//
// constants:	a, b, c, ...
// variables:	x, y, z, ...
// functions:	f, g, h, ...
// predicates:	P, Q, R, ...
//
// functions and predicates can have a list of arguments, such as:
//
// f(a, b, c) or P(a, b, c)
//
// a function maps a list of constants to a constant.
//
// terms are defined recursively as follows:
//
// 1) a constant is a term.
// 2) a variable is a term.
// 3) if f is an n-place function, and t1, ..., tn are terms, then
// f(t1,...,tn) is a term.
// 4) nothing else is a term.
//
// a predicate is mapping of a list of constants to True or False.
//
// if P is an n-place predicate and t1, ..., tn are terms, then
// P(t1,...,tn) is an atom. Nothing else is an atom.
//
// well-formed formulas, WFF, are built as follows:
//
// 1) an atom is a formula.
// 2) if F and G are formulas, then the following are formulas: 
//
//	1) ~F
//	2) F || G
//	3) F && G
//	4) F --> G
//	5) F <--> G
//
// 3) If F is a formula and x is a variable free in F, then the following
// 	are formulas:
//
//	1) forall(x)F(x) or <x>F(x) (universal instantiation)
//	2) forsome(x)F(x) or [x]F(x) (existential instantiation)
//
// additional notation:
//
//	(, )  - parenthesis for grouping.
//	|- - "therefore ..."
//	?- - "query for ..."
//
// the language defined for this prover has a few "C"-isms, the
// operators are from C, and all lines must be terminated with a 
// semicolon.
//
/////////////////////////////////////////////////////////////////////
//

// headers
#include "folp.h"

// definitions generated by yacc
#include "folpyacc.h"

// other macros
#ifdef YYDEBUG
#define YYDUMP() fprintf(stdout, "token is <%s>.\n", yytext)
#else
#define YYDUMP() 
#endif

#define IFECHO if (echo) ECHO

#define GETTOKEN(tokenId) { \
	IFECHO; \
	YYDUMP(); \
	strcpy(yylval.cstring, yytext); \
	return(tokenId); \
}

%}
identifier		[a-z][a-zA-Z0-9_]*
pidentifier		[A-Z][a-zA-Z0-9_]*
number			\-?[0-9]+
minus			"-"
string			\"[^\"]*\"
whitespace		[ \t]+
pound			#[^\n]*"\n"
newline			"\n"
%%

{whitespace}	IFECHO;
{pound} 	IFECHO;
{newline}	IFECHO;

"|-"		GETTOKEN(THEREFORE);
"?-"		GETTOKEN(QUERY);
"<-->"		GETTOKEN(BICONDITIONAL);
"-->"		GETTOKEN(IMPLICATION);
"||"		GETTOKEN(OR);
"&&"		GETTOKEN(AND);
"~"		GETTOKEN(NEGATION);
"("		GETTOKEN(LPAREN);
")"		GETTOKEN(RPAREN);
":"		GETTOKEN(COLON);
","		GETTOKEN(COMMA);
";"		GETTOKEN(SEMICOLON);
"forall"	GETTOKEN(UNIVERSAL);
"<"		GETTOKEN(LEFTUNIVERSAL);
">"		GETTOKEN(RIGHTUNIVERSAL);
"forsome"	GETTOKEN(EXISTENTIAL);
"["		GETTOKEN(LEFTEXISTENTIAL);
"]"		GETTOKEN(RIGHTEXISTENTIAL);
"{"		GETTOKEN(LBRACE);
"}"		GETTOKEN(RBRACE);
"="		GETTOKEN(EQUAL);
"!="		GETTOKEN(NOTEQUAL);
"argument"	GETTOKEN(ARGUMENT);
"quit"		GETTOKEN(QUIT);
"true"		GETTOKEN(TRUE);
"false"		GETTOKEN(FALSE);
"SOS"		GETTOKEN(SOS);
"options"	GETTOKEN(OPTION);
{number}	GETTOKEN(NUMBER);
{minus}		GETTOKEN(MINUS);

{string}	{
		IFECHO;
		YYDUMP();
		yytext[strlen(yytext)-1] = 0;
		strcpy(yylval.cstring, yytext+1);
		return(STRING);
		}
{identifier}	GETTOKEN(IDENTIFIER);
{pidentifier}	GETTOKEN(PIDENTIFIER);
.		{
		IFECHO;
		YYDUMP();
		strcpy(yylval.cstring, yytext);
		return(*yytext);
		}

%%

// useless function
int
yywrap(void)
{
	return(1);
}

#if 0
main(int argc, char **argv)
{
	extern FILE *yyin;

	// tokenize a list of files
	for (int arg = 1; arg < argc; arg++)
	{
		// tell which file is scanned
		cout << "scanning file ... " << argv[arg] << endl;

		// open file to scan
		if ((yyin = fopen(argv[arg], "r")) == NULL)
		{
			ERRORD("fopen failed.", argv[arg], errno);
			continue;
		}

		// call scanner 
		while (yylex() != 0) ;
	}

	// all done
	return(0);
}
#endif




