
LUP MATRIX DECOMPOSITION USING TEMPLATES

I INTRODUCTION

Solving a set of linear equations is a very common problem in engineering.
Two examples are the sets of equations that arise from analyzing an 
electrical circuit or from statics. In either case, the set of linear 
equations has the following form:

	A(1,1)*X(1) + A(1,2)*X(2) + ... + A(1,N)*X(N) = Y(1)
	A(2,1)*X(1) + A(2,2)*X(2) + ... + A(2,N)*X(N) = Y(2)
		.
		.
		.
	A(N,1)*X(1) + A(N,2)*X(2) + ... + A(N,N)*X(N) = Y(N)

where A(i,j) is the i,j element of an NxN matrix, and X(i) and Y(i)
are vectors of N dimensions. In general, you know A and Y, and you have 
to solve for X.

There are several methods which are used to solve for the vector
X in the previous of set of equations. This article describes an 
implementation of one of these methods, LUP decomposition. LUP
decomposition is the method of choice for matrices that are dense 
(A(i,j) mostly non-zero) and for N less than a few hundred [1]. 
For matrices that are sparse (A(i,j) mostly zero) and for N greater 
than a few hundred, a set of techniques known as iterative methods 
is used to solve for X [2, 3].

II LUP DECOMPOSITION ALGORITHM

The set of equations listed before can be rewritten more concisely using 
matrix notation as follows:

	A*X = Y,

where A is an NxN matrix, and X and Y are vectors of N dimensions. Again,
A and Y are known, and X must be determined. 

The LUP decomposition method assumes that the matrix A can be rewritten
as the product of two matrices,

	A = L*U,

where the matrix L is assumed to be lower triangular (all L(i,j) above
the main diagonal are zero) and the matrix U is assumed to be upper triangular
(all U(i,j) below the main diagonal are zero). Substituting into the
original equation we get:

	A = L*U
	A*X = Y
	L*U*X = Y.

Now suppose that U*X = Z where Z is a new vector of N dimensions, then we 
can rewrite the original problem A*X = Y as follows,

	U*X = Z
	L*Z = Y.

What has this gained us? It turns out that the two new sets of equations
can be solved very efficiently since L and U are triangular matrices.
First we solve L*Z = Y for Z using forward substitution, then we solve
U*X = Z for X, the original problem, using backward substitution [4].

There are two common factorizations for the L and U matrices, Crout's and 
Doolittle's. Crout's factorization results with a U matrix which has
one's along the main diagonal, and Doolittle's factorization results
with an L matrix with ones along the the main diagonal. I have chosen
to use Gaussian elimination with pivoting and scaling to generate
a Doolittle factorization of the matrix A [4]. Since pivoting is required 
to maintain stability during Gaussian elimination, it is necessary 
to track how rows are switched. A permutation vector (the P in the name
LUP) is generated by the LUP decomposition function to record the row 
switches.

III IMPLEMENTATION

The LUP code is displayed in listings 1 through 6. It is based on the 
algorithms described in reference [4]. All the code was tested using the 
SUN Solaris 4.2 C++ compiler (without the use of #pragmas). All the 
code is also available from the CUJ FTP site.

Listings 1 and 2 display the headers of the vector and matrix classes
used in the LUP code. The LUP code requires the Matrix class to have
a constructor of the form Matrix<T>(unsigned int number_of_rows,
unsigned int number_of_columns) and an access operator of the 
form T &operator()(unsigned int row, unsigned int col). Purists may
argue that the correct method to access a matrix is with the
form, matrix[i][j], but I went with the simpler solution. The vector
class must support a constructor of form Vector<T>(unsigned int dimension)
and an access operator of the form T &operator[](unsigned int).

Listings 4 and 5 display the header and source file containing the LUP 
code. Listing 5 lists the following functions.

1) GaussianLUP_Pivot(Matrix<T> &m, Vector<int> &pv, T ep, T &sign) 
generates the LUP decomposition for the given matrix. It expects m
to contain the original matrix and it returns L and U stored in 
m, that is, m is overwritten with L and U. pv is the permutation vector
which tracks how rows were switched during Gaussian elimination. ep
is the epsilon used to determine if a matrix is singular and 
sign is used to calculate determinants. If epsilon (ep) is less than 
or equal to zero, then the template function calcEpsilon() is called 
to calculate it.

2) SolveUsingGaussianLUP_Pivot(Matrix<T> &m, Vector<T> &x, Vector<T> &y, 
Vector<int> &pv, T ep) calculates and returns the solution vector x for 
a given matrix m and vector y. It expects m to contain the matrices L 
and U, pv the permutation vector and ep to equal the epsilon.

3) GetInverseUsingGaussianLUP_Pivot(Matrix<T> &m, Matrix<T> &minv, 
Vector<int> &pv, T ep) calculates and returns the inverse of m in the
matrix minv. It expects m to contain the matrices L and U, pv the 
permutation vector and ep to equal the epsilon.

Listing 5 displays a template function calcEpsilon() which calculates 
the smallest difference that is representable for a given data type.
These values are used to determine if a matrix is singular. If the values 
are too small, then they can be scaled. On a SUN workstation the epsilon 
calculated for float and double match the values stored in header float.h,
FLT_EPSILON and DBL_EPSILON, respectively. 

IV EXAMPLE

Listing 6 displays a sample program which calculates the LUP decomposition 
for a matrix, then it uses the results to calculate the X vector for a given
Y vector, and to calculate the inverse matrix. The solution vector X and
the inverse matrix are printed.

V CONCLUSIONS

The original version of this code was written in Fortran 77 over
10 years ago. Recently I rewrote the code for a numerical methods
class that I teach at a local 2-year college. Finally, I completely
rewrote and updated the algorithm using C++. Since then its main 
use has been for least-squares fit and optimization.

VI ACKNOWLEDGMENTS

I would like to thank K. B. Williams for his comments and review of the 
LUP code, and Mary M. Clarke for her encouragement and support at Lucent. 
They are both gratefully acknowledged.
 
VII REFERENCES

[1] Numerical Methods: The Art of Scientific Computing. William H.
Press, Brian P. Flannery, Saul A. Teukolsky, and William T. Vetterling
(Cambridge University Press, 1987).

[2] Terrence J. Akai. Applied Numerical Methods for Engineers (John
Wiley, 1994).

[3] Lee W. Johnson and R. Dean Riess. Numerical Methods (Addison-Wesley, 1982).

[4] David Kincaid and Ward Cheney. Numerical Methods: Mathematics of
Scientific Computing (Brooks/Cole, 1991).

============================== Listing 1 - vector.h ======================

#ifndef __VECTOR_H
#define __VECTOR_H
// vector class

// headers
#include <stdlib.h>
#include <iostream.h>
#include <math.h>
#include <errno.h>

// local headers
#include "returns.h"
#include "debug.h"

// forward declarations
template <class T> class Vector;
template <class T> Vector<T> conj(const Vector<T> &);
template <class T> T dot(const Vector<T> &, const Vector<T> &);
template <class T> T norm(const Vector<T> &);

// vector class definition
template <class T> class Vector
{
public:
	 // constructors and destructor
	 Vector(unsigned int);
	 Vector(const T *, unsigned int);
	 Vector(const Vector<T> &);
	 ~Vector();

	 // assignment
	 Vector<T> &operator=(const Vector<T> &);
	 T &operator[](unsigned int);
	 T &operator[](unsigned int) const;

	 // vector operations
	 Vector<T> &operator+=(const Vector<T> &);
	 Vector<T> &operator-=(const Vector<T> &);
	 Vector<T> operator+(const Vector<T> &) const;
	 Vector<T> operator-(const Vector<T> &) const;

	 // arithmetic operations
	 Vector<T> &operator*=(const T &);
	 Vector<T> &operator/=(const T &);
	 Vector<T> operator*(const T &) const;
	 Vector<T> operator/(const T &) const;
	 friend Vector<T> operator*(const T &n, const Vector<T> &v) {
		return(Vector<T>(v) *= n);
	}

	 // logical operators
	 int operator==(const Vector<T> &) const;
	 int operator!=(const Vector<T> &) const;

	 // vector products
	 friend Vector<T> conj(const Vector<T> &);
	 friend T dot(const Vector<T> &, const Vector<T> &);
	 friend T norm(const Vector<T> &);

	 // miscellaneous 
	 inline unsigned int getDimension() const { 
		  return(dimension);
	 }
	 void dump(ostream &) const;
	 friend ostream &operator<<(ostream &os, const Vector<T> &v) {
		v.dump(os);
		return(os);
	}

protected:
	 // data
	 unsigned int dimension;
	 T *vector;
};

#endif
============================== Listing 2 - matrix.h ======================

#ifndef __MATRIX_H
#define __MATRIX_H

// matrix class definitions

// headers
#include <stdlib.h>
#include <iostream.h>
#include <math.h>

// local headers
#include "returns.h"
#include "debug.h"
#include "vector.h"
#include "epsilon.h"

// forward declarations
template <class T> class Matrix;
template <class T> Vector<T> operator*(const Vector<T> &, const Matrix<T> &);
template <class T> Matrix<T> operator*(const T &, const Matrix<T> &);
template <class T> Matrix<T> operator*(T, const Matrix<T> &);
template <class T> ostream &operator<<(ostream &, const Matrix<T> &);

// matrix class definition
template <class T> class Matrix
{
public:
	// constructors and destructor
	Matrix(unsigned int, unsigned int);
	Matrix(const Matrix<T> &);
	~Matrix();

	// assignment operators and accessors
	Matrix<T> &operator=(const Matrix<T> &);
	T &operator[](unsigned int);
	T &operator[](unsigned int) const;
	T &operator()(unsigned int, unsigned int);
	T &operator()(unsigned int, unsigned int) const;

	// matrix operations
	Matrix<T> &operator+=(const Matrix<T> &);
	Matrix<T> &operator-=(const Matrix<T> &);
	Matrix<T> &operator*=(const Matrix<T> &);
	Matrix<T> operator+(const Matrix<T> &) const;
	Matrix<T> operator-(const Matrix<T> &) const;
	Matrix<T> operator*(const Matrix<T> &) const;

	// matrix and vector operations
	Vector<T> operator*(const Vector<T> &) const;
	friend Vector<T> operator*(const Vector<T> &, const Matrix<T> &);

	// matrix and scalar operations
	Matrix<T> &operator*=(const T &);
	Matrix<T> &operator/=(const T &);
	Matrix<T> operator*(const T &) const;
	Matrix<T> operator/(const T &) const;
	friend Matrix<T> operator*(const T &, const Matrix<T> &);

	// logical operators
	int operator==(const Matrix<T> &) const;
	int operator!=(const Matrix<T> &) const;

	// other functions
	inline unsigned int getRows() { return(nrows); }
	inline unsigned int getCols() { return(ncols); }
	void dump(ostream &) const;
	friend ostream &operator<<(ostream &, const Matrix<T> &);

	// get epsilon 
	T getEpsilon() {
		return(epsilon);
	}

protected:
	// internal data
	T *matrix;
	unsigned int nrows, ncols;
	T epsilon;
};

#endif

============================== Listing 3 - gausslup.h ======================

#ifndef __GAUSSLUP_H
#define __GAUSSLUP_H

// gaussian LUP decomposition definitions

// headers
#include <stdlib.h>
#include <iostream.h>
#include <math.h>

// local headers
#include "returns.h"
#include "debug.h"
#include "vector.h"
#include "matrix.h"
#include "epsilon.h"

// calculates gaussian LUP decomposition for a matrix.
template <class T>
int
GaussianLUP_Pivot(Matrix<T> &, Vector<int> &, T, T &);

// solves set of linear equations using results of 
// gaussian LUP decomposition
template <class T>
int
SolveUsingGaussianLUP_Pivot(Matrix<T> &, 
	Vector<T> &, Vector<T> &, Vector<int> &, T);

// calculate the inverse using gaussian LUP results
template <class T>
int
GetInverseUsingGaussianLUP_Pivot(Matrix<T> &, 
	Matrix<T> &, Vector<int> &, T);

#endif

============================== Listing 4 - gausslup.c ======================

// required headers
#include "gausslup.h"

//
// given a matrix, generate an LUP decomposition using Gaussian
// elimination with scaling and pivoting.
//
template <class T>
int
GaussianLUP_Pivot(Matrix<T> &m, Vector<int> &p, T ep, T &sign)
{
	// must be a square matrix
	MustBeTrue(m.getRows() == m.getCols() && m.getRows() > 0);
	sign = -1;

	// check epsilon, set if invalid
	T minep = calcEpsilon(T(0));
	if ((ep = fabs(ep)) < minep)
		ep = minep;

	// get number of rows and columns
	int max = m.getRows();

	// generate scaling information for each row. initialize 
	// permutation array, p.
	int i;
	Vector<T> s(max);
	for (i = 0; i < max; i++)
	{
		p[i] = i;
		if (1 < max)
			s[i] = fabs(m(i, 1));
		else
			s[i] = fabs(m(i, 0));
		for (int j = 2; j < max; j++)
		{
			T tmp = fabs(m(i, j));
			if (tmp > s[i])
				s[i] = tmp;
		}
	}

	// start gaussian elimination process
	for (int k = 0; k < (max-1); k++)
	{
		// find pivot row
		int pivot = k;
		T tmpf = fabs(m(p[pivot], k))/s[p[pivot]];
		for (i = k+1; i < max; i++)
		{
			T tmpf2 = fabs(m(p[i], k))/s[p[i]];
			if (tmpf2 > tmpf)
			{
				pivot = i;
				tmpf = tmpf2;
			}
		}
		if (pivot != k)
		{
			int tmpp = p[k];
			p[k] = p[pivot];
			p[pivot] = tmpp;
			sign = -sign;
		}

		// check for division by zero
		if (fabs(m(p[k], k)) <= ep)
			return(NOTOK);

		// calculate L and U matrices
		for (i = k+1; i < max; i++)
		{
			// multiplier for column
			T d = m(p[i], k)/m(p[k], k);

			// save multiplier since it is L.
			m(p[i], k) = d;

			// reduce original matrix to get U.
			for (int j = k+1; j < max; j++)
			{
				m(p[i], j) -= d*m(p[k], j);
			}
		}
	}

	// all done
	return(OK);
}

//
// given a gaussian LUP decomposition of a matrix and a permutation vector,
// solve for x-vector using the given y-vector.
//
template <class T>
int
SolveUsingGaussianLUP_Pivot(Matrix<T> &m, 
	Vector<T> &x, Vector<T> &y, Vector<int> &p, T ep)
{
	// must be a square matrix
	MustBeTrue(m.getRows() == m.getCols() && m.getRows() > 0);

	// check epsilon, set if invalid
	T minep = calcEpsilon(T(0));
	if ((ep = fabs(ep)) < minep)
		ep = minep;

	// get number of rows and columns
	int max = m.getRows();

	// update y-vector
	for (int k = 0; k < (max-1); k++)
	{
		for (int i = k+1; i < max; i++)
		{
			y[p[i]] -= m(p[i], k)*y[p[k]];
		}
	}

	// start backward substitution
	for (int i = max-1; i >= 0; i--)
	{
		// check for a singular matrix
		if (fabs(m(p[i], i)) <= ep)
			return(NOTOK);

		// solve for x by substituting previous solutions
		x[i] = y[p[i]];
		for (int j = i+1; j < max; j++)
		{
			x[i] -= m(p[i], j)*x[j];
		}
		x[i] /= m(p[i], i);
	}

	// all done
	return(OK);
}

//
// given a gaussian LUP decomposition of a matrix and a permutation vector,
// calculate the inverse of the original matrix.
//
template <class T>
int
GetInverseUsingGaussianLUP_Pivot(Matrix<T> &m, Matrix<T> &minv, Vector<int> &p, T ep)
{
	// must be a square matrix
	MustBeTrue(m.getRows() == m.getCols() && m.getRows() > 0);
	MustBeTrue(minv.getRows() == minv.getCols() && minv.getRows() > 0);
	MustBeTrue(minv.getRows() == m.getCols());

	// get number of rows and columns
	int max = m.getRows();

	// update inverse matrix
	for (int i = 0; i < max; i++)
	{
		// initialize column vector
		Vector<T> y(max);
		int j;
		for (j = 0; j < max; j++)
		{
			y[j] = 0;
		}
		y[i] = 1;

		// solve for corresponding vector in inverse
		Vector<T> x(max);
		if (SolveUsingGaussianLUP_Pivot(m, x, y, p, ep) != OK)
			return(NOTOK);

		// transfer results to inverse matrix
		for (j = 0; j < max; j++)
		{
			minv(j, i) = x[j];
		}
	}

	// all done
	return(OK);
}

============================== Listing 5 - epsilon.c ======================

#include "epsilon.h"

template <class T>
T
calcEpsilon(T)
{
	T f1 = 1.0;
	T f2 = 1.0;
	T oldf2 = 0.0;

	for (f2 /= 2.0; ((f1-f2) != f1); oldf2=f2, f2 /= 2.0) ;
	return(T(2.0)*oldf2);
}

============================== Listing 6 - example.c ======================

// gaussian LUP header, matrix header, vector header, etc.
#include "gausslup.h"

double data[] = {
	33.0, 16.0, 72.0,
	-24.0, -10.0, -57.0,
	-8.0, -4.0, -17.0,
	-359.0, 281.0, 85.0
};
 
// test driver
main(int , char **)
{
	// output precision
	cout.precision(6);
	cout.setf(ios::showpoint);

	// define matrix and initialize elements
	int nrows = 3;
	int ncols = 3;
	int idata = 0;
	int ir = 0;
	Matrix<double> m(nrows, ncols);
	for ( ; ir < nrows; ir++)
	{
		for (int ic = 0; ic < ncols; ic++)
		{
			m(ir, ic) = data[idata++];
		}
	}
	cout << "TEST MATRIX IS ... " << endl;
	cout << m << endl;
	Matrix<double> msave(m);

	// initialize inhomogeneous part.
	Vector<double> y(nrows);
	for (ir = 0; ir < nrows; ir++)
	{
		y[ir] = data[idata++];
	}
	cout << "TEST Y-VECTOR IS ... " << endl;
	cout << y << endl << endl;

	// get LUP decomposition
	Vector<int> pv(nrows);
	double determinant;
	MustBeTrue(GaussianLUP_Pivot(m, pv, 0.0, determinant) == OK);

	// get solution using LUP results
	Vector<double> x(nrows);
	MustBeTrue(SolveUsingGaussianLUP_Pivot(m, x, y, pv, 0.0) == OK);
	cout << "SOLUTION X IS ... " << x << endl << endl;

	// get inverse using LUP results
	Matrix<double> minv(nrows, ncols);
	MustBeTrue(GetInverseUsingGaussianLUP_Pivot(m, minv, pv, 0.0) == OK)
	cout << "INVERSE OF M IS ... " << endl << endl;
	cout << minv << endl;
	cout << "M*MINV IS ... " << endl;
	cout << msave*minv << endl << endl;

	return(0);
}

