1) you can define an array by assigning a vector to the
dim() attribute of an object.

> dim(a) <- c(3,4)
Error in dim(a) <- c(3, 4) : object 'a' not found
> a <- c(1:20)
> dim(a) <- c(4,5)
> a
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20

other ways is use matrix() or array().

> x <- array(1:20, dim=c(4,5))
> x
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    9   13   17
[2,]    2    6   10   14   18
[3,]    3    7   11   15   19
[4,]    4    8   12   16   20

generate an array of indexes:

> i <- array(c(1:3,3:1), dim=c(3,2))
> i
     [,1] [,2]
[1,]    1    3
[2,]    2    2
[3,]    3    1

use index array to access the other matrix.

> x[i]
[1] 9 6 3

reset selected values to zero.

> x[i] <- 0
> 
> x
     [,1] [,2] [,3] [,4] [,5]
[1,]    1    5    0   13   17
[2,]    2    0   10   14   18
[3,]    0    7   11   15   19
[4,]    4    8   12   16   20

2) an use array to initialize and create n-dimensional arrays, 
simple arithmetic can also be performs. however the operations
are element-by-element and this is WRONG for matrix multiplication.

> h <- 1:24
> 
> h
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
> 
> Z <- array(h, c(3,4,2))
> Z
, , 1

     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12

, , 2

     [,1] [,2] [,3] [,4]
[1,]   13   16   19   22
[2,]   14   17   20   23
[3,]   15   18   21   24

> 
> Z <- array(0, c(3,4,2))
> Z
, , 1

     [,1] [,2] [,3] [,4]
[1,]    0    0    0    0
[2,]    0    0    0    0
[3,]    0    0    0    0

, , 2

     [,1] [,2] [,3] [,4]
[1,]    0    0    0    0
[2,]    0    0    0    0
[3,]    0    0    0    0

> dim(Z)
[1] 3 4 2
> 
> ls()
[1] "a" "h" "i" "x" "Z"
> 
> A <- array(1, c(3,3))
> A
     [,1] [,2] [,3]
[1,]    1    1    1
[2,]    1    1    1
[3,]    1    1    1
> B <- array(1, c(3,3))
> B <- array(2, c(3,3))
> B
     [,1] [,2] [,3]
[1,]    2    2    2
[2,]    2    2    2
[3,]    2    2    2
> C <- array(3, c(3,3))
> 
> D <- 2*A*B + C
> D
     [,1] [,2] [,3]
[1,]    7    7    7
[2,]    7    7    7
[3,]    7    7    7
> A
     [,1] [,2] [,3]
[1,]    1    1    1
[2,]    1    1    1
[3,]    1    1    1
> B
     [,1] [,2] [,3]
[1,]    2    2    2
[2,]    2    2    2
[3,]    2    2    2
> C
     [,1] [,2] [,3]
[1,]    3    3    3
[2,]    3    3    3
[3,]    3    3    3

3) outer products can be used to combine two matrices. it works
like a set product, ie, one element from one set is combined
with an element from the second set, the coordinates are concatenated.

> a <- array(1:16, dim=c(2,2))
> a
     [,1] [,2]
[1,]    1    3
[2,]    2    4
> b <- array(2*(1:16), dim=c(2,2))
> b
     [,1] [,2]
[1,]    2    6
[2,]    4    8
> ab <- a %o% b
> ab
, , 1, 1

     [,1] [,2]
[1,]    2    6
[2,]    4    8

, , 2, 1

     [,1] [,2]
[1,]    4   12
[2,]    8   16

, , 1, 2

     [,1] [,2]
[1,]    6   18
[2,]   12   24

, , 2, 2

     [,1] [,2]
[1,]    8   24
[2,]   16   32


> cd <- outer(a,b,"*")
> cd
, , 1, 1

     [,1] [,2]
[1,]    2    6
[2,]    4    8

, , 2, 1

     [,1] [,2]
[1,]    4   12
[2,]    8   16

, , 1, 2

     [,1] [,2]
[1,]    6   18
[2,]   12   24

, , 2, 2

     [,1] [,2]
[1,]    8   24
[2,]   16   32

4) you can also define your own function and use outer() to
evaluate it.

> x <- 1:10
> x
 [1]  1  2  3  4  5  6  7  8  9 10
> y <- 0.5*(1:10)
> y
 [1] 0.5 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0
> f <- function(x,y) cos(y)/(1+x^2)
> z <- outer(x,y,f)
> z
             [,1]        [,2]         [,3]         [,4]         [,5]
 [1,] 0.438791281 0.270151153 0.0353686008 -0.208073418 -0.400571808
 [2,] 0.175516512 0.108060461 0.0141474403 -0.083229367 -0.160228723
 [3,] 0.087758256 0.054030231 0.0070737202 -0.041614684 -0.080114362
 [4,] 0.051622504 0.031782489 0.0041610119 -0.024479226 -0.047126095
 [5,] 0.033753175 0.020780858 0.0027206616 -0.016005648 -0.030813216
 [6,] 0.023718448 0.014602765 0.0019118163 -0.011247212 -0.021652530
 [7,] 0.017551651 0.010806046 0.0014147440 -0.008322937 -0.016022872
 [8,] 0.013501270 0.008312343 0.0010882646 -0.006402259 -0.012325286
 [9,] 0.010702226 0.006589053 0.0008626488 -0.005074961 -0.009770044
[10,] 0.008688936 0.005349528 0.0007003683 -0.004120266 -0.007932115
              [,6]         [,7]         [,8]         [,9]       [,10]
 [1,] -0.494996248 -0.468228344 -0.326821810 -0.105397900 0.141831093
 [2,] -0.197998499 -0.187291337 -0.130728724 -0.042159160 0.056732437
 [3,] -0.098999250 -0.093645669 -0.065364362 -0.021079580 0.028366219
 [4,] -0.058234853 -0.055085687 -0.038449625 -0.012399753 0.016686011
 [5,] -0.038076634 -0.036017565 -0.025140139 -0.008107531 0.010910084
 [6,] -0.026756554 -0.025309640 -0.017666044 -0.005697184 0.007666546
 [7,] -0.019799850 -0.018729134 -0.013072872 -0.004215916 0.005673244
 [8,] -0.015230654 -0.014407026 -0.010056056 -0.003243012 0.004364034
 [9,] -0.012073079 -0.011420204 -0.007971264 -0.002570680 0.003459295
[10,] -0.009801906 -0.009271848 -0.006471719 -0.002087087 0.002808536

5) example to plot 2x2 matrix determinants. weird:

> d <- outer(0:9, 0:9)
> d
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
 [1,]    0    0    0    0    0    0    0    0    0     0
 [2,]    0    1    2    3    4    5    6    7    8     9
 [3,]    0    2    4    6    8   10   12   14   16    18
 [4,]    0    3    6    9   12   15   18   21   24    27
 [5,]    0    4    8   12   16   20   24   28   32    36
 [6,]    0    5   10   15   20   25   30   35   40    45
 [7,]    0    6   12   18   24   30   36   42   48    54
 [8,]    0    7   14   21   28   35   42   49   56    63
 [9,]    0    8   16   24   32   40   48   56   64    72
[10,]    0    9   18   27   36   45   54   63   72    81
> fr <- table(outer(d,d,"-"))
> fr

-81 -80 -79 -78 -77 -76 -75 -74 -73 -72 -71 -70 -69 -68 -67 -66 -65 -64 -63 -62 
 19   1   2   2   3   2   4   2   4  41   4   4   8   6   6  10   7  27  49   8 
-61 -60 -59 -58 -57 -56 -55 -54 -53 -52 -51 -50 -49 -48 -47 -46 -45 -44 -43 -42 
  8  17   8  12  18  53  13  60  12  18  22  16  35  70  22  24  66  28  18  72 
-41 -40 -39 -38 -37 -36 -35 -34 -33 -32 -31 -30 -29 -28 -27 -26 -25 -24 -23 -22 
 22  75  37  34  26 111  63  36  45  84  34  94  36  93  97  50  53 156  42  60 
-21 -20 -19 -18 -17 -16 -15 -14 -13 -12 -11 -10  -9  -8  -7  -6  -5  -4  -3  -2 
103 107  50 168  51 140 112 116  59 191  65 126 156 185 115 206 117 179 153 156 
 -1   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18 
111 570 111 156 153 179 117 206 115 185 156 126  65 191  59 116 112 140  51 168 
 19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38 
 50 107 103  60  42 156  53  50  97  93  36  94  34  84  45  36  63 111  26  34 
 39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54  55  56  57  58 
 37  75  22  72  18  28  66  24  22  70  35  16  22  18  12  60  13  53  18  12 
 59  60  61  62  63  64  65  66  67  68  69  70  71  72  73  74  75  76  77  78 
  8  17   8   8  49  27   7  10   6   6   8   4   4  41   4   2   4   2   3   2 
 79  80  81 
  2   1  19 
> plot(as.numeric(names(fr)), fr, type="h",
+ xlab="Determinant", ylab="Frequency")

6) permutation of indices is done using aperm() where the
second argument is a vector which maps old index to new index.

> B <- array(1:16, dim=c(4,4))
> B
     [,1] [,2] [,3] [,4]
[1,]    1    5    9   13
[2,]    2    6   10   14
[3,]    3    7   11   15
[4,]    4    8   12   16

the next example of aperm() maps 1 -> 2 and 2 -> 1, ie, rows become
columns, and columns become rows, a transpose.

> Bt <- aperm(B, c(2,1))
> Bt
     [,1] [,2] [,3] [,4]
[1,]    1    2    3    4
[2,]    5    6    7    8
[3,]    9   10   11   12
[4,]   13   14   15   16

t() is internal transpose function. it gives the same reults as
above.

> 
> Bt2 <- t(B)
> Bt2
     [,1] [,2] [,3] [,4]
[1,]    1    2    3    4
[2,]    5    6    7    8
[3,]    9   10   11   12
[4,]   13   14   15   16

7) real matrix multiplication done using %*% operator.

> A <- array(0.3*(1:16), dim=c(4,4))
> A
     [,1] [,2] [,3] [,4]
[1,]  0.3  1.5  2.7  3.9
[2,]  0.6  1.8  3.0  4.2
[3,]  0.9  2.1  3.3  4.5
[4,]  1.2  2.4  3.6  4.8
> B
     [,1] [,2] [,3] [,4]
[1,]    1    5    9   13
[2,]    2    6   10   14
[3,]    3    7   11   15
[4,]    4    8   12   16
> A*B
     [,1] [,2] [,3] [,4]
[1,]  0.3  7.5 24.3 50.7
[2,]  1.2 10.8 30.0 58.8
[3,]  2.7 14.7 36.3 67.5
[4,]  4.8 19.2 43.2 76.8
> A %*% B
     [,1] [,2]  [,3]  [,4]
[1,]   27 60.6  94.2 127.8
[2,]   30 68.4 106.8 145.2
[3,]   33 76.2 119.4 162.6
[4,]   36 84.0 132.0 180.0
> 
> x <- 1:4
> X %*% A %*% x
Error: object 'X' not found
> x %*% A %*% x
     [,1]
[1,]  330

8) linear equations and inversion:

solve x = A*b:

> A <- array(c(1.4, 5.6, 0.33, 0.45), dim=c(2,2))
> A
     [,1] [,2]
[1,]  1.4 0.33
[2,]  5.6 0.45
> b <- c(0.1, 2.0)
> solve(A,b)
[1]  0.5049261 -1.8390805

get the inverse of A:

> solve(A)
           [,1]      [,2]
[1,] -0.3694581  0.270936
[2,]  4.5977011 -1.149425

using inverse gets the same solution as above, but this
is very unstable.

> solve(A) %*% b
           [,1]
[1,]  0.5049261
[2,] -1.8390805

9) calculating eigenvalues and vectors:

> A
     [,1] [,2]
[1,]  1.4 0.33
[2,]  5.6 0.45
> 
> ev <- eigen(A)
> 
> ev
$values
[1]  2.3650087 -0.5150087

$vectors
          [,1]       [,2]
[1,] 0.3235696 -0.1698200
[2,] 0.9462044  0.9854751

> ev$values
[1]  2.3650087 -0.5150087
> 
> ev$vectors
          [,1]       [,2]
[1,] 0.3235696 -0.1698200
[2,] 0.9462044  0.9854751

for large matrice it is better to NOT calculate vectors, just the 
values:

> ev <- eigen(A, only.values=TRUE)
> ev
$values
[1]  2.3650087 -0.5150087

$vectors
NULL

> ev <- eigen(A, only.values=TRUE)$values
> ev
[1]  2.3650087 -0.5150087

10) singular value decomposition of a matrix:

> svd(A)
$d
[1] 5.7954491 0.2101649

$u
           [,1]       [,2]
[1,] -0.2456871 -0.9693492
[2,] -0.9693492  0.2456871

$v
            [,1]        [,2]
[1,] -0.99600864  0.08925691
[2,] -0.08925691 -0.99600864

calculate the determinant:

> 
> prod(svd(A)$d)
[1] 1.218
> 
> 

define a function to calculate the determinant:

> absdet <- function(M) prod(svd(M)%d)
Error: unexpected input in "absdet <- function(M) prod(svd(M)%d)"
> absdet <- function(M) prod(svd(M)$d)
> 
> absdet(A)
[1] 1.218

11) least squares fit:

can use lsfit() but prefer newer lm().

> x <- 1:20
> x
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
> y <- 2*x + 5
> y
 [1]  7  9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45
> ans <- lsfit(x,y)
> ans
$coefficients
Intercept         X 
        5         2 

$residuals
 [1]  1.363183e-14 -4.194586e-15 -2.245426e-15 -2.040037e-15 -2.722826e-15
 [6] -1.629259e-15 -9.797807e-16 -1.218481e-15 -1.013092e-15 -8.077032e-16
[11] -6.023143e-16 -3.969254e-16 -1.915365e-16  1.385237e-17  2.192413e-16
[16]  4.246302e-16  6.300191e-16  8.354080e-16  1.040797e-15  1.246186e-15

$intercept
[1] TRUE

$qr
$qt
 [1] -1.162755e+02  5.157519e+01 -3.552714e-15 -3.552714e-15 -4.440892e-15
 [6] -3.552714e-15 -3.108624e-15 -3.552714e-15 -3.552714e-15 -3.552714e-15
[11] -3.552714e-15 -3.552714e-15 -3.552714e-15 -3.552714e-15 -3.552714e-15
[16] -3.552714e-15 -3.552714e-15 -3.552714e-15 -3.552714e-15 -3.552714e-15

$qr
       Intercept             X
 [1,] -4.4721360 -46.957427527
 [2,]  0.2236068  25.787593916
 [3,]  0.2236068   0.223515697
 [4,]  0.2236068   0.184737360
 [5,]  0.2236068   0.145959023
 [6,]  0.2236068   0.107180687
 [7,]  0.2236068   0.068402350
 [8,]  0.2236068   0.029624013
 [9,]  0.2236068  -0.009154324
[10,]  0.2236068  -0.047932660
[11,]  0.2236068  -0.086710997
[12,]  0.2236068  -0.125489334
[13,]  0.2236068  -0.164267670
[14,]  0.2236068  -0.203046007
[15,]  0.2236068  -0.241824344
[16,]  0.2236068  -0.280602681
[17,]  0.2236068  -0.319381017
[18,]  0.2236068  -0.358159354
[19,]  0.2236068  -0.396937691
[20,]  0.2236068  -0.435716027

$qraux
[1] 1.223607 1.262294

$rank
[1] 2

$pivot
[1] 1 2

$tol
[1] 1e-07

attr(,"class")
[1] "qr"

12) can also use a QR reduction and calculat the same data as above:

> xplus <- qr(x)
> xplus
$qr
              [,1]
 [1,] -53.57238094
 [2,]   0.03733267
 [3,]   0.05599900
 [4,]   0.07466534
 [5,]   0.09333167
 [6,]   0.11199801
 [7,]   0.13066434
 [8,]   0.14933068
 [9,]   0.16799701
[10,]   0.18666335
[11,]   0.20532968
[12,]   0.22399602
[13,]   0.24266235
[14,]   0.26132869
[15,]   0.27999502
[16,]   0.29866136
[17,]   0.31732769
[18,]   0.33599403
[19,]   0.35466036
[20,]   0.37332670

$rank
[1] 1

$qraux
[1] 1.018666

$pivot
[1] 1

attr(,"class")
[1] "qr"
> b <- qr.coef(xplus, y)
> b
[1] 2.365854
> fit <- qr.fitted(xplus, y)
> fit
 [1]  2.365854  4.731707  7.097561  9.463415 11.829268 14.195122 16.560976
 [8] 18.926829 21.292683 23.658537 26.024390 28.390244 30.756098 33.121951
[15] 35.487805 37.853659 40.219512 42.585366 44.951220 47.317073
> res <- qr.resid(xplus, y)
> res
 [1]  4.6341463  4.2682927  3.9024390  3.5365854  3.1707317  2.8048780
 [7]  2.4390244  2.0731707  1.7073171  1.3414634  0.9756098  0.6097561
[13]  0.2439024 -0.1219512 -0.4878049 -0.8536585 -1.2195122 -1.5853659
[19] -1.9512195 -2.3170732
> 

13) matrices or arrays can be built from simpler arrays or matrices 
using the functions: cbind, column-bind and rbind, row-bind.

c() can also concatenate arrays. it will flatten out the array to a list.

vec <- as.vector(Matrix)

is the same as:

vec <- c(Matrix)

but as.vector is the preferred way.


14) frequency tables using factors. use previous data.

read in data:

> source("data.cmds")
> ls()
 [1] "a"       "A"       "ab"      "absdet"  "ans"     "b"       "B"      
 [8] "Bt"      "Bt2"     "C"       "cd"      "d"       "D"       "ev"     
[15] "f"       "fit"     "fr"      "h"       "i"       "incomes" "res"    
[22] "state"   "statef"  "x"       "xplus"   "y"       "z"       "Z"      
> state
 [1] "tas" "qld" "sa"  "sa"  "sa"  "vic" "nt"  "act" "qld" "nsw" "wa"  "nsw"
[13] "nsw" "vic" "vic" "vic" "nsw" "qld" "qld" "vic" "nt"  "wa"  "wa"  "qld"
[25] "sa"  "tas" "nsw" "nsw" "wa"  "act"

> statef
 [1] tas qld sa  sa  sa  vic nt  act qld nsw wa  nsw nsw vic vic vic nsw qld qld
[20] vic nt  wa  wa  qld sa  tas nsw nsw wa  act
Levels: act nsw nt qld sa tas vic wa
> 
> statefr <- table(statef)
> statefr
statef
act nsw  nt qld  sa tas vic  wa 
  2   6   2   5   4   2   5   4 

> factor(cut(incomes, breaks = 35+10*(0:7))) -> incomef
> incomef
 [1] (55,65] (45,55] (35,45] (55,65] (55,65] (55,65] (55,65] (45,55] (55,65]
[10] (65,75] (65,75] (35,45] (55,65] (55,65] (55,65] (55,65] (55,65] (45,55]
[19] (45,55] (55,65] (45,55] (45,55] (35,45] (45,55] (45,55] (45,55] (55,65]
[28] (45,55] (55,65] (35,45]
Levels: (35,45] (45,55] (55,65] (65,75]

> table(incomef,statef)
         statef
incomef   act nsw nt qld sa tas vic wa
  (35,45]   1   1  0   0  1   0   0  1
  (45,55]   1   1  1   4  1   1   0  1
  (55,65]   0   3  1   1  2   1   5  1
  (65,75]   0   1  0   0  0   0   0  1

